

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="李嘉图">
  <meta name="keywords" content="">
  
    <meta name="description" content="I2C通信：I2C集成电路总线是一种串行的通信总线，使用主从架构特点：只需要两条双向总线（SDA串行数据线、SCL串行时钟线）所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。I2C是真正的多主设备总线，可以提供仲裁和冲突检测。 CAN总线仲裁：CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C驱动框架学习">
<meta property="og:url" content="http://example.com/2023/09/28/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Linux Kernel tyro">
<meta property="og:description" content="I2C通信：I2C集成电路总线是一种串行的通信总线，使用主从架构特点：只需要两条双向总线（SDA串行数据线、SCL串行时钟线）所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。I2C是真正的多主设备总线，可以提供仲裁和冲突检测。 CAN总线仲裁：CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif">
<meta property="og:image" content="http://example.com/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png">
<meta property="og:image" content="http://example.com/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png">
<meta property="article:published_time" content="2023-09-28T13:43:49.000Z">
<meta property="article:modified_time" content="2023-09-30T05:04:11.983Z">
<meta property="article:author" content="李嘉图">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif">
  
  
  
  <title>I2C驱动框架学习 - Linux Kernel tyro</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Linux Kernel tyro</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/imgs/%E5%A3%81%E7%BA%B8/%E5%A3%81%E7%BA%B8.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="I2C驱动框架学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-28 21:43" pubdate>
          2023年9月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          145 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">I2C驱动框架学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="I2C通信："><a href="#I2C通信：" class="headerlink" title="I2C通信："></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>
<h3 id="CAN总线仲裁："><a href="#CAN总线仲裁：" class="headerlink" title="CAN总线仲裁："></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif" srcset="/img/loading.gif" lazyload><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>
<h3 id="数据传输协议："><a href="#数据传输协议：" class="headerlink" title="数据传输协议："></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>
<h4 id="开始条件："><a href="#开始条件：" class="headerlink" title="开始条件："></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>
<p><strong>地址位</strong>：</p>
<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>
<p><strong>读写位</strong>：</p>
<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>
<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>
<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>
<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>
<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>
<h3 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h3><p><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>
<h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>
<h6 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>
<h5 id="第四层："><a href="#第四层：" class="headerlink" title="第四层："></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>
<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>
<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>
<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>
<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>
<h5 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a>i2c_driver</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> &#123;</span><br>	<span class="hljs-type">int</span> id;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br> <br>	<span class="hljs-type">int</span> (*attach_adapter)(<span class="hljs-keyword">struct</span> i2c_adapter *);<br>	<span class="hljs-type">int</span> (*detach_adapter)(<span class="hljs-keyword">struct</span> i2c_adapter *);<br> <br>	<span class="hljs-type">int</span> (*detach_client)(<span class="hljs-keyword">struct</span> i2c_client *);<br> <br>	<span class="hljs-type">int</span> (*command)(<span class="hljs-keyword">struct</span> i2c_client *client,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">void</span> *arg);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>};</p>
<h5 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a>i2c_client</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;		<span class="hljs-comment">/* div., see below		*/</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr;		<span class="hljs-comment">/* chip address - <span class="hljs-doctag">NOTE:</span> 7bit 	*/</span><br>					<span class="hljs-comment">/* addresses are stored in the	*/</span><br>					<span class="hljs-comment">/* _LOWER_ 7 bits		*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span>	<span class="hljs-comment">/* the adapter we sit on	*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> *<span class="hljs-title">driver</span>;</span>	<span class="hljs-comment">/* and our access routines	*/</span><br>	<span class="hljs-type">int</span> usage_count;		<span class="hljs-comment">/* How many accesses currently  */</span><br>					<span class="hljs-comment">/* to the client		*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>		<span class="hljs-comment">/* the device structure		*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>	<span class="hljs-type">char</span> name[I2C_NAME_SIZE];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a>i2c_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span><span class="hljs-comment">/* the algorithm to access the bus	*/</span><br>	<span class="hljs-type">void</span> *algo_data;<br> <br>	<span class="hljs-comment">/* --- administration stuff. */</span><br>	<span class="hljs-type">int</span> (*client_register)(<span class="hljs-keyword">struct</span> i2c_client *);<br>	<span class="hljs-type">int</span> (*client_unregister)(<span class="hljs-keyword">struct</span> i2c_client *);<br> <br>	<span class="hljs-comment">/* data fields that are valid for all devices	*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">bus_lock</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">clist_lock</span>;</span><br> <br>	<span class="hljs-type">int</span> timeout;<br>	<span class="hljs-type">int</span> retries;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span>		<span class="hljs-comment">/* the adapter device */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_device</span> <span class="hljs-title">class_dev</span>;</span>	<span class="hljs-comment">/* the class device */</span><br> <br>	<span class="hljs-type">int</span> nr;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">clients</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>	<span class="hljs-type">char</span> name[I2C_NAME_SIZE];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">class_dev_released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a>i2c_algorithm</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> &#123;</span><br>	<span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap,<span class="hljs-keyword">struct</span> i2c_msg *msgs, <br>	                   <span class="hljs-type">int</span> num);<br>	<span class="hljs-type">int</span> (*slave_send)(<span class="hljs-keyword">struct</span> i2c_adapter *,<span class="hljs-type">char</span>*,<span class="hljs-type">int</span>);<br>	<span class="hljs-type">int</span> (*slave_recv)(<span class="hljs-keyword">struct</span> i2c_adapter *,<span class="hljs-type">char</span>*,<span class="hljs-type">int</span>);<br>	u32 (*functionality) (<span class="hljs-keyword">struct</span> i2c_adapter *);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="【i2c-adapter与i2c-algorithm】"><a href="#【i2c-adapter与i2c-algorithm】" class="headerlink" title="【i2c_adapter与i2c_algorithm】"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<pre><code class="hljs"> /*
  * I2C Message - used for pure i2c transaction, also from /dev interface
  */
 struct i2c_msg &#123;
     __u16 addr;	/* slave address			*/
  	__u16 flags;		
  	__u16 len;		/* msg length				*/
  	__u8 *buf;		/* pointer to msg data			*/
 &#125;;
</code></pre>
<h5 id="【i2c-driver和i2c-client】"><a href="#【i2c-driver和i2c-client】" class="headerlink" title="【i2c_driver和i2c_client】"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<h5 id="【i2c-adapter和i2c-client】"><a href="#【i2c-adapter和i2c-client】" class="headerlink" title="【i2c_adapter和i2c_client】"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">EXPORT_SYMBOL(i2c_add_adapter);<br>EXPORT_SYMBOL(i2c_del_adapter);<br>EXPORT_SYMBOL(i2c_del_driver);<br>EXPORT_SYMBOL(i2c_attach_client);<br>EXPORT_SYMBOL(i2c_detach_client);<br><br>EXPORT_SYMBOL(i2c_transfer);<br></code></pre></td></tr></table></figure>

<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter * adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num)</span><br>&#123;<br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class="hljs-comment">//如果master_xfer函数存在，则调用，否则返回错误</span><br>		ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class="hljs-comment">//这个函数在硬件相关的代码中给algorithm赋值</span><br>		<span class="hljs-keyword">return</span> ret;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> -ENOSYS;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_attach_client</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span><br>&#123;<br>	...<br>	device_register(&amp;client-&gt;dev);<br>	device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>	...<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_detach_client</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span><br>&#123;<br>	...<br>	device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>	device_unregister(&amp;client-&gt;dev);<br>	...<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* -----</span><br><span class="hljs-comment"> * i2c_add_adapter is called from within the algorithm layer,</span><br><span class="hljs-comment"> * when a new hw adapter registers. A new device is register to be</span><br><span class="hljs-comment"> * available for clients.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_add_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span><br>&#123;<br>	...<br>	device_register(&amp;adap-&gt;dev);<br>	device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>	...<br>	<span class="hljs-comment">/* inform drivers of new adapters */</span><br>	list_for_each(item,&amp;drivers) &#123;<br>		driver = list_entry(item, <span class="hljs-keyword">struct</span> i2c_driver, <span class="hljs-built_in">list</span>);<br>		<span class="hljs-keyword">if</span> (driver-&gt;attach_adapter)<br>			<span class="hljs-comment">/* We ignore the return code; if it fails, too bad */</span><br>			driver-&gt;attach_adapter(adap);<br>	&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">i2c_del_adapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adap)</span><br>&#123;<br>	...<br>	list_for_each(item,&amp;drivers) &#123;<br>		driver = list_entry(item, <span class="hljs-keyword">struct</span> i2c_driver, <span class="hljs-built_in">list</span>);<br>		<span class="hljs-keyword">if</span> (driver-&gt;detach_adapter)<br>			<span class="hljs-keyword">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;<br>			&#125;<br>	&#125;<br>	...<br>	list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;<br>		client = list_entry(item, <span class="hljs-keyword">struct</span> i2c_client, <span class="hljs-built_in">list</span>);<br> <br>		<span class="hljs-keyword">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;<br> <br>		&#125;<br>	&#125;<br>	...<br>	device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>	device_unregister(&amp;adap-&gt;dev);<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">davinci_i2c_driver</span> =</span> &#123;<br>	.probe		= davinci_i2c_probe,<br>	.remove		= davinci_i2c_remove,<br>	.driver		= &#123;<br>		.name	= <span class="hljs-string">&quot;i2c_davinci&quot;</span>,<br>		.owner	= THIS_MODULE,<br>	&#125;,<br>&#125;;<br> <br><span class="hljs-comment">/* I2C may be needed to bring up other drivers */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">davinci_i2c_init_driver</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> platform_driver_register(&amp;davinci_i2c_driver);<br>&#125;<br>subsys_initcall(davinci_i2c_init_driver);<br> <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">davinci_i2c_exit_driver</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	platform_driver_unregister(&amp;davinci_i2c_driver);<br>&#125;<br>module_exit(davinci_i2c_exit_driver);<br></code></pre></td></tr></table></figure>

<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> <span class="hljs-title">i2c_davinci_algo</span> =</span> &#123;<br>	.master_xfer	= i2c_davinci_xfer,<br>	.functionality	= i2c_davinci_func,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">adap-&gt;algo = &amp;i2c_davinci_algo;<br></code></pre></td></tr></table></figure>


<h3 id="梳理图"><a href="#梳理图" class="headerlink" title="梳理图"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>
<p><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png" srcset="/img/loading.gif" lazyload></p>
<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>
<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>
<h4 id="ov2715设备i2c驱动源码分析"><a href="#ov2715设备i2c驱动源码分析" class="headerlink" title="ov2715设备i2c驱动源码分析"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><br>  <span class="hljs-type">int</span> devAddr;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> <span class="hljs-title">client</span>;</span>   <span class="hljs-comment">//!&lt; Data structure containing general access routines.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">driver</span>;</span>   <span class="hljs-comment">//!&lt; Data structure containing information specific to each client.</span><br><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>  <span class="hljs-type">int</span> nameSize;<br>  <span class="hljs-type">int</span> users;<br><br>&#125; I2C_Obj;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>             <span class="hljs-comment">/* Char device structure    */</span><br>  <span class="hljs-type">int</span>     major;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">semLock</span>;</span><br>    <br>  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];<br> <br>  <span class="hljs-type">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class="hljs-type">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class="hljs-type">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class="hljs-number">4</span>];<br>  <br>&#125; I2C_Dev;<br></code></pre></td></tr></table></figure>

<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_devInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span>     result, i;<br>  <span class="hljs-type">dev_t</span>   dev = <span class="hljs-number">0</span>;<br> <br>  result = alloc_chrdev_region(&amp;dev, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, I2C_DRV_NAME);<span class="hljs-comment">//分配字符设备空间</span><br>  <br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)<br>  &#123;<br>    gI2C_dev.pObj[i]=<span class="hljs-literal">NULL</span>;<br>  &#125;<br> <br>  gI2C_dev.major = MAJOR(dev);<span class="hljs-comment">//保存设备主编号</span><br>  sema_init(&amp;gI2C_dev.semLock, <span class="hljs-number">1</span>);<span class="hljs-comment">//信号量初始化</span><br>  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class="hljs-comment">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span><br>  gI2C_dev.cdev.owner = THIS_MODULE;<span class="hljs-comment">//常规赋值</span><br> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class="hljs-comment">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span><br>gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">gI2C_devFileOps</span> =</span> &#123;<br>  .owner = THIS_MODULE,<br>  .open = I2C_devOpen,<br>  .release = I2C_devRelease,<br>  .ioctl = I2C_devIoctl,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_devIoctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>  I2C_Obj *pObj;<br>  <span class="hljs-type">int</span> status=<span class="hljs-number">0</span>;<br>  I2C_TransferPrm transferPrm;<br>  <br>  pObj = (I2C_Obj *)filp-&gt;private_data;<br> <br>  <span class="hljs-keyword">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  cmd = I2C_IOCTL_CMD_GET(cmd);<span class="hljs-comment">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span><br> <br>  down_interruptible(&amp;gI2C_dev.semLock);      <span class="hljs-comment">//信号量down</span><br>  <br>  <span class="hljs-keyword">switch</span>(cmd)<br>  &#123;<br>    <span class="hljs-keyword">case</span> I2C_CMD_SET_DEV_ADDR:<span class="hljs-comment">//命令1，设置设备地址</span><br>      filp-&gt;private_data = I2C_create(arg);<br> <br>    <span class="hljs-keyword">case</span> I2C_CMD_WRITE:  <span class="hljs-comment">//命令2，写寄存器值</span><br>      <br>      status = copy_from_user(&amp;transferPrm, (<span class="hljs-type">void</span> *)arg, <span class="hljs-keyword">sizeof</span>(transferPrm));<br>      ...<br>            <br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I2C_CMD_READ:  <span class="hljs-comment">//命令3，读寄存器值</span><br>    <br>      status = copy_from_user(&amp;transferPrm, (<span class="hljs-type">void</span> *)arg, <span class="hljs-keyword">sizeof</span>(transferPrm));<br>      ...<br>      <br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      status = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;    <br>  &#125;<br> <br>  up(&amp;gI2C_dev.semLock);      <span class="hljs-comment">//信号量up</span><br> <br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">I2C_create</span><span class="hljs-params">(<span class="hljs-type">int</span> devAddr)</span> &#123;<br> <br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> *<span class="hljs-title">driver</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span> =</span> client;<br>    I2C_Obj *pObj;<br> <br>    devAddr &gt;&gt;= <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class="hljs-comment">//变量合法性判断</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>   <br>    <span class="hljs-keyword">if</span>(gI2C_dev.pObj[devAddr]!=<span class="hljs-literal">NULL</span>) &#123;	<span class="hljs-comment">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span><br>      <span class="hljs-comment">// already allocated, increment user count, and return the allocated handle</span><br>      gI2C_dev.pObj[devAddr]-&gt;users++;<br>      <span class="hljs-keyword">return</span> gI2C_dev.pObj[devAddr];<br>    &#125;<br>    <br>    pObj = (<span class="hljs-type">void</span>*)kmalloc( <span class="hljs-keyword">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class="hljs-comment">//为pObj分配空间</span><br>    gI2C_dev.pObj[devAddr] = pObj;  <span class="hljs-comment">//将分配的空间地址保存在全局变量里</span><br>    <span class="hljs-built_in">memset</span>(pObj, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(I2C_Obj));<br>  <br>    pObj-&gt;client.adapter = <span class="hljs-literal">NULL</span>;<br>    pObj-&gt;users++;    <span class="hljs-comment">//用户基数，初始化为0，当前设为1</span><br>    pObj-&gt;devAddr = devAddr;  <span class="hljs-comment">//保存设备地址</span><br>    <br>    gI2C_curAddr = pObj-&gt;devAddr;  <span class="hljs-comment">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span><br>    driver = &amp;pObj-&gt;driver;  <span class="hljs-comment">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span><br> <br>    pObj-&gt;nameSize=<span class="hljs-number">0</span>;<span class="hljs-comment">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span><br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;I&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;_&#x27;</span>;   <br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-string">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="hljs-number">0</span>;<br> <br>    driver-&gt;driver.name = pObj-&gt;name; <span class="hljs-comment">//保存刚才设置的name</span><br>    driver-&gt;id = I2C_DRIVERID_MISC;<br>    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class="hljs-comment">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span><br>    driver-&gt;detach_client = I2C_detachClient;	<span class="hljs-comment">//这个很重，在后面分析</span><br> <br>    <span class="hljs-keyword">if</span>((ret = i2c_add_driver(driver)))	<span class="hljs-comment">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span><br>    &#123;<br>        printk( KERN_ERR <span class="hljs-string">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\n&quot;</span>, pObj-&gt;devAddr);<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>) &#123;<br> <br>      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class="hljs-literal">NULL</span>;<br>      kfree(pObj);    <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_write</span><span class="hljs-params">(I2C_Obj *pObj, <span class="hljs-type">uint8_t</span> *reg, <span class="hljs-type">uint8_t</span> *buffer, <span class="hljs-type">uint8_t</span> count, <span class="hljs-type">uint8_t</span> dataSize)</span><br>&#123;<br>  <span class="hljs-type">uint8_t</span> i;<br>  <span class="hljs-type">int</span> err;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> <span class="hljs-title">msg</span>[1];</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">8</span>];<br> <br>  <span class="hljs-keyword">if</span>(pObj==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> -ENODEV;<br> <br>  client = &amp;pObj-&gt;client;<span class="hljs-comment">//得到client信息</span><br>  <span class="hljs-keyword">if</span>(!client-&gt;adapter)<br>    <span class="hljs-keyword">return</span> -ENODEV;  <br>  <br>  <span class="hljs-keyword">if</span>(dataSize&lt;=<span class="hljs-number">0</span>||dataSize&gt;<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>  <br>    msg-&gt;addr = client-&gt;addr;<span class="hljs-comment">//设置要写的i2c设备地址</span><br>    msg-&gt;flags= <span class="hljs-number">0</span>;<span class="hljs-comment">//一直为0</span><br>    msg-&gt;buf  = data;<span class="hljs-comment">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span><br>		<br>    data[<span class="hljs-number">0</span>] = reg[i];<span class="hljs-comment">//寄存器地址赋值</span><br>		<br>    <span class="hljs-keyword">if</span>(dataSize==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//寄存器值长度为1</span><br>       data[<span class="hljs-number">1</span>]  = buffer[i];<span class="hljs-comment">//寄存器值赋值</span><br>       msg-&gt;len = <span class="hljs-number">2</span>;  	<span class="hljs-comment">//设置data长度为2	</span><br>    &#125;	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dataSize==<span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//寄存器值长度为2</span><br>       data[<span class="hljs-number">1</span>] = buffer[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>];<br>       data[<span class="hljs-number">2</span>] = buffer[<span class="hljs-number">2</span>*i];<br>       msg-&gt;len = <span class="hljs-number">3</span>;<br>    &#125; <br>    err = i2c_transfer(client-&gt;adapter, msg, <span class="hljs-number">1</span>);<span class="hljs-comment">//调用i2c-core中的i2c_transfer发送i2c数据</span><br>    <span class="hljs-keyword">if</span>( err &lt; <span class="hljs-number">0</span> )<br>      <span class="hljs-keyword">return</span> err;<br>    &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">driver-&gt;driver.name = pObj-&gt;name;<br>driver-&gt;id = I2C_DRIVERID_MISC;<br>driver-&gt;attach_adapter = I2C_attachAdapter;<br>driver-&gt;detach_client = I2C_detachClient;<br></code></pre></td></tr></table></figure>
<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Notifies the driver that a new bus has appeared. This routine</span><br><span class="hljs-comment"> * can be used by the driver to test if the bus meets its conditions</span><br><span class="hljs-comment"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span><br><span class="hljs-comment"> * registers the client(s) that are on the bus to the i2c admin. via</span><br><span class="hljs-comment"> * i2c_attach_client.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_attachAdapter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> I2C_detectClient(adapter, gI2C_curAddr);<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_detectClient</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_adapter *adapter, <span class="hljs-type">int</span> address)</span><br>&#123;<br>    I2C_Obj *pObj;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;<br>      printk( KERN_ERR <span class="hljs-string">&quot;I2C: ERROR: Invalid device address %x\n&quot;</span>, address);        <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>      <br>    pObj = gI2C_dev.pObj[address];<br>    <span class="hljs-keyword">if</span>(pObj==<span class="hljs-literal">NULL</span>) &#123;<br>      printk( KERN_ERR <span class="hljs-string">&quot;I2C: ERROR: Object not found for address %x\n&quot;</span>, address);    <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    client = &amp;pObj-&gt;client;<br> <br>    <span class="hljs-keyword">if</span>(client-&gt;adapter)<br>      <span class="hljs-keyword">return</span> -EBUSY;  <span class="hljs-comment">/* our client is already attached */</span><br> <br>    <span class="hljs-built_in">memset</span>(client, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> i2c_client));<br>    client-&gt;addr = pObj-&gt;devAddr;<br>    client-&gt;adapter = adapter;<br>    client-&gt;driver = &amp;pObj-&gt;driver;<br> <br>    <span class="hljs-keyword">if</span>((err = i2c_attach_client(client)))<br>    &#123;<br>        printk( KERN_ERR <span class="hljs-string">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);<br>        client-&gt;adapter = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> err;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* tells the driver that a client is about to be deleted &amp; gives it </span><br><span class="hljs-comment"> * the chance to remove its private data. Also, if the client struct</span><br><span class="hljs-comment"> * has been dynamically allocated by the driver in the function above,</span><br><span class="hljs-comment"> * it must be freed here.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">I2C_detachClient</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span><br>&#123;<br>    <span class="hljs-type">int</span> err;<br><span class="hljs-keyword">if</span>(!client-&gt;adapter)<br>    <span class="hljs-keyword">return</span> -ENODEV; <span class="hljs-comment">/* our client isn&#x27;t attached */</span><br> <br><span class="hljs-keyword">if</span>((err = i2c_detach_client(client))) &#123;<br>    printk( KERN_ERR <span class="hljs-string">&quot;Client deregistration failed (address=%x), client not detached.\n&quot;</span>, client-&gt;addr);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br> <br>client-&gt;adapter = <span class="hljs-literal">NULL</span>;<br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<p>}</p>
<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>I2C驱动框架学习</div>
      <div>http://example.com/2023/09/28/I2C驱动框架学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>李嘉图</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09/29/Linux%E9%A9%B1%E5%8A%A8-%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="Linux驱动-构造和运行模块个人学习总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux驱动-构造和运行模块个人学习总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Ricardo0106" target="_blank" rel="nofollow noopener"><span>Ricardo</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
