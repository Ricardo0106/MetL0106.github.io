{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/default.png","path":"img/default.png","modified":1,"renderable":0},{"_id":"source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":0},{"_id":"source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":0},{"_id":"source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":0},{"_id":"source/yzb/2.png","path":"yzb/2.png","modified":1,"renderable":0},{"_id":"source/yzb/北京云.jpg","path":"yzb/北京云.jpg","modified":1,"renderable":0},{"_id":"source/yzb/小狗卷卷.jpg","path":"yzb/小狗卷卷.jpg","modified":1,"renderable":0},{"_id":"source/yzb/尹志斌.png","path":"yzb/尹志斌.png","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","path":"imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","path":"imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/I2C驱动框架.png","path":"imgs/I2C驱动框架学习/I2C驱动框架.png","modified":1,"renderable":0},{"_id":"source/imgs/壁纸/壁纸.png","path":"imgs/壁纸/壁纸.png","modified":1,"renderable":0},{"_id":"source/imgs/外设驱动开发/心灵捕手.webp","path":"imgs/外设驱动开发/心灵捕手.webp","modified":1,"renderable":0},{"_id":"source/imgs/头脑特工队/rilay1.png","path":"imgs/头脑特工队/rilay1.png","modified":1,"renderable":0},{"_id":"source/imgs/头脑特工队/rilay2.png","path":"imgs/头脑特工队/rilay2.png","modified":1,"renderable":0},{"_id":"source/imgs/广东计划/桔钓沙.jpg","path":"imgs/广东计划/桔钓沙.jpg","modified":1,"renderable":0},{"_id":"source/imgs/广东计划/桔钓沙2.jpg","path":"imgs/广东计划/桔钓沙2.jpg","modified":1,"renderable":0},{"_id":"source/imgs/广东计划/金钓沙露营计划.jpg","path":"imgs/广东计划/金钓沙露营计划.jpg","modified":1,"renderable":0},{"_id":"source/imgs/广东计划/鹿嘴山庄1.jpg","path":"imgs/广东计划/鹿嘴山庄1.jpg","modified":1,"renderable":0},{"_id":"source/imgs/广东计划/鹿嘴山庄2.jpg","path":"imgs/广东计划/鹿嘴山庄2.jpg","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/彩虹.jpg","path":"imgs/心情记录/彩虹.jpg","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/心情1.png","path":"imgs/心情记录/心情1.png","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/心情2.png","path":"imgs/心情记录/心情2.png","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/心情3.jpg","path":"imgs/心情记录/心情3.jpg","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/心情4.png","path":"imgs/心情记录/心情4.png","modified":1,"renderable":0},{"_id":"source/imgs/心情记录/心情5.jpg","path":"imgs/心情记录/心情5.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/CNN输入到网络.jpg","path":"imgs/深度学习/CNN输入到网络.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN.jpg","path":"imgs/深度学习/RNN.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN1.gif","path":"imgs/深度学习/RNN1.gif","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN2.gif","path":"imgs/深度学习/RNN2.gif","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN3.gif","path":"imgs/深度学习/RNN3.gif","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN4.gif","path":"imgs/深度学习/RNN4.gif","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/RNN5.gif","path":"imgs/深度学习/RNN5.gif","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/Transformer.jpg","path":"imgs/深度学习/Transformer.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/图像输入.jpg","path":"imgs/深度学习/图像输入.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/损失L.jpg","path":"imgs/深度学习/损失L.jpg","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/注意力.png","path":"imgs/深度学习/注意力.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/注意力1.png","path":"imgs/深度学习/注意力1.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/注意力2.png","path":"imgs/深度学习/注意力2.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/注意力3.png","path":"imgs/深度学习/注意力3.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/深度网络.png","path":"imgs/深度学习/深度网络.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/移动1","path":"imgs/深度学习/移动1","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/移动2","path":"imgs/深度学习/移动2","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/移动3","path":"imgs/深度学习/移动3","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/鸟.png","path":"imgs/深度学习/鸟.png","modified":1,"renderable":0},{"_id":"source/imgs/深度学习/鸟识别1.jpg","path":"imgs/深度学习/鸟识别1.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/MissingLi.md","hash":"ed22b91f5f57790e3784ea49921fc3f95baaf130","modified":1696170233297},{"_id":"source/_posts/Linux驱动-构造和运行模块个人学习总结.md","hash":"69227ff8a9ef2777cab1959bb17e9b31d27faf35","modified":1696090150819},{"_id":"source/CNAME","hash":"ef057967805a3f389b38f5a530b8533bc1bd97f5","modified":1696050251983},{"_id":"source/_posts/I2C驱动框架学习.md","hash":"e357560755d86c882a739f72396f47723a803eec","modified":1696089777573},{"_id":"source/_posts/深度学习分享.md","hash":"f6c360cc280e0ae778005181bcbcfc5b9cb9cd04","modified":1696319143598},{"_id":"source/about/index.md","hash":"271b9859765a391c6fe1a3a6c4b8ef3dfd77b276","modified":1696088704886},{"_id":"source/_posts/广东注意事项.md","hash":"8062d318ecf8d1244777d1b8b8aa9c62774ea910","modified":1696250663577},{"_id":"source/_posts/字符设备驱动.md","hash":"acc5fbd8415332713bfda2bd5217e1c574f4f7b9","modified":1696123368271},{"_id":"source/_posts/头脑特工队观赏报告-重要.md","hash":"4accf71c6df7dd9ddf6e415045742d0c00f27309","modified":1696130089715},{"_id":"source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1696080165422},{"_id":"source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1696080165424},{"_id":"source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1696080165425},{"_id":"source/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","hash":"3a8ea5d0782a4f95fd7bdf14ed41653526fae901","modified":1696050251984},{"_id":"source/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","hash":"a2a3f2c04a656db334d6a0577297469ceaf288e3","modified":1696050251985},{"_id":"source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1696080165425},{"_id":"source/imgs/广东计划/金钓沙露营计划.jpg","hash":"066cb85fd19a9314de51182e86d167fa759dfc18","modified":1696250110889},{"_id":"source/imgs/心情记录/心情4.png","hash":"889850dad84cab773f299ab2b03bfeb9e1aefc81","modified":1696063692678},{"_id":"source/imgs/心情记录/心情5.jpg","hash":"2a4a39b0ba5cc6a3a00ae75f0c4286b5263e3d8b","modified":1696063707120},{"_id":"source/imgs/深度学习/RNN2.gif","hash":"997228ffddae89dd7515ef04183451b73ab58d86","modified":1696317542208},{"_id":"source/imgs/深度学习/RNN1.gif","hash":"aade0c169f8ac6424d128a5480a1554715150530","modified":1696317528544},{"_id":"source/imgs/深度学习/RNN3.gif","hash":"2825d9ebd0f31ae86e65764a0ba6fedc4b958fa5","modified":1696317564663},{"_id":"source/imgs/深度学习/损失L.jpg","hash":"34170c6674bbc447705905bfa638accbc13a76c1","modified":1696305841726},{"_id":"source/imgs/深度学习/移动1","hash":"b4919d2d960f620a12f0bd80f7e7fad2615a84ca","modified":1696314587694},{"_id":"source/imgs/深度学习/移动2","hash":"22b3b50c25920deaf21c69e6e3aa5e8279d2d152","modified":1696314642279},{"_id":"source/imgs/深度学习/移动3","hash":"ee08f762e757079210df78613ef2121bd72fc1cc","modified":1696314671567},{"_id":"source/imgs/深度学习/鸟.png","hash":"992dd76c01e228b1cae38fcb3a7e420d608b38b3","modified":1696313719231},{"_id":"source/yzb/2.png","hash":"309ef89707252868bc4699ab3af1056641b3a522","modified":1696088564772},{"_id":"source/yzb/小狗卷卷.jpg","hash":"f08e29d9768a94ecf0d3ab69611f57525aff01be","modified":1696090036739},{"_id":"source/imgs/I2C驱动框架学习/I2C驱动框架.png","hash":"523d20cbb4d764190a041c57e19ee9701d08fd33","modified":1696050251986},{"_id":"source/imgs/心情记录/彩虹.jpg","hash":"a25b65b03b0cbe171bdde43da1b94143d325b90f","modified":1696063313043},{"_id":"source/imgs/深度学习/CNN输入到网络.jpg","hash":"7de24c154e8d5b2fbecee8c45bcff88fcac3f3c7","modified":1696312036311},{"_id":"source/imgs/深度学习/RNN4.gif","hash":"427d0660dc70a3ebc45e4b5348529aec84a9f0ac","modified":1696317570480},{"_id":"source/imgs/深度学习/RNN5.gif","hash":"bb3dd1f6e412eaab190d00793addbf2a2c04938c","modified":1696317575948},{"_id":"source/imgs/深度学习/图像输入.jpg","hash":"5fffe8d5519ff46c9999390801bc03d995a53eda","modified":1696311475847},{"_id":"source/imgs/深度学习/注意力3.png","hash":"75964095718294c02d64c10505982016f793fc3b","modified":1696317975686},{"_id":"source/imgs/深度学习/鸟识别1.jpg","hash":"d994bc978032ef7854d3b3774dce4985e56e0913","modified":1696312355080},{"_id":"source/imgs/心情记录/心情1.png","hash":"083d45fa0289454435c854f84652e20a8c45c715","modified":1696063651887},{"_id":"source/imgs/深度学习/RNN.jpg","hash":"b1f49ca157123ab3d757e6264661c6dccba15cb3","modified":1696317453014},{"_id":"source/imgs/心情记录/心情2.png","hash":"72372416ea2352461177509560a8a5a5acb35e25","modified":1696063664079},{"_id":"source/yzb/尹志斌.png","hash":"3ccee60b2481e9ba53d1edd16f645102faddc591","modified":1696088527962},{"_id":"source/imgs/广东计划/桔钓沙.jpg","hash":"7c1d443f0fe593e7717ba2a21de56f1860850916","modified":1696250344668},{"_id":"source/imgs/外设驱动开发/心灵捕手.webp","hash":"7ecf11bbd15886912e17d4e19c4fe6150d24163a","modified":1696053181470},{"_id":"source/imgs/深度学习/深度网络.png","hash":"ebfabd35c52b380fe673029132f5471ba20d0e81","modified":1696310321320},{"_id":"source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1696080165424},{"_id":"source/imgs/深度学习/注意力2.png","hash":"e14deb7a27c19ecb25e30916051b8d9b2cb53cc7","modified":1696317949525},{"_id":"source/yzb/北京云.jpg","hash":"88b14690c43c0e06985e28dd27f8bcf85c78dbfa","modified":1696123189422},{"_id":"source/imgs/深度学习/Transformer.jpg","hash":"58a523c0c477f40bc9f35d8571b268f73f1f628c","modified":1696318571787},{"_id":"source/imgs/广东计划/鹿嘴山庄2.jpg","hash":"3da94bd25994a065f64acc94e59c7ec5eebed21c","modified":1696250360553},{"_id":"source/imgs/广东计划/鹿嘴山庄1.jpg","hash":"ce4f73f184417629608dfaaa5e41555782245a00","modified":1696250330702},{"_id":"source/imgs/深度学习/注意力.png","hash":"dad80e886f65f3489c0655e5f93ad8c42fe752c2","modified":1696317881351},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1696078126083},{"_id":"source/imgs/广东计划/桔钓沙2.jpg","hash":"879409f81c3f8b371869a03e6e067c1797208fe4","modified":1696250653022},{"_id":"source/imgs/深度学习/注意力1.png","hash":"5fec3901d47a14f3e90882a0c6e263e83bcec33f","modified":1696317914994},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"b2c283d4e9aaf9ba49b8abb81adc03117b0e07db","modified":1696078125865},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1696078126087},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"cdde6c6d6a1bdf9fb965313e21d92cf6213582b6","modified":1696078126086},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1696078125509},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"49f681a203eecfa7127ac22edc13bd3b49693d0a","modified":1696078125866},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1696078126088},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1696078126089},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1696078126088},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1696078126089},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1696078126090},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1696078126090},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1696078126090},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1696078126091},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":1696078125341},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1696078125511},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1696078125514},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1696078125516},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1696078125519},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1696078125511},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1696078125834},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1696078125834},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1696078125838},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1696078125842},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1696078125841},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":1696078125833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1696078125514},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":1696078125343},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":1696078125341},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1696078125517},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1696078125520},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1696078125828},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1696078125830},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1696078125839},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1696078125838},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1696078125832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1696078125832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1696078125519},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1696078125840},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1696078125854},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1696078125850},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1696078125862},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1696078125858},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1696078125854},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1696078125857},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1696078125860},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1696078125849},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1696078125851},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1696078125854},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1696078125852},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1696078125862},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1696078125855},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1696078125860},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1696078125863},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1696078125863},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1696078125864},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1696078125847},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1696078125847},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1696078125852},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1696078125856},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1696078125859},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1696078125859},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":1696078125342},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1696078125848},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1696078125862},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1696078125863},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1696078125860},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1696078125343},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1696078126074},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1696078126075},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1696078125510},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1696078125344},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1696078125866},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1696078126063},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1696078125846},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1696078126064},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1696078126078},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1696078125846},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1696078125840},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1696078125848},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1696078125851},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1696078125853},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1696078125858},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1696078125835},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1696078125856},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1696078126084},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1696078125861},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1696078125864},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1696078125520},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1696078125829},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1696078125829},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1696078125829},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1696078125831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1696078125831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1696078125835},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1696078125843},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1696078125844},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1696078125843},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1696078125839},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1696078125844},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1696078125841},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1696078125515},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1696078125516},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1696078125513},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1696078125520},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1696078125830},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1696078125830},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1696078125832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1696078125837},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1696078125836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1696078125836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1696078125513},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1696078125843},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1696078125517},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1696078125838},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1696078125836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1696078125840},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1696078125849},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1696078125841},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1696078125853},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":1696078125853},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"b2f61b91fffb17d11ad56811f07d52d23f012741","modified":1696078125852},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1696078125855},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1696078125856},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1696078125858},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1696078126067},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1696078125521},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1696078125842},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1696078126067},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1696078126079},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1696078126065},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1696078126069},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1696078126068},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1696078126066},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1696078126076},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1696078126076},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":1696078126071},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1696078126081},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1696078126070},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1696078126070},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1696078126070},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1696078126075},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1696078126077},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1696078126074},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1696078126072},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1696078125837},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1696078126078},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1696078126080},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1696078126083},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1696078126081},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1696078126065},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1696078126066},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1696078126069},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1696078126071},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1696078126073},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1696078126073},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1696078126072},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1696078126074},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1696078126079},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1696078126079},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1696078126082},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1696078126079},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1696078126080},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1696078126082},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1696078126082},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1696078126084},{"_id":"source/imgs/头脑特工队/rilay1.png","hash":"64550a21afaa61c6df1b612f4c5fffc8ec9913ab","modified":1696050251992},{"_id":"source/imgs/头脑特工队/rilay2.png","hash":"84837115c382196fc5929199d0e50097c3b5ca59","modified":1696050251999},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1696078126056},{"_id":"source/imgs/壁纸/壁纸.png","hash":"b69d6c474a9aafd539287006d29be8c7eca7c183","modified":1696033940002},{"_id":"source/imgs/心情记录/心情3.jpg","hash":"00dab658ab245f7759f7f361f1b30121806020b4","modified":1696063681693},{"_id":"public/local-search.xml","hash":"ed877e4acd0943cbfdb56936ee0801ee5dfd7595","modified":1696319182809},{"_id":"public/about/index.html","hash":"39904473ddae22f9e0c1c0226f0b5776f7135a95","modified":1696319182809},{"_id":"public/archives/index.html","hash":"5ae76214329235101b73b0ee9538bd2497d9f8f2","modified":1696319182809},{"_id":"public/archives/2023/index.html","hash":"8ef4beace5a0b6454da77ea11783fa5aeffa4056","modified":1696319182809},{"_id":"public/archives/2023/09/index.html","hash":"db1297c02dd8b2e7998929c1f6d6a05235da8841","modified":1696319182809},{"_id":"public/archives/2023/10/index.html","hash":"bf25dc76ae6050ecad2aa84a79798158c382d609","modified":1696319182809},{"_id":"public/categories/Linux-Kernel/index.html","hash":"b454ed279bd644e16ae1fedf6cf6afe8ae233fe7","modified":1696319182809},{"_id":"public/tags/C/index.html","hash":"cc41f760f0e7946375aea3a3cef21bcb5721df40","modified":1696319182809},{"_id":"public/tags/MetLee/index.html","hash":"dff20f4bece1cef8baf1421da0014f419ccf41b8","modified":1696319182809},{"_id":"public/tags/Linux-Kernel-Driver/index.html","hash":"5cc6b8f96ba1408b4bdbc5a80439af3f3e74d4c0","modified":1696319182809},{"_id":"public/tags/Deep-Learning/index.html","hash":"f9156be7396873e8b5eb9ec67ad9d8418d54462a","modified":1696319182809},{"_id":"public/tags/生活注意事项/index.html","hash":"11777672c5a6a31b6f60e8ae186aac22e00d27ee","modified":1696319182809},{"_id":"public/404.html","hash":"8ec9ce95310166ad72707d4ee1ee03f2aa949f37","modified":1696319182809},{"_id":"public/tags/index.html","hash":"8e6c17c9a04b686ab21381530a0d520b3cfe5d11","modified":1696319182809},{"_id":"public/2023/10/01/深度学习分享/index.html","hash":"6931eefdb9a238ea82570dfe33bc22b4d5bd961e","modified":1696319182809},{"_id":"public/2023/10/01/字符设备驱动/index.html","hash":"69fcc0199cd865fec88a07e6ba39859b80c54ec7","modified":1696319182809},{"_id":"public/2023/10/01/广东注意事项/index.html","hash":"9b9678a7a5471317b45a6da3d47f49feca4c8961","modified":1696319182809},{"_id":"public/2023/09/30/MissingLi/index.html","hash":"c577463feff4b4b292df80b938e0838aceb79f0f","modified":1696319182809},{"_id":"public/2023/09/29/头脑特工队观赏报告-重要/index.html","hash":"76f6254962e1950bfbb92b12766b172d093cf607","modified":1696319182809},{"_id":"public/2023/09/29/Linux驱动-构造和运行模块个人学习总结/index.html","hash":"1c67d35fda957cf3f5f663482900549de9b43b16","modified":1696319182809},{"_id":"public/index.html","hash":"6eab3af81f41c19b2bda2d102e925265ebaa4e81","modified":1696319182809},{"_id":"public/2023/09/28/I2C驱动框架学习/index.html","hash":"2f0f7469c027dc0098795b009a95eb34bd4fc9b7","modified":1696319182809},{"_id":"public/categories/index.html","hash":"3dab1525f15c0aa9bb9206f05ea96638098a131b","modified":1696319182809},{"_id":"public/links/index.html","hash":"d2e62da8fce1f173737794ade116c85e58d7131b","modified":1696319182809},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1696319182809},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1696319182809},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1696319182809},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1696319182809},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1696319182809},{"_id":"public/CNAME","hash":"ef057967805a3f389b38f5a530b8533bc1bd97f5","modified":1696319182809},{"_id":"public/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","hash":"3a8ea5d0782a4f95fd7bdf14ed41653526fae901","modified":1696319182809},{"_id":"public/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","hash":"a2a3f2c04a656db334d6a0577297469ceaf288e3","modified":1696319182809},{"_id":"public/imgs/广东计划/金钓沙露营计划.jpg","hash":"066cb85fd19a9314de51182e86d167fa759dfc18","modified":1696319182809},{"_id":"public/imgs/心情记录/心情4.png","hash":"889850dad84cab773f299ab2b03bfeb9e1aefc81","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN1.gif","hash":"aade0c169f8ac6424d128a5480a1554715150530","modified":1696319182809},{"_id":"public/imgs/心情记录/心情5.jpg","hash":"2a4a39b0ba5cc6a3a00ae75f0c4286b5263e3d8b","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN2.gif","hash":"997228ffddae89dd7515ef04183451b73ab58d86","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN3.gif","hash":"2825d9ebd0f31ae86e65764a0ba6fedc4b958fa5","modified":1696319182809},{"_id":"public/imgs/深度学习/损失L.jpg","hash":"34170c6674bbc447705905bfa638accbc13a76c1","modified":1696319182809},{"_id":"public/imgs/深度学习/移动1","hash":"b4919d2d960f620a12f0bd80f7e7fad2615a84ca","modified":1696319182809},{"_id":"public/imgs/深度学习/移动2","hash":"22b3b50c25920deaf21c69e6e3aa5e8279d2d152","modified":1696319182809},{"_id":"public/imgs/深度学习/移动3","hash":"ee08f762e757079210df78613ef2121bd72fc1cc","modified":1696319182809},{"_id":"public/imgs/深度学习/鸟.png","hash":"992dd76c01e228b1cae38fcb3a7e420d608b38b3","modified":1696319182809},{"_id":"public/yzb/2.png","hash":"309ef89707252868bc4699ab3af1056641b3a522","modified":1696319182809},{"_id":"public/yzb/小狗卷卷.jpg","hash":"f08e29d9768a94ecf0d3ab69611f57525aff01be","modified":1696319182809},{"_id":"public/imgs/I2C驱动框架学习/I2C驱动框架.png","hash":"523d20cbb4d764190a041c57e19ee9701d08fd33","modified":1696319182809},{"_id":"public/imgs/心情记录/彩虹.jpg","hash":"a25b65b03b0cbe171bdde43da1b94143d325b90f","modified":1696319182809},{"_id":"public/imgs/深度学习/CNN输入到网络.jpg","hash":"7de24c154e8d5b2fbecee8c45bcff88fcac3f3c7","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN4.gif","hash":"427d0660dc70a3ebc45e4b5348529aec84a9f0ac","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN5.gif","hash":"bb3dd1f6e412eaab190d00793addbf2a2c04938c","modified":1696319182809},{"_id":"public/imgs/深度学习/图像输入.jpg","hash":"5fffe8d5519ff46c9999390801bc03d995a53eda","modified":1696319182809},{"_id":"public/imgs/深度学习/注意力3.png","hash":"75964095718294c02d64c10505982016f793fc3b","modified":1696319182809},{"_id":"public/imgs/深度学习/鸟识别1.jpg","hash":"d994bc978032ef7854d3b3774dce4985e56e0913","modified":1696319182809},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1696319182809},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1696319182809},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1696319182809},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1696319182809},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1696319182809},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1696319182809},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1696319182809},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1696319182809},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1696319182809},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1696319182809},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1696319182809},{"_id":"public/css/main.css","hash":"526a4522eb54bb51772f51fb98295dc4fe03429f","modified":1696319182809},{"_id":"public/imgs/心情记录/心情1.png","hash":"083d45fa0289454435c854f84652e20a8c45c715","modified":1696319182809},{"_id":"public/imgs/深度学习/RNN.jpg","hash":"b1f49ca157123ab3d757e6264661c6dccba15cb3","modified":1696319182809},{"_id":"public/imgs/心情记录/心情2.png","hash":"72372416ea2352461177509560a8a5a5acb35e25","modified":1696319182809},{"_id":"public/yzb/尹志斌.png","hash":"3ccee60b2481e9ba53d1edd16f645102faddc591","modified":1696319182809},{"_id":"public/imgs/外设驱动开发/心灵捕手.webp","hash":"7ecf11bbd15886912e17d4e19c4fe6150d24163a","modified":1696319182809},{"_id":"public/imgs/广东计划/桔钓沙.jpg","hash":"7c1d443f0fe593e7717ba2a21de56f1860850916","modified":1696319182809},{"_id":"public/imgs/深度学习/深度网络.png","hash":"ebfabd35c52b380fe673029132f5471ba20d0e81","modified":1696319182809},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1696319182809},{"_id":"public/imgs/广东计划/鹿嘴山庄2.jpg","hash":"3da94bd25994a065f64acc94e59c7ec5eebed21c","modified":1696319182809},{"_id":"public/imgs/深度学习/注意力2.png","hash":"e14deb7a27c19ecb25e30916051b8d9b2cb53cc7","modified":1696319182809},{"_id":"public/yzb/北京云.jpg","hash":"88b14690c43c0e06985e28dd27f8bcf85c78dbfa","modified":1696319182809},{"_id":"public/imgs/深度学习/Transformer.jpg","hash":"58a523c0c477f40bc9f35d8571b268f73f1f628c","modified":1696319182809},{"_id":"public/imgs/广东计划/鹿嘴山庄1.jpg","hash":"ce4f73f184417629608dfaaa5e41555782245a00","modified":1696319182809},{"_id":"public/imgs/深度学习/注意力.png","hash":"dad80e886f65f3489c0655e5f93ad8c42fe752c2","modified":1696319182809},{"_id":"public/imgs/广东计划/桔钓沙2.jpg","hash":"879409f81c3f8b371869a03e6e067c1797208fe4","modified":1696319182809},{"_id":"public/imgs/深度学习/注意力1.png","hash":"5fec3901d47a14f3e90882a0c6e263e83bcec33f","modified":1696319182809},{"_id":"public/imgs/头脑特工队/rilay1.png","hash":"64550a21afaa61c6df1b612f4c5fffc8ec9913ab","modified":1696319182809},{"_id":"public/imgs/头脑特工队/rilay2.png","hash":"84837115c382196fc5929199d0e50097c3b5ca59","modified":1696319182809},{"_id":"public/imgs/壁纸/壁纸.png","hash":"b69d6c474a9aafd539287006d29be8c7eca7c183","modified":1696319182809},{"_id":"public/imgs/心情记录/心情3.jpg","hash":"00dab658ab245f7759f7f361f1b30121806020b4","modified":1696319182809}],"Category":[{"name":"Linux Kernel","_id":"clna0n6si0003lcwf4ccx3l6b"}],"Data":[],"Page":[{"title":"about","layout":"about","date":"2023-09-30T12:51:45.000Z","_content":"\n一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。\n\n见不到的时候，好想李啊。\n\n20080512202305122023080719980106202309281520825879280398965\n","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2023-09-30 20:51:45\n---\n\n一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。\n\n见不到的时候，好想李啊。\n\n20080512202305122023080719980106202309281520825879280398965\n","updated":"2023-09-30T15:45:04.886Z","path":"about/index.html","comments":1,"_id":"clna0n6sb0000lcwf3oivar8e","content":"<p>一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。</p>\n<p>见不到的时候，好想李啊。</p>\n<p>20080512202305122023080719980106202309281520825879280398965</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。</p>\n<p>见不到的时候，好想李啊。</p>\n<p>20080512202305122023080719980106202309281520825879280398965</p>\n"}],"Post":[{"title":"I2C驱动框架学习","date":"2023-09-28T13:43:49.000Z","index_img":"https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png","typora-root-url":"./..","_content":"\n# I2C通信：\n**I2C集成电路总线是一种串行的通信总线，使用主从架构**\n特点：\n只需要两条双向总线（SDA串行数据线、SCL串行时钟线）\n所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。\nI2C是真正的多主设备总线，可以提供仲裁和冲突检测。\n\n### CAN总线仲裁：\nCAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。\n当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。\nCAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。\n![](/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif)\n如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。\n\n### 数据传输协议：\n主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。\n\n#### 开始条件：\n主设备要开始通信时发送开始信号，执行：\n将SDA线从高压电平转换到低压电平\n将SCL从高电平切换成低压电平\n\n**地址位**：\n\n主机向从机发送/接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。\n\n**读写位**：\n\n指定数据传输方向：主-->从，该位为0。从-->主，该位为1。\n\n**ACK**/**NACK**：\n\n主机每次发送完数据之后会等待从设备的应答信号ACK。\n如果从设备发送应答信号ACK，则SDA会被拉低；\n若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；\n\n**数据块**：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK/NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。\n\n**停止条件**：先将SDA线从低电压电平切换到高电压电平；\n再将SCL线从高电平拉到低电平。\n\n### 架构层次分类\n\n![](/imgs/I2C驱动框架学习/I2C驱动框架.png)\n\n##### 第一层：\n\n提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层\n\n##### 第二层：\n\n提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层\n\n###### 第三层：\n\n实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层\n\n##### 第四层：\n\n实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层\n\n第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c\n\n第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。\n\n#### 具体分析\ni2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。\n\n看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解\n\n##### i2c_driver\n\n```c\nstruct i2c_driver {\n\tint id;\n\tunsigned int class;\n \n\tint (*attach_adapter)(struct i2c_adapter *);\n\tint (*detach_adapter)(struct i2c_adapter *);\n \n\tint (*detach_client)(struct i2c_client *);\n \n\tint (*command)(struct i2c_client *client,unsigned int cmd, void *arg);\n\tstruct device_driver driver;\n\tstruct list_head list;\n};\n```\n};\n##### i2c_client\n\n```c\nstruct i2c_client {\n\tunsigned int flags;\t\t/* div., see below\t\t*/\n\tunsigned short addr;\t\t/* chip address - NOTE: 7bit \t*/\n\t\t\t\t\t/* addresses are stored in the\t*/\n\t\t\t\t\t/* _LOWER_ 7 bits\t\t*/\n\tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/\n\tstruct i2c_driver *driver;\t/* and our access routines\t*/\n\tint usage_count;\t\t/* How many accesses currently  */\n\t\t\t\t\t/* to the client\t\t*/\n\tstruct device dev;\t\t/* the device structure\t\t*/\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion released;\n};\n```\n\n##### i2c_adapter\n\n```c\nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int id;\n\tunsigned int class;\n\tstruct i2c_algorithm *algo;/* the algorithm to access the bus\t*/\n\tvoid *algo_data;\n \n\t/* --- administration stuff. */\n\tint (*client_register)(struct i2c_client *);\n\tint (*client_unregister)(struct i2c_client *);\n \n\t/* data fields that are valid for all devices\t*/\n\tstruct mutex bus_lock;\n\tstruct mutex clist_lock;\n \n\tint timeout;\n\tint retries;\n\tstruct device dev;\t\t/* the adapter device */\n\tstruct class_device class_dev;\t/* the class device */\n \n\tint nr;\n\tstruct list_head clients;\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion dev_released;\n\tstruct completion class_dev_released;\n};\n```\n##### i2c_algorithm\n\n```c\nstruct i2c_algorithm {\n\tint (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, \n\t                   int num);\n\tint (*slave_send)(struct i2c_adapter *,char*,int);\n\tint (*slave_recv)(struct i2c_adapter *,char*,int);\n\tu32 (*functionality) (struct i2c_adapter *);\n};\n```\n\n##### 【i2c_adapter与i2c_algorithm】\ni2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。\n\ni2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体\n\n \t/*\n \t * I2C Message - used for pure i2c transaction, also from /dev interface\n \t */\n \tstruct i2c_msg {\n \t\t__u16 addr;\t/* slave address\t\t\t*/\n \t \t__u16 flags;\t\t\n \t \t__u16 len;\t\t/* msg length\t\t\t\t*/\n \t \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n \t};\n\n##### 【i2c_driver和i2c_client】\ni2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.\n\n##### 【i2c_adapter和i2c_client】\n\ni2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。\n从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。\n\n我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c\n\n```c\nEXPORT_SYMBOL(i2c_add_adapter);\nEXPORT_SYMBOL(i2c_del_adapter);\nEXPORT_SYMBOL(i2c_del_driver);\nEXPORT_SYMBOL(i2c_attach_client);\nEXPORT_SYMBOL(i2c_detach_client);\n\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。\n\n```c\nint i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tif (adap->algo->master_xfer) {//如果master_xfer函数存在，则调用，否则返回错误\n\t\tret = adap->algo->master_xfer(adap,msgs,num);//这个函数在硬件相关的代码中给algorithm赋值\n\t\treturn ret;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n```\n\n当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下\n\n```c\nint i2c_attach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_register(&client->dev);\n\tdevice_create_file(&client->dev, &dev_attr_client_name);\n\t...\n\treturn 0;\n}\n```\n\n```c\nint i2c_detach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_remove_file(&client->dev, &dev_attr_client_name);\n\tdevice_unregister(&client->dev);\n\t...\n\treturn res;\n}\n```\n\ni2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用\n\n```c\n/* -----\n * i2c_add_adapter is called from within the algorithm layer,\n * when a new hw adapter registers. A new device is register to be\n * available for clients.\n */\nint i2c_add_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tdevice_register(&adap->dev);\n\tdevice_create_file(&adap->dev, &dev_attr_name);\n\t...\n\t/* inform drivers of new adapters */\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->attach_adapter)\n\t\t\t/* We ignore the return code; if it fails, too bad */\n\t\t\tdriver->attach_adapter(adap);\n\t}\n\t...\n}\n```\n\n```c\nint i2c_del_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->detach_adapter)\n\t\t\tif ((res = driver->detach_adapter(adap))) {\n\t\t\t}\n\t}\n\t...\n\tlist_for_each_safe(item, _n, &adap->clients) {\n\t\tclient = list_entry(item, struct i2c_client, list);\n \n\t\tif ((res=client->driver->detach_client(client))) {\n \n\t\t}\n\t}\n\t...\n\tdevice_remove_file(&adap->dev, &dev_attr_name);\n\tdevice_unregister(&adap->dev);\n \n}\n```\n\ni2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的\n\n```c\nstatic struct platform_driver davinci_i2c_driver = {\n\t.probe\t\t= davinci_i2c_probe,\n\t.remove\t\t= davinci_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_davinci\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n \n/* I2C may be needed to bring up other drivers */\nstatic int __init davinci_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&davinci_i2c_driver);\n}\nsubsys_initcall(davinci_i2c_init_driver);\n \nstatic void __exit davinci_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&davinci_i2c_driver);\n}\nmodule_exit(davinci_i2c_exit_driver);\n```\n\n并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器\n\n```c\nstatic struct i2c_algorithm i2c_davinci_algo = {\n\t.master_xfer\t= i2c_davinci_xfer,\n\t.functionality\t= i2c_davinci_func,\n};\n```\n\n然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中\n\n```c\nadap->algo = &i2c_davinci_algo;\n```\n\n\n### 梳理图\n有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:\n\n\n![](/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png)\n\nlinux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。\n\n在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。\n\n#### ov2715设备i2c驱动源码分析\nov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。\n该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。\n该字符设备的用到的结构体有两个，如下\n\n```c\ntypedef struct {\n\n  int devAddr;\n\n  struct i2c_client client;   //!< Data structure containing general access routines.\n  struct i2c_driver driver;   //!< Data structure containing information specific to each client.\n\n  char name[20];\n  int nameSize;\n  int users;\n\n} I2C_Obj;\n```\n\n```c\n#define I2C_DEV_MAX_ADDR  (0xFF)\n#define I2C_TRANSFER_BUF_SIZE_MAX   (256)\ntypedef struct {\n \n  struct cdev cdev;             /* Char device structure    */\n  int     major;\n  struct semaphore semLock;\n    \n  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];\n \n  uint8_t reg[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint16_t reg16[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint8_t buffer[I2C_TRANSFER_BUF_SIZE_MAX*4];\n  \n} I2C_Dev;\n```\n\n一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值\n使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。\n下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。\n首先是该字符设备的初始化和退出函数\n\n```c\nint I2C_devInit(void)\n{\n  int     result, i;\n  dev_t   dev = 0;\n \n  result = alloc_chrdev_region(&dev, 0, 1, I2C_DRV_NAME);//分配字符设备空间\n  \n  for(i=0; i<I2C_DEV_MAX_ADDR; i++)\n  {\n    gI2C_dev.pObj[i]=NULL;\n  }\n \n  gI2C_dev.major = MAJOR(dev);//保存设备主编号\n  sema_init(&gI2C_dev.semLock, 1);//信号量初始化\n  cdev_init(&gI2C_dev.cdev, &gI2C_devFileOps);//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文\n  gI2C_dev.cdev.owner = THIS_MODULE;//常规赋值\n gI2C_dev.cdev.ops = &gI2C_devFileOps;//常规赋值 result = cdev_add(&gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;}void I2C_devExit(void){ dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间}\ngI2c_devFileOps全局变量，驱动初始化会用到该结构体变量\nstruct file_operations gI2C_devFileOps = {\n  .owner = THIS_MODULE,\n  .open = I2C_devOpen,\n  .release = I2C_devRelease,\n  .ioctl = I2C_devIoctl,\n};\n```\n\n该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。\n在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）\n\n```c\nint I2C_devIoctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\n{\n  I2C_Obj *pObj;\n  int status=0;\n  I2C_TransferPrm transferPrm;\n  \n  pObj = (I2C_Obj *)filp->private_data;\n \n  if(!I2C_IOCTL_CMD_IS_VALID(cmd))\n    return -1;\n  cmd = I2C_IOCTL_CMD_GET(cmd);//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd\n \n  down_interruptible(&gI2C_dev.semLock);      //信号量down\n  \n  switch(cmd)\n  {\n    case I2C_CMD_SET_DEV_ADDR://命令1，设置设备地址\n      filp->private_data = I2C_create(arg);\n \n    case I2C_CMD_WRITE:  //命令2，写寄存器值\n      \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n            \n      break;\n    case I2C_CMD_READ:  //命令3，读寄存器值\n    \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n      \n      break;\n    default:\n      status = -1;\n      break;    \n  }\n \n  up(&gI2C_dev.semLock);      //信号量up\n \n  return status;\n}\n```\n\n以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码\n\n```c\nvoid *I2C_create(int devAddr) {\n \n    int ret;\n    struct i2c_driver *driver;\n    struct i2c_client *client = client;\n    I2C_Obj *pObj;\n \n    devAddr >>= 1;\n    \n    if(devAddr>I2C_DEV_MAX_ADDR)  //变量合法性判断\n      return NULL;\n   \n    if(gI2C_dev.pObj[devAddr]!=NULL) {\t//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用\n      // already allocated, increment user count, and return the allocated handle\n      gI2C_dev.pObj[devAddr]->users++;\n      return gI2C_dev.pObj[devAddr];\n    }\n    \n    pObj = (void*)kmalloc( sizeof(I2C_Obj), GFP_KERNEL); //为pObj分配空间\n    gI2C_dev.pObj[devAddr] = pObj;  //将分配的空间地址保存在全局变量里\n    memset(pObj, 0, sizeof(I2C_Obj));\n  \n    pObj->client.adapter = NULL;\n    pObj->users++;    //用户基数，初始化为0，当前设为1\n    pObj->devAddr = devAddr;  //保存设备地址\n    \n    gI2C_curAddr = pObj->devAddr;  //gI2C_curAddr为全局的整型变量，用于保存当前的设备地址\n    driver = &pObj->driver;  //将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动\n \n    pObj->nameSize=0;//i2c设备名称，注意，这里不是在/dev下面的设备节点名\n    pObj->name[pObj->nameSize++] = 'I';\n    pObj->name[pObj->nameSize++] = '2';\n    pObj->name[pObj->nameSize++] = 'C';\n    pObj->name[pObj->nameSize++] = '_';   \n    pObj->name[pObj->nameSize++] = 'A' + ((pObj->devAddr >> 0) & 0xF);\n    pObj->name[pObj->nameSize++] = 'B' + ((pObj->devAddr >> 4) & 0xF);\n    pObj->name[pObj->nameSize++] = 0;\n \n    driver->driver.name = pObj->name; //保存刚才设置的name\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;   //这个很重要，将驱动连接到i2c适配器上，在后面分析\n    driver->detach_client = I2C_detachClient;\t//这个很重，在后面分析\n \n    if((ret = i2c_add_driver(driver)))\t//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()\n    {\n        printk( KERN_ERR \"I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n\", pObj->devAddr);\n    }\n \n    if(ret<0) {\n \n      gI2C_dev.pObj[pObj->devAddr] = NULL;\n      kfree(pObj);    \n      return NULL;\n    }\n    return pObj;\n}\n```\n\n其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()\n\n```c\nint I2C_write(I2C_Obj *pObj, uint8_t *reg, uint8_t *buffer, uint8_t count, uint8_t dataSize)\n{\n  uint8_t i;\n  int err;\n  struct i2c_client *client;\n\tstruct i2c_msg msg[1];\n\tunsigned char data[8];\n \n  if(pObj==NULL)\n    return -ENODEV;\n \n  client = &pObj->client;//得到client信息\n  if(!client->adapter)\n    return -ENODEV;  \n  \n  if(dataSize<=0||dataSize>4)\n    return -1;\n    \n  for(i=0; i<count; i++) {\n  \n    msg->addr = client->addr;//设置要写的i2c设备地址\n    msg->flags= 0;//一直为0\n    msg->buf  = data;//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值\n\t\t\n    data[0] = reg[i];//寄存器地址赋值\n\t\t\n    if(dataSize==1) {//寄存器值长度为1\n       data[1]  = buffer[i];//寄存器值赋值\n       msg->len = 2;  \t//设置data长度为2\t\n    }\telse if(dataSize==2) {//寄存器值长度为2\n       data[1] = buffer[2*i+1];\n       data[2] = buffer[2*i];\n       msg->len = 3;\n    } \n    err = i2c_transfer(client->adapter, msg, 1);//调用i2c-core中的i2c_transfer发送i2c数据\n    if( err < 0 )\n      return err;\n    }\n  \n  return 0;\n}\n```\n\n重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的\n\n```c\n    driver->driver.name = pObj->name;\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;\n    driver->detach_client = I2C_detachClient;\n```\n在i2c_driver结构体中针对attach_adapter有这样的说明：\n\n```c\n\t/* Notifies the driver that a new bus has appeared. This routine\n\t * can be used by the driver to test if the bus meets its conditions\n\t * & seek for the presence of the chip(s) it supports. If found, it \n\t * registers the client(s) that are on the bus to the i2c admin. via\n\t * i2c_attach_client.\n\t */\n```\n\n意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示\n\n```c\nint I2C_attachAdapter(struct i2c_adapter *adapter)\n{\n    return I2C_detectClient(adapter, gI2C_curAddr);\n}\n \nint I2C_detectClient(struct i2c_adapter *adapter, int address)\n{\n    I2C_Obj *pObj;\n    struct i2c_client *client;\n    int err = 0;\n    \n    if(address > I2C_DEV_MAX_ADDR) {\n      printk( KERN_ERR \"I2C: ERROR: Invalid device address %x\\n\", address);        \n      return -1;\n    }\n      \n    pObj = gI2C_dev.pObj[address];\n    if(pObj==NULL) {\n      printk( KERN_ERR \"I2C: ERROR: Object not found for address %x\\n\", address);    \n      return -1;\n    }\n \n    client = &pObj->client;\n \n    if(client->adapter)\n      return -EBUSY;  /* our client is already attached */\n \n    memset(client, 0x00, sizeof(struct i2c_client));\n    client->addr = pObj->devAddr;\n    client->adapter = adapter;\n    client->driver = &pObj->driver;\n \n    if((err = i2c_attach_client(client)))\n    {\n        printk( KERN_ERR \"I2C: ERROR: Couldn't attach %s (address=%x)\\n\", pObj->name, pObj->devAddr);\n        client->adapter = NULL;\n        return err;\n    }\n    return 0;\n}\n```\n最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。\n当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：\n\n```c\n\t/* tells the driver that a client is about to be deleted & gives it \n\t * the chance to remove its private data. Also, if the client struct\n\t * has been dynamically allocated by the driver in the function above,\n\t * it must be freed here.\n\t */\n```\n\n下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接\n\n```c\nint I2C_detachClient(struct i2c_client *client)\n{\n    int err;\nif(!client->adapter)\n    return -ENODEV; /* our client isn't attached */\n \nif((err = i2c_detach_client(client))) {\n    printk( KERN_ERR \"Client deregistration failed (address=%x), client not detached.\\n\", client->addr);\n    return err;\n}\n \nclient->adapter = NULL;\n \nreturn 0;\n```\n}\n\n\n\n\n\n\n\n\n<small>misslyh20080512202305122023080719980106202309281520825879280398965</small>\n","source":"_posts/I2C驱动框架学习.md","raw":"---\ntitle: I2C驱动框架学习\ndate: 2023-09-28 21:43:49\nindex_img: https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png\ncategory: Linux Kernel\ntags: \n  - C\ntypora-root-url: ./..\n---\n\n# I2C通信：\n**I2C集成电路总线是一种串行的通信总线，使用主从架构**\n特点：\n只需要两条双向总线（SDA串行数据线、SCL串行时钟线）\n所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。\nI2C是真正的多主设备总线，可以提供仲裁和冲突检测。\n\n### CAN总线仲裁：\nCAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。\n当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。\nCAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。\n![](/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif)\n如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。\n\n### 数据传输协议：\n主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。\n\n#### 开始条件：\n主设备要开始通信时发送开始信号，执行：\n将SDA线从高压电平转换到低压电平\n将SCL从高电平切换成低压电平\n\n**地址位**：\n\n主机向从机发送/接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。\n\n**读写位**：\n\n指定数据传输方向：主-->从，该位为0。从-->主，该位为1。\n\n**ACK**/**NACK**：\n\n主机每次发送完数据之后会等待从设备的应答信号ACK。\n如果从设备发送应答信号ACK，则SDA会被拉低；\n若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；\n\n**数据块**：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK/NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。\n\n**停止条件**：先将SDA线从低电压电平切换到高电压电平；\n再将SCL线从高电平拉到低电平。\n\n### 架构层次分类\n\n![](/imgs/I2C驱动框架学习/I2C驱动框架.png)\n\n##### 第一层：\n\n提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层\n\n##### 第二层：\n\n提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层\n\n###### 第三层：\n\n实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层\n\n##### 第四层：\n\n实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层\n\n第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c\n\n第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。\n\n#### 具体分析\ni2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。\n\n看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解\n\n##### i2c_driver\n\n```c\nstruct i2c_driver {\n\tint id;\n\tunsigned int class;\n \n\tint (*attach_adapter)(struct i2c_adapter *);\n\tint (*detach_adapter)(struct i2c_adapter *);\n \n\tint (*detach_client)(struct i2c_client *);\n \n\tint (*command)(struct i2c_client *client,unsigned int cmd, void *arg);\n\tstruct device_driver driver;\n\tstruct list_head list;\n};\n```\n};\n##### i2c_client\n\n```c\nstruct i2c_client {\n\tunsigned int flags;\t\t/* div., see below\t\t*/\n\tunsigned short addr;\t\t/* chip address - NOTE: 7bit \t*/\n\t\t\t\t\t/* addresses are stored in the\t*/\n\t\t\t\t\t/* _LOWER_ 7 bits\t\t*/\n\tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/\n\tstruct i2c_driver *driver;\t/* and our access routines\t*/\n\tint usage_count;\t\t/* How many accesses currently  */\n\t\t\t\t\t/* to the client\t\t*/\n\tstruct device dev;\t\t/* the device structure\t\t*/\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion released;\n};\n```\n\n##### i2c_adapter\n\n```c\nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int id;\n\tunsigned int class;\n\tstruct i2c_algorithm *algo;/* the algorithm to access the bus\t*/\n\tvoid *algo_data;\n \n\t/* --- administration stuff. */\n\tint (*client_register)(struct i2c_client *);\n\tint (*client_unregister)(struct i2c_client *);\n \n\t/* data fields that are valid for all devices\t*/\n\tstruct mutex bus_lock;\n\tstruct mutex clist_lock;\n \n\tint timeout;\n\tint retries;\n\tstruct device dev;\t\t/* the adapter device */\n\tstruct class_device class_dev;\t/* the class device */\n \n\tint nr;\n\tstruct list_head clients;\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion dev_released;\n\tstruct completion class_dev_released;\n};\n```\n##### i2c_algorithm\n\n```c\nstruct i2c_algorithm {\n\tint (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, \n\t                   int num);\n\tint (*slave_send)(struct i2c_adapter *,char*,int);\n\tint (*slave_recv)(struct i2c_adapter *,char*,int);\n\tu32 (*functionality) (struct i2c_adapter *);\n};\n```\n\n##### 【i2c_adapter与i2c_algorithm】\ni2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。\n\ni2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体\n\n \t/*\n \t * I2C Message - used for pure i2c transaction, also from /dev interface\n \t */\n \tstruct i2c_msg {\n \t\t__u16 addr;\t/* slave address\t\t\t*/\n \t \t__u16 flags;\t\t\n \t \t__u16 len;\t\t/* msg length\t\t\t\t*/\n \t \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n \t};\n\n##### 【i2c_driver和i2c_client】\ni2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.\n\n##### 【i2c_adapter和i2c_client】\n\ni2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。\n从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。\n\n我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c\n\n```c\nEXPORT_SYMBOL(i2c_add_adapter);\nEXPORT_SYMBOL(i2c_del_adapter);\nEXPORT_SYMBOL(i2c_del_driver);\nEXPORT_SYMBOL(i2c_attach_client);\nEXPORT_SYMBOL(i2c_detach_client);\n\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。\n\n```c\nint i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tif (adap->algo->master_xfer) {//如果master_xfer函数存在，则调用，否则返回错误\n\t\tret = adap->algo->master_xfer(adap,msgs,num);//这个函数在硬件相关的代码中给algorithm赋值\n\t\treturn ret;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n```\n\n当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下\n\n```c\nint i2c_attach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_register(&client->dev);\n\tdevice_create_file(&client->dev, &dev_attr_client_name);\n\t...\n\treturn 0;\n}\n```\n\n```c\nint i2c_detach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_remove_file(&client->dev, &dev_attr_client_name);\n\tdevice_unregister(&client->dev);\n\t...\n\treturn res;\n}\n```\n\ni2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用\n\n```c\n/* -----\n * i2c_add_adapter is called from within the algorithm layer,\n * when a new hw adapter registers. A new device is register to be\n * available for clients.\n */\nint i2c_add_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tdevice_register(&adap->dev);\n\tdevice_create_file(&adap->dev, &dev_attr_name);\n\t...\n\t/* inform drivers of new adapters */\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->attach_adapter)\n\t\t\t/* We ignore the return code; if it fails, too bad */\n\t\t\tdriver->attach_adapter(adap);\n\t}\n\t...\n}\n```\n\n```c\nint i2c_del_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->detach_adapter)\n\t\t\tif ((res = driver->detach_adapter(adap))) {\n\t\t\t}\n\t}\n\t...\n\tlist_for_each_safe(item, _n, &adap->clients) {\n\t\tclient = list_entry(item, struct i2c_client, list);\n \n\t\tif ((res=client->driver->detach_client(client))) {\n \n\t\t}\n\t}\n\t...\n\tdevice_remove_file(&adap->dev, &dev_attr_name);\n\tdevice_unregister(&adap->dev);\n \n}\n```\n\ni2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的\n\n```c\nstatic struct platform_driver davinci_i2c_driver = {\n\t.probe\t\t= davinci_i2c_probe,\n\t.remove\t\t= davinci_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_davinci\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n \n/* I2C may be needed to bring up other drivers */\nstatic int __init davinci_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&davinci_i2c_driver);\n}\nsubsys_initcall(davinci_i2c_init_driver);\n \nstatic void __exit davinci_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&davinci_i2c_driver);\n}\nmodule_exit(davinci_i2c_exit_driver);\n```\n\n并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器\n\n```c\nstatic struct i2c_algorithm i2c_davinci_algo = {\n\t.master_xfer\t= i2c_davinci_xfer,\n\t.functionality\t= i2c_davinci_func,\n};\n```\n\n然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中\n\n```c\nadap->algo = &i2c_davinci_algo;\n```\n\n\n### 梳理图\n有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:\n\n\n![](/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png)\n\nlinux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。\n\n在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。\n\n#### ov2715设备i2c驱动源码分析\nov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。\n该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。\n该字符设备的用到的结构体有两个，如下\n\n```c\ntypedef struct {\n\n  int devAddr;\n\n  struct i2c_client client;   //!< Data structure containing general access routines.\n  struct i2c_driver driver;   //!< Data structure containing information specific to each client.\n\n  char name[20];\n  int nameSize;\n  int users;\n\n} I2C_Obj;\n```\n\n```c\n#define I2C_DEV_MAX_ADDR  (0xFF)\n#define I2C_TRANSFER_BUF_SIZE_MAX   (256)\ntypedef struct {\n \n  struct cdev cdev;             /* Char device structure    */\n  int     major;\n  struct semaphore semLock;\n    \n  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];\n \n  uint8_t reg[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint16_t reg16[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint8_t buffer[I2C_TRANSFER_BUF_SIZE_MAX*4];\n  \n} I2C_Dev;\n```\n\n一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值\n使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。\n下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。\n首先是该字符设备的初始化和退出函数\n\n```c\nint I2C_devInit(void)\n{\n  int     result, i;\n  dev_t   dev = 0;\n \n  result = alloc_chrdev_region(&dev, 0, 1, I2C_DRV_NAME);//分配字符设备空间\n  \n  for(i=0; i<I2C_DEV_MAX_ADDR; i++)\n  {\n    gI2C_dev.pObj[i]=NULL;\n  }\n \n  gI2C_dev.major = MAJOR(dev);//保存设备主编号\n  sema_init(&gI2C_dev.semLock, 1);//信号量初始化\n  cdev_init(&gI2C_dev.cdev, &gI2C_devFileOps);//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文\n  gI2C_dev.cdev.owner = THIS_MODULE;//常规赋值\n gI2C_dev.cdev.ops = &gI2C_devFileOps;//常规赋值 result = cdev_add(&gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;}void I2C_devExit(void){ dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间}\ngI2c_devFileOps全局变量，驱动初始化会用到该结构体变量\nstruct file_operations gI2C_devFileOps = {\n  .owner = THIS_MODULE,\n  .open = I2C_devOpen,\n  .release = I2C_devRelease,\n  .ioctl = I2C_devIoctl,\n};\n```\n\n该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。\n在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）\n\n```c\nint I2C_devIoctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\n{\n  I2C_Obj *pObj;\n  int status=0;\n  I2C_TransferPrm transferPrm;\n  \n  pObj = (I2C_Obj *)filp->private_data;\n \n  if(!I2C_IOCTL_CMD_IS_VALID(cmd))\n    return -1;\n  cmd = I2C_IOCTL_CMD_GET(cmd);//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd\n \n  down_interruptible(&gI2C_dev.semLock);      //信号量down\n  \n  switch(cmd)\n  {\n    case I2C_CMD_SET_DEV_ADDR://命令1，设置设备地址\n      filp->private_data = I2C_create(arg);\n \n    case I2C_CMD_WRITE:  //命令2，写寄存器值\n      \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n            \n      break;\n    case I2C_CMD_READ:  //命令3，读寄存器值\n    \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n      \n      break;\n    default:\n      status = -1;\n      break;    \n  }\n \n  up(&gI2C_dev.semLock);      //信号量up\n \n  return status;\n}\n```\n\n以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码\n\n```c\nvoid *I2C_create(int devAddr) {\n \n    int ret;\n    struct i2c_driver *driver;\n    struct i2c_client *client = client;\n    I2C_Obj *pObj;\n \n    devAddr >>= 1;\n    \n    if(devAddr>I2C_DEV_MAX_ADDR)  //变量合法性判断\n      return NULL;\n   \n    if(gI2C_dev.pObj[devAddr]!=NULL) {\t//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用\n      // already allocated, increment user count, and return the allocated handle\n      gI2C_dev.pObj[devAddr]->users++;\n      return gI2C_dev.pObj[devAddr];\n    }\n    \n    pObj = (void*)kmalloc( sizeof(I2C_Obj), GFP_KERNEL); //为pObj分配空间\n    gI2C_dev.pObj[devAddr] = pObj;  //将分配的空间地址保存在全局变量里\n    memset(pObj, 0, sizeof(I2C_Obj));\n  \n    pObj->client.adapter = NULL;\n    pObj->users++;    //用户基数，初始化为0，当前设为1\n    pObj->devAddr = devAddr;  //保存设备地址\n    \n    gI2C_curAddr = pObj->devAddr;  //gI2C_curAddr为全局的整型变量，用于保存当前的设备地址\n    driver = &pObj->driver;  //将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动\n \n    pObj->nameSize=0;//i2c设备名称，注意，这里不是在/dev下面的设备节点名\n    pObj->name[pObj->nameSize++] = 'I';\n    pObj->name[pObj->nameSize++] = '2';\n    pObj->name[pObj->nameSize++] = 'C';\n    pObj->name[pObj->nameSize++] = '_';   \n    pObj->name[pObj->nameSize++] = 'A' + ((pObj->devAddr >> 0) & 0xF);\n    pObj->name[pObj->nameSize++] = 'B' + ((pObj->devAddr >> 4) & 0xF);\n    pObj->name[pObj->nameSize++] = 0;\n \n    driver->driver.name = pObj->name; //保存刚才设置的name\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;   //这个很重要，将驱动连接到i2c适配器上，在后面分析\n    driver->detach_client = I2C_detachClient;\t//这个很重，在后面分析\n \n    if((ret = i2c_add_driver(driver)))\t//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()\n    {\n        printk( KERN_ERR \"I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n\", pObj->devAddr);\n    }\n \n    if(ret<0) {\n \n      gI2C_dev.pObj[pObj->devAddr] = NULL;\n      kfree(pObj);    \n      return NULL;\n    }\n    return pObj;\n}\n```\n\n其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()\n\n```c\nint I2C_write(I2C_Obj *pObj, uint8_t *reg, uint8_t *buffer, uint8_t count, uint8_t dataSize)\n{\n  uint8_t i;\n  int err;\n  struct i2c_client *client;\n\tstruct i2c_msg msg[1];\n\tunsigned char data[8];\n \n  if(pObj==NULL)\n    return -ENODEV;\n \n  client = &pObj->client;//得到client信息\n  if(!client->adapter)\n    return -ENODEV;  \n  \n  if(dataSize<=0||dataSize>4)\n    return -1;\n    \n  for(i=0; i<count; i++) {\n  \n    msg->addr = client->addr;//设置要写的i2c设备地址\n    msg->flags= 0;//一直为0\n    msg->buf  = data;//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值\n\t\t\n    data[0] = reg[i];//寄存器地址赋值\n\t\t\n    if(dataSize==1) {//寄存器值长度为1\n       data[1]  = buffer[i];//寄存器值赋值\n       msg->len = 2;  \t//设置data长度为2\t\n    }\telse if(dataSize==2) {//寄存器值长度为2\n       data[1] = buffer[2*i+1];\n       data[2] = buffer[2*i];\n       msg->len = 3;\n    } \n    err = i2c_transfer(client->adapter, msg, 1);//调用i2c-core中的i2c_transfer发送i2c数据\n    if( err < 0 )\n      return err;\n    }\n  \n  return 0;\n}\n```\n\n重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的\n\n```c\n    driver->driver.name = pObj->name;\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;\n    driver->detach_client = I2C_detachClient;\n```\n在i2c_driver结构体中针对attach_adapter有这样的说明：\n\n```c\n\t/* Notifies the driver that a new bus has appeared. This routine\n\t * can be used by the driver to test if the bus meets its conditions\n\t * & seek for the presence of the chip(s) it supports. If found, it \n\t * registers the client(s) that are on the bus to the i2c admin. via\n\t * i2c_attach_client.\n\t */\n```\n\n意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示\n\n```c\nint I2C_attachAdapter(struct i2c_adapter *adapter)\n{\n    return I2C_detectClient(adapter, gI2C_curAddr);\n}\n \nint I2C_detectClient(struct i2c_adapter *adapter, int address)\n{\n    I2C_Obj *pObj;\n    struct i2c_client *client;\n    int err = 0;\n    \n    if(address > I2C_DEV_MAX_ADDR) {\n      printk( KERN_ERR \"I2C: ERROR: Invalid device address %x\\n\", address);        \n      return -1;\n    }\n      \n    pObj = gI2C_dev.pObj[address];\n    if(pObj==NULL) {\n      printk( KERN_ERR \"I2C: ERROR: Object not found for address %x\\n\", address);    \n      return -1;\n    }\n \n    client = &pObj->client;\n \n    if(client->adapter)\n      return -EBUSY;  /* our client is already attached */\n \n    memset(client, 0x00, sizeof(struct i2c_client));\n    client->addr = pObj->devAddr;\n    client->adapter = adapter;\n    client->driver = &pObj->driver;\n \n    if((err = i2c_attach_client(client)))\n    {\n        printk( KERN_ERR \"I2C: ERROR: Couldn't attach %s (address=%x)\\n\", pObj->name, pObj->devAddr);\n        client->adapter = NULL;\n        return err;\n    }\n    return 0;\n}\n```\n最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。\n当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：\n\n```c\n\t/* tells the driver that a client is about to be deleted & gives it \n\t * the chance to remove its private data. Also, if the client struct\n\t * has been dynamically allocated by the driver in the function above,\n\t * it must be freed here.\n\t */\n```\n\n下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接\n\n```c\nint I2C_detachClient(struct i2c_client *client)\n{\n    int err;\nif(!client->adapter)\n    return -ENODEV; /* our client isn't attached */\n \nif((err = i2c_detach_client(client))) {\n    printk( KERN_ERR \"Client deregistration failed (address=%x), client not detached.\\n\", client->addr);\n    return err;\n}\n \nclient->adapter = NULL;\n \nreturn 0;\n```\n}\n\n\n\n\n\n\n\n\n<small>misslyh20080512202305122023080719980106202309281520825879280398965</small>\n","slug":"I2C驱动框架学习","published":1,"updated":"2023-09-30T16:02:57.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6se0001lcwfg1tfc2a4","content":"<h1 id=\"I2C通信：\"><a href=\"#I2C通信：\" class=\"headerlink\" title=\"I2C通信：\"></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>\n<h3 id=\"CAN总线仲裁：\"><a href=\"#CAN总线仲裁：\" class=\"headerlink\" title=\"CAN总线仲裁：\"></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif\"><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>\n<h3 id=\"数据传输协议：\"><a href=\"#数据传输协议：\" class=\"headerlink\" title=\"数据传输协议：\"></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>\n<h4 id=\"开始条件：\"><a href=\"#开始条件：\" class=\"headerlink\" title=\"开始条件：\"></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>\n<p><strong>地址位</strong>：</p>\n<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>\n<p><strong>读写位</strong>：</p>\n<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>\n<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>\n<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>\n<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>\n<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>\n<h3 id=\"架构层次分类\"><a href=\"#架构层次分类\" class=\"headerlink\" title=\"架构层次分类\"></a>架构层次分类</h3><p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png\"></p>\n<h5 id=\"第一层：\"><a href=\"#第一层：\" class=\"headerlink\" title=\"第一层：\"></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>\n<h5 id=\"第二层：\"><a href=\"#第二层：\" class=\"headerlink\" title=\"第二层：\"></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>\n<h6 id=\"第三层：\"><a href=\"#第三层：\" class=\"headerlink\" title=\"第三层：\"></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>\n<h5 id=\"第四层：\"><a href=\"#第四层：\" class=\"headerlink\" title=\"第四层：\"></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>\n<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>\n<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>\n<h4 id=\"具体分析\"><a href=\"#具体分析\" class=\"headerlink\" title=\"具体分析\"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>\n<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>\n<h5 id=\"i2c-driver\"><a href=\"#i2c-driver\" class=\"headerlink\" title=\"i2c_driver\"></a>i2c_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span> id;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>;</span><br> <br>\t<span class=\"hljs-type\">int</span> (*attach_adapter)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br>\t<span class=\"hljs-type\">int</span> (*detach_adapter)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br> <br>\t<span class=\"hljs-type\">int</span> (*detach_client)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br> <br>\t<span class=\"hljs-type\">int</span> (*command)(<span class=\"hljs-keyword\">struct</span> i2c_client *client,<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> cmd, <span class=\"hljs-type\">void</span> *arg);<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device_driver</span> <span class=\"hljs-title\">driver</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>};</p>\n<h5 id=\"i2c-client\"><a href=\"#i2c-client\" class=\"headerlink\" title=\"i2c_client\"></a>i2c_client</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> &#123;</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags;\t\t<span class=\"hljs-comment\">/* div., see below\t\t*/</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">short</span> addr;\t\t<span class=\"hljs-comment\">/* chip address - <span class=\"hljs-doctag\">NOTE:</span> 7bit \t*/</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* addresses are stored in the\t*/</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* _LOWER_ 7 bits\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_adapter</span> *<span class=\"hljs-title\">adapter</span>;</span>\t<span class=\"hljs-comment\">/* the adapter we sit on\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> *<span class=\"hljs-title\">driver</span>;</span>\t<span class=\"hljs-comment\">/* and our access routines\t*/</span><br>\t<span class=\"hljs-type\">int</span> usage_count;\t\t<span class=\"hljs-comment\">/* How many accesses currently  */</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* to the client\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device</span> <span class=\"hljs-title\">dev</span>;</span>\t\t<span class=\"hljs-comment\">/* the device structure\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>\t<span class=\"hljs-type\">char</span> name[I2C_NAME_SIZE];<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"i2c-adapter\"><a href=\"#i2c-adapter\" class=\"headerlink\" title=\"i2c_adapter\"></a>i2c_adapter</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_adapter</span> &#123;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">module</span> *<span class=\"hljs-title\">owner</span>;</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> *<span class=\"hljs-title\">algo</span>;</span><span class=\"hljs-comment\">/* the algorithm to access the bus\t*/</span><br>\t<span class=\"hljs-type\">void</span> *algo_data;<br> <br>\t<span class=\"hljs-comment\">/* --- administration stuff. */</span><br>\t<span class=\"hljs-type\">int</span> (*client_register)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br>\t<span class=\"hljs-type\">int</span> (*client_unregister)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br> <br>\t<span class=\"hljs-comment\">/* data fields that are valid for all devices\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mutex</span> <span class=\"hljs-title\">bus_lock</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mutex</span> <span class=\"hljs-title\">clist_lock</span>;</span><br> <br>\t<span class=\"hljs-type\">int</span> timeout;<br>\t<span class=\"hljs-type\">int</span> retries;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device</span> <span class=\"hljs-title\">dev</span>;</span>\t\t<span class=\"hljs-comment\">/* the adapter device */</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">class_device</span> <span class=\"hljs-title\">class_dev</span>;</span>\t<span class=\"hljs-comment\">/* the class device */</span><br> <br>\t<span class=\"hljs-type\">int</span> nr;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">clients</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>\t<span class=\"hljs-type\">char</span> name[I2C_NAME_SIZE];<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">dev_released</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">class_dev_released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"i2c-algorithm\"><a href=\"#i2c-algorithm\" class=\"headerlink\" title=\"i2c_algorithm\"></a>i2c_algorithm</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span> (*master_xfer)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap,<span class=\"hljs-keyword\">struct</span> i2c_msg *msgs, <br>\t                   <span class=\"hljs-type\">int</span> num);<br>\t<span class=\"hljs-type\">int</span> (*slave_send)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *,<span class=\"hljs-type\">char</span>*,<span class=\"hljs-type\">int</span>);<br>\t<span class=\"hljs-type\">int</span> (*slave_recv)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *,<span class=\"hljs-type\">char</span>*,<span class=\"hljs-type\">int</span>);<br>\tu32 (*functionality) (<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"【i2c-adapter与i2c-algorithm】\"><a href=\"#【i2c-adapter与i2c-algorithm】\" class=\"headerlink\" title=\"【i2c_adapter与i2c_algorithm】\"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>\n<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>\n<pre><code class=\"hljs\"> /*\n  * I2C Message - used for pure i2c transaction, also from /dev interface\n  */\n struct i2c_msg &#123;\n     __u16 addr;\t/* slave address\t\t\t*/\n  \t__u16 flags;\t\t\n  \t__u16 len;\t\t/* msg length\t\t\t\t*/\n  \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n &#125;;\n</code></pre>\n<h5 id=\"【i2c-driver和i2c-client】\"><a href=\"#【i2c-driver和i2c-client】\" class=\"headerlink\" title=\"【i2c_driver和i2c_client】\"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>\n<h5 id=\"【i2c-adapter和i2c-client】\"><a href=\"#【i2c-adapter和i2c-client】\" class=\"headerlink\" title=\"【i2c_adapter和i2c_client】\"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>\n<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">EXPORT_SYMBOL(i2c_add_adapter);<br>EXPORT_SYMBOL(i2c_del_adapter);<br>EXPORT_SYMBOL(i2c_del_driver);<br>EXPORT_SYMBOL(i2c_attach_client);<br>EXPORT_SYMBOL(i2c_detach_client);<br><br>EXPORT_SYMBOL(i2c_transfer);<br></code></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_transfer</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter * adap, <span class=\"hljs-keyword\">struct</span> i2c_msg *msgs, <span class=\"hljs-type\">int</span> num)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> ret;<br>\t<span class=\"hljs-keyword\">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class=\"hljs-comment\">//如果master_xfer函数存在，则调用，否则返回错误</span><br>\t\tret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class=\"hljs-comment\">//这个函数在硬件相关的代码中给algorithm赋值</span><br>\t\t<span class=\"hljs-keyword\">return</span> ret;<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> -ENOSYS;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_attach_client</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>\t...<br>\tdevice_register(&amp;client-&gt;dev);<br>\tdevice_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>\t...<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_detach_client</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>\t...<br>\tdevice_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>\tdevice_unregister(&amp;client-&gt;dev);<br>\t...<br>\t<span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* -----</span><br><span class=\"hljs-comment\"> * i2c_add_adapter is called from within the algorithm layer,</span><br><span class=\"hljs-comment\"> * when a new hw adapter registers. A new device is register to be</span><br><span class=\"hljs-comment\"> * available for clients.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_add_adapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap)</span><br>&#123;<br>\t...<br>\tdevice_register(&amp;adap-&gt;dev);<br>\tdevice_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>\t...<br>\t<span class=\"hljs-comment\">/* inform drivers of new adapters */</span><br>\tlist_for_each(item,&amp;drivers) &#123;<br>\t\tdriver = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_driver, <span class=\"hljs-built_in\">list</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (driver-&gt;attach_adapter)<br>\t\t\t<span class=\"hljs-comment\">/* We ignore the return code; if it fails, too bad */</span><br>\t\t\tdriver-&gt;attach_adapter(adap);<br>\t&#125;<br>\t...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_del_adapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap)</span><br>&#123;<br>\t...<br>\tlist_for_each(item,&amp;drivers) &#123;<br>\t\tdriver = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_driver, <span class=\"hljs-built_in\">list</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (driver-&gt;detach_adapter)<br>\t\t\t<span class=\"hljs-keyword\">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;<br>\t\t\t&#125;<br>\t&#125;<br>\t...<br>\tlist_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;<br>\t\tclient = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_client, <span class=\"hljs-built_in\">list</span>);<br> <br>\t\t<span class=\"hljs-keyword\">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;<br> <br>\t\t&#125;<br>\t&#125;<br>\t...<br>\tdevice_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>\tdevice_unregister(&amp;adap-&gt;dev);<br> <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">platform_driver</span> <span class=\"hljs-title\">davinci_i2c_driver</span> =</span> &#123;<br>\t.probe\t\t= davinci_i2c_probe,<br>\t.remove\t\t= davinci_i2c_remove,<br>\t.driver\t\t= &#123;<br>\t\t.name\t= <span class=\"hljs-string\">&quot;i2c_davinci&quot;</span>,<br>\t\t.owner\t= THIS_MODULE,<br>\t&#125;,<br>&#125;;<br> <br><span class=\"hljs-comment\">/* I2C may be needed to bring up other drivers */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">davinci_i2c_init_driver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> platform_driver_register(&amp;davinci_i2c_driver);<br>&#125;<br>subsys_initcall(davinci_i2c_init_driver);<br> <br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">davinci_i2c_exit_driver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tplatform_driver_unregister(&amp;davinci_i2c_driver);<br>&#125;<br>module_exit(davinci_i2c_exit_driver);<br></code></pre></td></tr></table></figure>\n\n<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> <span class=\"hljs-title\">i2c_davinci_algo</span> =</span> &#123;<br>\t.master_xfer\t= i2c_davinci_xfer,<br>\t.functionality\t= i2c_davinci_func,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">adap-&gt;algo = &amp;i2c_davinci_algo;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"梳理图\"><a href=\"#梳理图\" class=\"headerlink\" title=\"梳理图\"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>\n<p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png\"></p>\n<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>\n<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>\n<h4 id=\"ov2715设备i2c驱动源码分析\"><a href=\"#ov2715设备i2c驱动源码分析\" class=\"headerlink\" title=\"ov2715设备i2c驱动源码分析\"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> &#123;</span><br><br>  <span class=\"hljs-type\">int</span> devAddr;<br><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> <span class=\"hljs-title\">client</span>;</span>   <span class=\"hljs-comment\">//!&lt; Data structure containing general access routines.</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> <span class=\"hljs-title\">driver</span>;</span>   <span class=\"hljs-comment\">//!&lt; Data structure containing information specific to each client.</span><br><br>  <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<br>  <span class=\"hljs-type\">int</span> nameSize;<br>  <span class=\"hljs-type\">int</span> users;<br><br>&#125; I2C_Obj;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> &#123;</span><br> <br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">cdev</span> <span class=\"hljs-title\">cdev</span>;</span>             <span class=\"hljs-comment\">/* Char device structure    */</span><br>  <span class=\"hljs-type\">int</span>     major;<br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">semaphore</span> <span class=\"hljs-title\">semLock</span>;</span><br>    <br>  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];<br> <br>  <span class=\"hljs-type\">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class=\"hljs-type\">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class=\"hljs-type\">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class=\"hljs-number\">4</span>];<br>  <br>&#125; I2C_Dev;<br></code></pre></td></tr></table></figure>\n\n<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_devInit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>  <span class=\"hljs-type\">int</span>     result, i;<br>  <span class=\"hljs-type\">dev_t</span>   dev = <span class=\"hljs-number\">0</span>;<br> <br>  result = alloc_chrdev_region(&amp;dev, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, I2C_DRV_NAME);<span class=\"hljs-comment\">//分配字符设备空间</span><br>  <br>  <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)<br>  &#123;<br>    gI2C_dev.pObj[i]=<span class=\"hljs-literal\">NULL</span>;<br>  &#125;<br> <br>  gI2C_dev.major = MAJOR(dev);<span class=\"hljs-comment\">//保存设备主编号</span><br>  sema_init(&amp;gI2C_dev.semLock, <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//信号量初始化</span><br>  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class=\"hljs-comment\">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span><br>  gI2C_dev.cdev.owner = THIS_MODULE;<span class=\"hljs-comment\">//常规赋值</span><br> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class=\"hljs-comment\">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span><br>gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">file_operations</span> <span class=\"hljs-title\">gI2C_devFileOps</span> =</span> &#123;<br>  .owner = THIS_MODULE,<br>  .open = I2C_devOpen,<br>  .release = I2C_devRelease,<br>  .ioctl = I2C_devIoctl,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_devIoctl</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> inode *inode, <span class=\"hljs-keyword\">struct</span> file *filp, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> cmd, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg)</span><br>&#123;<br>  I2C_Obj *pObj;<br>  <span class=\"hljs-type\">int</span> status=<span class=\"hljs-number\">0</span>;<br>  I2C_TransferPrm transferPrm;<br>  <br>  pObj = (I2C_Obj *)filp-&gt;private_data;<br> <br>  <span class=\"hljs-keyword\">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  cmd = I2C_IOCTL_CMD_GET(cmd);<span class=\"hljs-comment\">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span><br> <br>  down_interruptible(&amp;gI2C_dev.semLock);      <span class=\"hljs-comment\">//信号量down</span><br>  <br>  <span class=\"hljs-keyword\">switch</span>(cmd)<br>  &#123;<br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_SET_DEV_ADDR:<span class=\"hljs-comment\">//命令1，设置设备地址</span><br>      filp-&gt;private_data = I2C_create(arg);<br> <br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_WRITE:  <span class=\"hljs-comment\">//命令2，写寄存器值</span><br>      <br>      status = copy_from_user(&amp;transferPrm, (<span class=\"hljs-type\">void</span> *)arg, <span class=\"hljs-keyword\">sizeof</span>(transferPrm));<br>      ...<br>            <br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_READ:  <span class=\"hljs-comment\">//命令3，读寄存器值</span><br>    <br>      status = copy_from_user(&amp;transferPrm, (<span class=\"hljs-type\">void</span> *)arg, <span class=\"hljs-keyword\">sizeof</span>(transferPrm));<br>      ...<br>      <br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">default</span>:<br>      status = <span class=\"hljs-number\">-1</span>;<br>      <span class=\"hljs-keyword\">break</span>;    <br>  &#125;<br> <br>  up(&amp;gI2C_dev.semLock);      <span class=\"hljs-comment\">//信号量up</span><br> <br>  <span class=\"hljs-keyword\">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">I2C_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> devAddr)</span> &#123;<br> <br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> *<span class=\"hljs-title\">driver</span>;</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span> =</span> client;<br>    I2C_Obj *pObj;<br> <br>    devAddr &gt;&gt;= <span class=\"hljs-number\">1</span>;<br>    <br>    <span class=\"hljs-keyword\">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class=\"hljs-comment\">//变量合法性判断</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>   <br>    <span class=\"hljs-keyword\">if</span>(gI2C_dev.pObj[devAddr]!=<span class=\"hljs-literal\">NULL</span>) &#123;\t<span class=\"hljs-comment\">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span><br>      <span class=\"hljs-comment\">// already allocated, increment user count, and return the allocated handle</span><br>      gI2C_dev.pObj[devAddr]-&gt;users++;<br>      <span class=\"hljs-keyword\">return</span> gI2C_dev.pObj[devAddr];<br>    &#125;<br>    <br>    pObj = (<span class=\"hljs-type\">void</span>*)kmalloc( <span class=\"hljs-keyword\">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class=\"hljs-comment\">//为pObj分配空间</span><br>    gI2C_dev.pObj[devAddr] = pObj;  <span class=\"hljs-comment\">//将分配的空间地址保存在全局变量里</span><br>    <span class=\"hljs-built_in\">memset</span>(pObj, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(I2C_Obj));<br>  <br>    pObj-&gt;client.adapter = <span class=\"hljs-literal\">NULL</span>;<br>    pObj-&gt;users++;    <span class=\"hljs-comment\">//用户基数，初始化为0，当前设为1</span><br>    pObj-&gt;devAddr = devAddr;  <span class=\"hljs-comment\">//保存设备地址</span><br>    <br>    gI2C_curAddr = pObj-&gt;devAddr;  <span class=\"hljs-comment\">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span><br>    driver = &amp;pObj-&gt;driver;  <span class=\"hljs-comment\">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span><br> <br>    pObj-&gt;nameSize=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span><br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;I&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;2&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;C&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;_&#x27;</span>;   <br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"hljs-number\">0</span>) &amp; <span class=\"hljs-number\">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"hljs-number\">4</span>) &amp; <span class=\"hljs-number\">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-number\">0</span>;<br> <br>    driver-&gt;driver.name = pObj-&gt;name; <span class=\"hljs-comment\">//保存刚才设置的name</span><br>    driver-&gt;id = I2C_DRIVERID_MISC;<br>    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class=\"hljs-comment\">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span><br>    driver-&gt;detach_client = I2C_detachClient;\t<span class=\"hljs-comment\">//这个很重，在后面分析</span><br> <br>    <span class=\"hljs-keyword\">if</span>((ret = i2c_add_driver(driver)))\t<span class=\"hljs-comment\">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span><br>    &#123;<br>        printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n&quot;</span>, pObj-&gt;devAddr);<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span>(ret&lt;<span class=\"hljs-number\">0</span>) &#123;<br> <br>      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class=\"hljs-literal\">NULL</span>;<br>      kfree(pObj);    <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_write</span><span class=\"hljs-params\">(I2C_Obj *pObj, <span class=\"hljs-type\">uint8_t</span> *reg, <span class=\"hljs-type\">uint8_t</span> *buffer, <span class=\"hljs-type\">uint8_t</span> count, <span class=\"hljs-type\">uint8_t</span> dataSize)</span><br>&#123;<br>  <span class=\"hljs-type\">uint8_t</span> i;<br>  <span class=\"hljs-type\">int</span> err;<br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_msg</span> <span class=\"hljs-title\">msg</span>[1];</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> data[<span class=\"hljs-number\">8</span>];<br> <br>  <span class=\"hljs-keyword\">if</span>(pObj==<span class=\"hljs-literal\">NULL</span>)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV;<br> <br>  client = &amp;pObj-&gt;client;<span class=\"hljs-comment\">//得到client信息</span><br>  <span class=\"hljs-keyword\">if</span>(!client-&gt;adapter)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV;  <br>  <br>  <span class=\"hljs-keyword\">if</span>(dataSize&lt;=<span class=\"hljs-number\">0</span>||dataSize&gt;<span class=\"hljs-number\">4</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <br>  <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>; i&lt;count; i++) &#123;<br>  <br>    msg-&gt;addr = client-&gt;addr;<span class=\"hljs-comment\">//设置要写的i2c设备地址</span><br>    msg-&gt;flags= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//一直为0</span><br>    msg-&gt;buf  = data;<span class=\"hljs-comment\">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span><br>\t\t<br>    data[<span class=\"hljs-number\">0</span>] = reg[i];<span class=\"hljs-comment\">//寄存器地址赋值</span><br>\t\t<br>    <span class=\"hljs-keyword\">if</span>(dataSize==<span class=\"hljs-number\">1</span>) &#123;<span class=\"hljs-comment\">//寄存器值长度为1</span><br>       data[<span class=\"hljs-number\">1</span>]  = buffer[i];<span class=\"hljs-comment\">//寄存器值赋值</span><br>       msg-&gt;len = <span class=\"hljs-number\">2</span>;  \t<span class=\"hljs-comment\">//设置data长度为2\t</span><br>    &#125;\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dataSize==<span class=\"hljs-number\">2</span>) &#123;<span class=\"hljs-comment\">//寄存器值长度为2</span><br>       data[<span class=\"hljs-number\">1</span>] = buffer[<span class=\"hljs-number\">2</span>*i+<span class=\"hljs-number\">1</span>];<br>       data[<span class=\"hljs-number\">2</span>] = buffer[<span class=\"hljs-number\">2</span>*i];<br>       msg-&gt;len = <span class=\"hljs-number\">3</span>;<br>    &#125; <br>    err = i2c_transfer(client-&gt;adapter, msg, <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//调用i2c-core中的i2c_transfer发送i2c数据</span><br>    <span class=\"hljs-keyword\">if</span>( err &lt; <span class=\"hljs-number\">0</span> )<br>      <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">driver-&gt;driver.name = pObj-&gt;name;<br>driver-&gt;id = I2C_DRIVERID_MISC;<br>driver-&gt;attach_adapter = I2C_attachAdapter;<br>driver-&gt;detach_client = I2C_detachClient;<br></code></pre></td></tr></table></figure>\n<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Notifies the driver that a new bus has appeared. This routine</span><br><span class=\"hljs-comment\"> * can be used by the driver to test if the bus meets its conditions</span><br><span class=\"hljs-comment\"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span><br><span class=\"hljs-comment\"> * registers the client(s) that are on the bus to the i2c admin. via</span><br><span class=\"hljs-comment\"> * i2c_attach_client.</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_attachAdapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adapter)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> I2C_detectClient(adapter, gI2C_curAddr);<br>&#125;<br> <br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_detectClient</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adapter, <span class=\"hljs-type\">int</span> address)</span><br>&#123;<br>    I2C_Obj *pObj;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span>;</span><br>    <span class=\"hljs-type\">int</span> err = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;<br>      printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Invalid device address %x\\n&quot;</span>, address);        <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>      <br>    pObj = gI2C_dev.pObj[address];<br>    <span class=\"hljs-keyword\">if</span>(pObj==<span class=\"hljs-literal\">NULL</span>) &#123;<br>      printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Object not found for address %x\\n&quot;</span>, address);    <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br> <br>    client = &amp;pObj-&gt;client;<br> <br>    <span class=\"hljs-keyword\">if</span>(client-&gt;adapter)<br>      <span class=\"hljs-keyword\">return</span> -EBUSY;  <span class=\"hljs-comment\">/* our client is already attached */</span><br> <br>    <span class=\"hljs-built_in\">memset</span>(client, <span class=\"hljs-number\">0x00</span>, <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> i2c_client));<br>    client-&gt;addr = pObj-&gt;devAddr;<br>    client-&gt;adapter = adapter;<br>    client-&gt;driver = &amp;pObj-&gt;driver;<br> <br>    <span class=\"hljs-keyword\">if</span>((err = i2c_attach_client(client)))<br>    &#123;<br>        printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);<br>        client-&gt;adapter = <span class=\"hljs-literal\">NULL</span>;<br>        <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* tells the driver that a client is about to be deleted &amp; gives it </span><br><span class=\"hljs-comment\"> * the chance to remove its private data. Also, if the client struct</span><br><span class=\"hljs-comment\"> * has been dynamically allocated by the driver in the function above,</span><br><span class=\"hljs-comment\"> * it must be freed here.</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_detachClient</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> err;<br><span class=\"hljs-keyword\">if</span>(!client-&gt;adapter)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV; <span class=\"hljs-comment\">/* our client isn&#x27;t attached */</span><br> <br><span class=\"hljs-keyword\">if</span>((err = i2c_detach_client(client))) &#123;<br>    printk( KERN_ERR <span class=\"hljs-string\">&quot;Client deregistration failed (address=%x), client not detached.\\n&quot;</span>, client-&gt;addr);<br>    <span class=\"hljs-keyword\">return</span> err;<br>&#125;<br> <br>client-&gt;adapter = <span class=\"hljs-literal\">NULL</span>;<br> <br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>}</p>\n<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"I2C通信：\"><a href=\"#I2C通信：\" class=\"headerlink\" title=\"I2C通信：\"></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>\n<h3 id=\"CAN总线仲裁：\"><a href=\"#CAN总线仲裁：\" class=\"headerlink\" title=\"CAN总线仲裁：\"></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif\"><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>\n<h3 id=\"数据传输协议：\"><a href=\"#数据传输协议：\" class=\"headerlink\" title=\"数据传输协议：\"></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>\n<h4 id=\"开始条件：\"><a href=\"#开始条件：\" class=\"headerlink\" title=\"开始条件：\"></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>\n<p><strong>地址位</strong>：</p>\n<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>\n<p><strong>读写位</strong>：</p>\n<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>\n<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>\n<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>\n<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>\n<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>\n<h3 id=\"架构层次分类\"><a href=\"#架构层次分类\" class=\"headerlink\" title=\"架构层次分类\"></a>架构层次分类</h3><p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png\"></p>\n<h5 id=\"第一层：\"><a href=\"#第一层：\" class=\"headerlink\" title=\"第一层：\"></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>\n<h5 id=\"第二层：\"><a href=\"#第二层：\" class=\"headerlink\" title=\"第二层：\"></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>\n<h6 id=\"第三层：\"><a href=\"#第三层：\" class=\"headerlink\" title=\"第三层：\"></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>\n<h5 id=\"第四层：\"><a href=\"#第四层：\" class=\"headerlink\" title=\"第四层：\"></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>\n<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>\n<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>\n<h4 id=\"具体分析\"><a href=\"#具体分析\" class=\"headerlink\" title=\"具体分析\"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>\n<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>\n<h5 id=\"i2c-driver\"><a href=\"#i2c-driver\" class=\"headerlink\" title=\"i2c_driver\"></a>i2c_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span> id;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>;</span><br> <br>\t<span class=\"hljs-type\">int</span> (*attach_adapter)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br>\t<span class=\"hljs-type\">int</span> (*detach_adapter)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br> <br>\t<span class=\"hljs-type\">int</span> (*detach_client)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br> <br>\t<span class=\"hljs-type\">int</span> (*command)(<span class=\"hljs-keyword\">struct</span> i2c_client *client,<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> cmd, <span class=\"hljs-type\">void</span> *arg);<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device_driver</span> <span class=\"hljs-title\">driver</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>};</p>\n<h5 id=\"i2c-client\"><a href=\"#i2c-client\" class=\"headerlink\" title=\"i2c_client\"></a>i2c_client</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> &#123;</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags;\t\t<span class=\"hljs-comment\">/* div., see below\t\t*/</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">short</span> addr;\t\t<span class=\"hljs-comment\">/* chip address - <span class=\"hljs-doctag\">NOTE:</span> 7bit \t*/</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* addresses are stored in the\t*/</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* _LOWER_ 7 bits\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_adapter</span> *<span class=\"hljs-title\">adapter</span>;</span>\t<span class=\"hljs-comment\">/* the adapter we sit on\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> *<span class=\"hljs-title\">driver</span>;</span>\t<span class=\"hljs-comment\">/* and our access routines\t*/</span><br>\t<span class=\"hljs-type\">int</span> usage_count;\t\t<span class=\"hljs-comment\">/* How many accesses currently  */</span><br>\t\t\t\t\t<span class=\"hljs-comment\">/* to the client\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device</span> <span class=\"hljs-title\">dev</span>;</span>\t\t<span class=\"hljs-comment\">/* the device structure\t\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>\t<span class=\"hljs-type\">char</span> name[I2C_NAME_SIZE];<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"i2c-adapter\"><a href=\"#i2c-adapter\" class=\"headerlink\" title=\"i2c_adapter\"></a>i2c_adapter</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_adapter</span> &#123;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">module</span> *<span class=\"hljs-title\">owner</span>;</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> *<span class=\"hljs-title\">algo</span>;</span><span class=\"hljs-comment\">/* the algorithm to access the bus\t*/</span><br>\t<span class=\"hljs-type\">void</span> *algo_data;<br> <br>\t<span class=\"hljs-comment\">/* --- administration stuff. */</span><br>\t<span class=\"hljs-type\">int</span> (*client_register)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br>\t<span class=\"hljs-type\">int</span> (*client_unregister)(<span class=\"hljs-keyword\">struct</span> i2c_client *);<br> <br>\t<span class=\"hljs-comment\">/* data fields that are valid for all devices\t*/</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mutex</span> <span class=\"hljs-title\">bus_lock</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">mutex</span> <span class=\"hljs-title\">clist_lock</span>;</span><br> <br>\t<span class=\"hljs-type\">int</span> timeout;<br>\t<span class=\"hljs-type\">int</span> retries;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">device</span> <span class=\"hljs-title\">dev</span>;</span>\t\t<span class=\"hljs-comment\">/* the adapter device */</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">class_device</span> <span class=\"hljs-title\">class_dev</span>;</span>\t<span class=\"hljs-comment\">/* the class device */</span><br> <br>\t<span class=\"hljs-type\">int</span> nr;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">clients</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_head</span> <span class=\"hljs-title\">list</span>;</span><br>\t<span class=\"hljs-type\">char</span> name[I2C_NAME_SIZE];<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">dev_released</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">completion</span> <span class=\"hljs-title\">class_dev_released</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h5 id=\"i2c-algorithm\"><a href=\"#i2c-algorithm\" class=\"headerlink\" title=\"i2c_algorithm\"></a>i2c_algorithm</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span> (*master_xfer)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap,<span class=\"hljs-keyword\">struct</span> i2c_msg *msgs, <br>\t                   <span class=\"hljs-type\">int</span> num);<br>\t<span class=\"hljs-type\">int</span> (*slave_send)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *,<span class=\"hljs-type\">char</span>*,<span class=\"hljs-type\">int</span>);<br>\t<span class=\"hljs-type\">int</span> (*slave_recv)(<span class=\"hljs-keyword\">struct</span> i2c_adapter *,<span class=\"hljs-type\">char</span>*,<span class=\"hljs-type\">int</span>);<br>\tu32 (*functionality) (<span class=\"hljs-keyword\">struct</span> i2c_adapter *);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"【i2c-adapter与i2c-algorithm】\"><a href=\"#【i2c-adapter与i2c-algorithm】\" class=\"headerlink\" title=\"【i2c_adapter与i2c_algorithm】\"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>\n<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>\n<pre><code> /*\n  * I2C Message - used for pure i2c transaction, also from /dev interface\n  */\n struct i2c_msg &#123;\n     __u16 addr;\t/* slave address\t\t\t*/\n  \t__u16 flags;\t\t\n  \t__u16 len;\t\t/* msg length\t\t\t\t*/\n  \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n &#125;;\n</code></pre>\n<h5 id=\"【i2c-driver和i2c-client】\"><a href=\"#【i2c-driver和i2c-client】\" class=\"headerlink\" title=\"【i2c_driver和i2c_client】\"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>\n<h5 id=\"【i2c-adapter和i2c-client】\"><a href=\"#【i2c-adapter和i2c-client】\" class=\"headerlink\" title=\"【i2c_adapter和i2c_client】\"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>\n<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">EXPORT_SYMBOL(i2c_add_adapter);<br>EXPORT_SYMBOL(i2c_del_adapter);<br>EXPORT_SYMBOL(i2c_del_driver);<br>EXPORT_SYMBOL(i2c_attach_client);<br>EXPORT_SYMBOL(i2c_detach_client);<br><br>EXPORT_SYMBOL(i2c_transfer);<br></code></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_transfer</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter * adap, <span class=\"hljs-keyword\">struct</span> i2c_msg *msgs, <span class=\"hljs-type\">int</span> num)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> ret;<br>\t<span class=\"hljs-keyword\">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class=\"hljs-comment\">//如果master_xfer函数存在，则调用，否则返回错误</span><br>\t\tret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class=\"hljs-comment\">//这个函数在硬件相关的代码中给algorithm赋值</span><br>\t\t<span class=\"hljs-keyword\">return</span> ret;<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> -ENOSYS;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_attach_client</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>\t...<br>\tdevice_register(&amp;client-&gt;dev);<br>\tdevice_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>\t...<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_detach_client</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>\t...<br>\tdevice_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);<br>\tdevice_unregister(&amp;client-&gt;dev);<br>\t...<br>\t<span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* -----</span><br><span class=\"hljs-comment\"> * i2c_add_adapter is called from within the algorithm layer,</span><br><span class=\"hljs-comment\"> * when a new hw adapter registers. A new device is register to be</span><br><span class=\"hljs-comment\"> * available for clients.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_add_adapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap)</span><br>&#123;<br>\t...<br>\tdevice_register(&amp;adap-&gt;dev);<br>\tdevice_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>\t...<br>\t<span class=\"hljs-comment\">/* inform drivers of new adapters */</span><br>\tlist_for_each(item,&amp;drivers) &#123;<br>\t\tdriver = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_driver, <span class=\"hljs-built_in\">list</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (driver-&gt;attach_adapter)<br>\t\t\t<span class=\"hljs-comment\">/* We ignore the return code; if it fails, too bad */</span><br>\t\t\tdriver-&gt;attach_adapter(adap);<br>\t&#125;<br>\t...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">i2c_del_adapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adap)</span><br>&#123;<br>\t...<br>\tlist_for_each(item,&amp;drivers) &#123;<br>\t\tdriver = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_driver, <span class=\"hljs-built_in\">list</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (driver-&gt;detach_adapter)<br>\t\t\t<span class=\"hljs-keyword\">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;<br>\t\t\t&#125;<br>\t&#125;<br>\t...<br>\tlist_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;<br>\t\tclient = list_entry(item, <span class=\"hljs-keyword\">struct</span> i2c_client, <span class=\"hljs-built_in\">list</span>);<br> <br>\t\t<span class=\"hljs-keyword\">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;<br> <br>\t\t&#125;<br>\t&#125;<br>\t...<br>\tdevice_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);<br>\tdevice_unregister(&amp;adap-&gt;dev);<br> <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">platform_driver</span> <span class=\"hljs-title\">davinci_i2c_driver</span> =</span> &#123;<br>\t.probe\t\t= davinci_i2c_probe,<br>\t.remove\t\t= davinci_i2c_remove,<br>\t.driver\t\t= &#123;<br>\t\t.name\t= <span class=\"hljs-string\">&quot;i2c_davinci&quot;</span>,<br>\t\t.owner\t= THIS_MODULE,<br>\t&#125;,<br>&#125;;<br> <br><span class=\"hljs-comment\">/* I2C may be needed to bring up other drivers */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">davinci_i2c_init_driver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> platform_driver_register(&amp;davinci_i2c_driver);<br>&#125;<br>subsys_initcall(davinci_i2c_init_driver);<br> <br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">davinci_i2c_exit_driver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tplatform_driver_unregister(&amp;davinci_i2c_driver);<br>&#125;<br>module_exit(davinci_i2c_exit_driver);<br></code></pre></td></tr></table></figure>\n\n<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_algorithm</span> <span class=\"hljs-title\">i2c_davinci_algo</span> =</span> &#123;<br>\t.master_xfer\t= i2c_davinci_xfer,<br>\t.functionality\t= i2c_davinci_func,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">adap-&gt;algo = &amp;i2c_davinci_algo;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"梳理图\"><a href=\"#梳理图\" class=\"headerlink\" title=\"梳理图\"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>\n<p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png\"></p>\n<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>\n<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>\n<h4 id=\"ov2715设备i2c驱动源码分析\"><a href=\"#ov2715设备i2c驱动源码分析\" class=\"headerlink\" title=\"ov2715设备i2c驱动源码分析\"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> &#123;</span><br><br>  <span class=\"hljs-type\">int</span> devAddr;<br><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> <span class=\"hljs-title\">client</span>;</span>   <span class=\"hljs-comment\">//!&lt; Data structure containing general access routines.</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> <span class=\"hljs-title\">driver</span>;</span>   <span class=\"hljs-comment\">//!&lt; Data structure containing information specific to each client.</span><br><br>  <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<br>  <span class=\"hljs-type\">int</span> nameSize;<br>  <span class=\"hljs-type\">int</span> users;<br><br>&#125; I2C_Obj;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> &#123;</span><br> <br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">cdev</span> <span class=\"hljs-title\">cdev</span>;</span>             <span class=\"hljs-comment\">/* Char device structure    */</span><br>  <span class=\"hljs-type\">int</span>     major;<br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">semaphore</span> <span class=\"hljs-title\">semLock</span>;</span><br>    <br>  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];<br> <br>  <span class=\"hljs-type\">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class=\"hljs-type\">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];<br>  <span class=\"hljs-type\">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class=\"hljs-number\">4</span>];<br>  <br>&#125; I2C_Dev;<br></code></pre></td></tr></table></figure>\n\n<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_devInit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>  <span class=\"hljs-type\">int</span>     result, i;<br>  <span class=\"hljs-type\">dev_t</span>   dev = <span class=\"hljs-number\">0</span>;<br> <br>  result = alloc_chrdev_region(&amp;dev, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, I2C_DRV_NAME);<span class=\"hljs-comment\">//分配字符设备空间</span><br>  <br>  <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)<br>  &#123;<br>    gI2C_dev.pObj[i]=<span class=\"hljs-literal\">NULL</span>;<br>  &#125;<br> <br>  gI2C_dev.major = MAJOR(dev);<span class=\"hljs-comment\">//保存设备主编号</span><br>  sema_init(&amp;gI2C_dev.semLock, <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//信号量初始化</span><br>  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class=\"hljs-comment\">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span><br>  gI2C_dev.cdev.owner = THIS_MODULE;<span class=\"hljs-comment\">//常规赋值</span><br> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class=\"hljs-comment\">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span><br>gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">file_operations</span> <span class=\"hljs-title\">gI2C_devFileOps</span> =</span> &#123;<br>  .owner = THIS_MODULE,<br>  .open = I2C_devOpen,<br>  .release = I2C_devRelease,<br>  .ioctl = I2C_devIoctl,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_devIoctl</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> inode *inode, <span class=\"hljs-keyword\">struct</span> file *filp, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> cmd, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg)</span><br>&#123;<br>  I2C_Obj *pObj;<br>  <span class=\"hljs-type\">int</span> status=<span class=\"hljs-number\">0</span>;<br>  I2C_TransferPrm transferPrm;<br>  <br>  pObj = (I2C_Obj *)filp-&gt;private_data;<br> <br>  <span class=\"hljs-keyword\">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>  cmd = I2C_IOCTL_CMD_GET(cmd);<span class=\"hljs-comment\">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span><br> <br>  down_interruptible(&amp;gI2C_dev.semLock);      <span class=\"hljs-comment\">//信号量down</span><br>  <br>  <span class=\"hljs-keyword\">switch</span>(cmd)<br>  &#123;<br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_SET_DEV_ADDR:<span class=\"hljs-comment\">//命令1，设置设备地址</span><br>      filp-&gt;private_data = I2C_create(arg);<br> <br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_WRITE:  <span class=\"hljs-comment\">//命令2，写寄存器值</span><br>      <br>      status = copy_from_user(&amp;transferPrm, (<span class=\"hljs-type\">void</span> *)arg, <span class=\"hljs-keyword\">sizeof</span>(transferPrm));<br>      ...<br>            <br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> I2C_CMD_READ:  <span class=\"hljs-comment\">//命令3，读寄存器值</span><br>    <br>      status = copy_from_user(&amp;transferPrm, (<span class=\"hljs-type\">void</span> *)arg, <span class=\"hljs-keyword\">sizeof</span>(transferPrm));<br>      ...<br>      <br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">default</span>:<br>      status = <span class=\"hljs-number\">-1</span>;<br>      <span class=\"hljs-keyword\">break</span>;    <br>  &#125;<br> <br>  up(&amp;gI2C_dev.semLock);      <span class=\"hljs-comment\">//信号量up</span><br> <br>  <span class=\"hljs-keyword\">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">I2C_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> devAddr)</span> &#123;<br> <br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_driver</span> *<span class=\"hljs-title\">driver</span>;</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span> =</span> client;<br>    I2C_Obj *pObj;<br> <br>    devAddr &gt;&gt;= <span class=\"hljs-number\">1</span>;<br>    <br>    <span class=\"hljs-keyword\">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class=\"hljs-comment\">//变量合法性判断</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>   <br>    <span class=\"hljs-keyword\">if</span>(gI2C_dev.pObj[devAddr]!=<span class=\"hljs-literal\">NULL</span>) &#123;\t<span class=\"hljs-comment\">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span><br>      <span class=\"hljs-comment\">// already allocated, increment user count, and return the allocated handle</span><br>      gI2C_dev.pObj[devAddr]-&gt;users++;<br>      <span class=\"hljs-keyword\">return</span> gI2C_dev.pObj[devAddr];<br>    &#125;<br>    <br>    pObj = (<span class=\"hljs-type\">void</span>*)kmalloc( <span class=\"hljs-keyword\">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class=\"hljs-comment\">//为pObj分配空间</span><br>    gI2C_dev.pObj[devAddr] = pObj;  <span class=\"hljs-comment\">//将分配的空间地址保存在全局变量里</span><br>    <span class=\"hljs-built_in\">memset</span>(pObj, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(I2C_Obj));<br>  <br>    pObj-&gt;client.adapter = <span class=\"hljs-literal\">NULL</span>;<br>    pObj-&gt;users++;    <span class=\"hljs-comment\">//用户基数，初始化为0，当前设为1</span><br>    pObj-&gt;devAddr = devAddr;  <span class=\"hljs-comment\">//保存设备地址</span><br>    <br>    gI2C_curAddr = pObj-&gt;devAddr;  <span class=\"hljs-comment\">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span><br>    driver = &amp;pObj-&gt;driver;  <span class=\"hljs-comment\">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span><br> <br>    pObj-&gt;nameSize=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span><br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;I&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;2&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;C&#x27;</span>;<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;_&#x27;</span>;   <br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"hljs-number\">0</span>) &amp; <span class=\"hljs-number\">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-string\">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"hljs-number\">4</span>) &amp; <span class=\"hljs-number\">0xF</span>);<br>    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"hljs-number\">0</span>;<br> <br>    driver-&gt;driver.name = pObj-&gt;name; <span class=\"hljs-comment\">//保存刚才设置的name</span><br>    driver-&gt;id = I2C_DRIVERID_MISC;<br>    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class=\"hljs-comment\">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span><br>    driver-&gt;detach_client = I2C_detachClient;\t<span class=\"hljs-comment\">//这个很重，在后面分析</span><br> <br>    <span class=\"hljs-keyword\">if</span>((ret = i2c_add_driver(driver)))\t<span class=\"hljs-comment\">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span><br>    &#123;<br>        printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n&quot;</span>, pObj-&gt;devAddr);<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span>(ret&lt;<span class=\"hljs-number\">0</span>) &#123;<br> <br>      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class=\"hljs-literal\">NULL</span>;<br>      kfree(pObj);    <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_write</span><span class=\"hljs-params\">(I2C_Obj *pObj, <span class=\"hljs-type\">uint8_t</span> *reg, <span class=\"hljs-type\">uint8_t</span> *buffer, <span class=\"hljs-type\">uint8_t</span> count, <span class=\"hljs-type\">uint8_t</span> dataSize)</span><br>&#123;<br>  <span class=\"hljs-type\">uint8_t</span> i;<br>  <span class=\"hljs-type\">int</span> err;<br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span>;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_msg</span> <span class=\"hljs-title\">msg</span>[1];</span><br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> data[<span class=\"hljs-number\">8</span>];<br> <br>  <span class=\"hljs-keyword\">if</span>(pObj==<span class=\"hljs-literal\">NULL</span>)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV;<br> <br>  client = &amp;pObj-&gt;client;<span class=\"hljs-comment\">//得到client信息</span><br>  <span class=\"hljs-keyword\">if</span>(!client-&gt;adapter)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV;  <br>  <br>  <span class=\"hljs-keyword\">if</span>(dataSize&lt;=<span class=\"hljs-number\">0</span>||dataSize&gt;<span class=\"hljs-number\">4</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <br>  <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>; i&lt;count; i++) &#123;<br>  <br>    msg-&gt;addr = client-&gt;addr;<span class=\"hljs-comment\">//设置要写的i2c设备地址</span><br>    msg-&gt;flags= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//一直为0</span><br>    msg-&gt;buf  = data;<span class=\"hljs-comment\">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span><br>\t\t<br>    data[<span class=\"hljs-number\">0</span>] = reg[i];<span class=\"hljs-comment\">//寄存器地址赋值</span><br>\t\t<br>    <span class=\"hljs-keyword\">if</span>(dataSize==<span class=\"hljs-number\">1</span>) &#123;<span class=\"hljs-comment\">//寄存器值长度为1</span><br>       data[<span class=\"hljs-number\">1</span>]  = buffer[i];<span class=\"hljs-comment\">//寄存器值赋值</span><br>       msg-&gt;len = <span class=\"hljs-number\">2</span>;  \t<span class=\"hljs-comment\">//设置data长度为2\t</span><br>    &#125;\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dataSize==<span class=\"hljs-number\">2</span>) &#123;<span class=\"hljs-comment\">//寄存器值长度为2</span><br>       data[<span class=\"hljs-number\">1</span>] = buffer[<span class=\"hljs-number\">2</span>*i+<span class=\"hljs-number\">1</span>];<br>       data[<span class=\"hljs-number\">2</span>] = buffer[<span class=\"hljs-number\">2</span>*i];<br>       msg-&gt;len = <span class=\"hljs-number\">3</span>;<br>    &#125; <br>    err = i2c_transfer(client-&gt;adapter, msg, <span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//调用i2c-core中的i2c_transfer发送i2c数据</span><br>    <span class=\"hljs-keyword\">if</span>( err &lt; <span class=\"hljs-number\">0</span> )<br>      <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">driver-&gt;driver.name = pObj-&gt;name;<br>driver-&gt;id = I2C_DRIVERID_MISC;<br>driver-&gt;attach_adapter = I2C_attachAdapter;<br>driver-&gt;detach_client = I2C_detachClient;<br></code></pre></td></tr></table></figure>\n<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Notifies the driver that a new bus has appeared. This routine</span><br><span class=\"hljs-comment\"> * can be used by the driver to test if the bus meets its conditions</span><br><span class=\"hljs-comment\"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span><br><span class=\"hljs-comment\"> * registers the client(s) that are on the bus to the i2c admin. via</span><br><span class=\"hljs-comment\"> * i2c_attach_client.</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_attachAdapter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adapter)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> I2C_detectClient(adapter, gI2C_curAddr);<br>&#125;<br> <br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_detectClient</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_adapter *adapter, <span class=\"hljs-type\">int</span> address)</span><br>&#123;<br>    I2C_Obj *pObj;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">i2c_client</span> *<span class=\"hljs-title\">client</span>;</span><br>    <span class=\"hljs-type\">int</span> err = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;<br>      printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Invalid device address %x\\n&quot;</span>, address);        <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>      <br>    pObj = gI2C_dev.pObj[address];<br>    <span class=\"hljs-keyword\">if</span>(pObj==<span class=\"hljs-literal\">NULL</span>) &#123;<br>      printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Object not found for address %x\\n&quot;</span>, address);    <br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br> <br>    client = &amp;pObj-&gt;client;<br> <br>    <span class=\"hljs-keyword\">if</span>(client-&gt;adapter)<br>      <span class=\"hljs-keyword\">return</span> -EBUSY;  <span class=\"hljs-comment\">/* our client is already attached */</span><br> <br>    <span class=\"hljs-built_in\">memset</span>(client, <span class=\"hljs-number\">0x00</span>, <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> i2c_client));<br>    client-&gt;addr = pObj-&gt;devAddr;<br>    client-&gt;adapter = adapter;<br>    client-&gt;driver = &amp;pObj-&gt;driver;<br> <br>    <span class=\"hljs-keyword\">if</span>((err = i2c_attach_client(client)))<br>    &#123;<br>        printk( KERN_ERR <span class=\"hljs-string\">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);<br>        client-&gt;adapter = <span class=\"hljs-literal\">NULL</span>;<br>        <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* tells the driver that a client is about to be deleted &amp; gives it </span><br><span class=\"hljs-comment\"> * the chance to remove its private data. Also, if the client struct</span><br><span class=\"hljs-comment\"> * has been dynamically allocated by the driver in the function above,</span><br><span class=\"hljs-comment\"> * it must be freed here.</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">I2C_detachClient</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> i2c_client *client)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> err;<br><span class=\"hljs-keyword\">if</span>(!client-&gt;adapter)<br>    <span class=\"hljs-keyword\">return</span> -ENODEV; <span class=\"hljs-comment\">/* our client isn&#x27;t attached */</span><br> <br><span class=\"hljs-keyword\">if</span>((err = i2c_detach_client(client))) &#123;<br>    printk( KERN_ERR <span class=\"hljs-string\">&quot;Client deregistration failed (address=%x), client not detached.\\n&quot;</span>, client-&gt;addr);<br>    <span class=\"hljs-keyword\">return</span> err;<br>&#125;<br> <br>client-&gt;adapter = <span class=\"hljs-literal\">NULL</span>;<br> <br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>}</p>\n<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>\n"},{"title":"头脑特工队观赏报告(重要)","date":"2023-09-29T11:24:05.000Z","Index_img":"https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png","typora-root-url":"./..","_content":"\n\n\n被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。\n\n![](/imgs/头脑特工队/rilay2.png)\n\n我打了好多好多字啊，\n\n可我都删了。\n\n我想说很多话，有时候都说不出来。\n\n就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。\n\n内心的复杂，是多么纤细而又值得赞颂的。\n\n”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。\n\n![](/imgs/头脑特工队/rilay1.png)\n\nRilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。\n\n我以为我会一直这样，直到我兜兜转转。\n\n遇到你的时候，\n\n我发现我好想跟你玩啊？\n\n我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？\n\n你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。\n\n哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，\n\n原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。\n\n那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。\n\n谢谢你，lyh，带给我这么多完整的情绪。\n\n\n\n搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。\n\n头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。\n\n![](/imgs/心情记录/心情4.png)\n\n\n\n最近总做梦\n\n做了一个很短的梦\t\n\n梦到我在公司加班\n\n上电梯的时候电梯在四楼坏了一直往下坠\n\n电梯里就我一个人\n\n我重重的跟电梯一起坠到了一楼\n\n头顶的钢板把我砸晕了\n\n昏迷了好久好久\n\n公司给紧急联系人打电话\n\n我的紧急联系人是已经去世的外婆\n\n找不到紧急联系人\n\n不知怎么的，爸爸妈妈还是得到了这个消息，火急火燎的坐飞机来深圳\n\n结果在飞机上出了意外\n\n我昏迷后 醒来了\n\n啥也不记得\n\n我看到你在病床旁边陪着我高兴坏了\n\n我跟你讲：“我做了个梦，梦到自己在公司出了意外电梯坠毁了，父母也在赶来的路上去世了。”\n\n“还好是个梦，这个梦还挺好，我们俩在一个城市工作，25岁还有父母，多想一直活着梦里。”\n\n“昨天我以为我肺炎要去世了，怎么也想不起来漪怎么写。我怎么也写不出来，好难过啊，明天我们是不是要结婚了。”\n\n你跟我说：“你明天要跟我结婚，肺炎去世才是个梦。”\n\n“你现在就是才25岁被电梯砸伤了，我就来看看你而已。还有就是你现在25岁也没有父母了，他们来深圳的飞机上出意外了😶”\n","source":"_posts/头脑特工队观赏报告-重要.md","raw":"---\ntitle: 头脑特工队观赏报告(重要)\ndate: 2023-09-29 19:24:05\nIndex_img: https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png\ntags:\n  - MetLee\ntypora-root-url: ./..\n---\n\n\n\n被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。\n\n![](/imgs/头脑特工队/rilay2.png)\n\n我打了好多好多字啊，\n\n可我都删了。\n\n我想说很多话，有时候都说不出来。\n\n就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。\n\n内心的复杂，是多么纤细而又值得赞颂的。\n\n”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。\n\n![](/imgs/头脑特工队/rilay1.png)\n\nRilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。\n\n我以为我会一直这样，直到我兜兜转转。\n\n遇到你的时候，\n\n我发现我好想跟你玩啊？\n\n我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？\n\n你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。\n\n哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，\n\n原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。\n\n那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。\n\n谢谢你，lyh，带给我这么多完整的情绪。\n\n\n\n搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。\n\n头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。\n\n![](/imgs/心情记录/心情4.png)\n\n\n\n最近总做梦\n\n做了一个很短的梦\t\n\n梦到我在公司加班\n\n上电梯的时候电梯在四楼坏了一直往下坠\n\n电梯里就我一个人\n\n我重重的跟电梯一起坠到了一楼\n\n头顶的钢板把我砸晕了\n\n昏迷了好久好久\n\n公司给紧急联系人打电话\n\n我的紧急联系人是已经去世的外婆\n\n找不到紧急联系人\n\n不知怎么的，爸爸妈妈还是得到了这个消息，火急火燎的坐飞机来深圳\n\n结果在飞机上出了意外\n\n我昏迷后 醒来了\n\n啥也不记得\n\n我看到你在病床旁边陪着我高兴坏了\n\n我跟你讲：“我做了个梦，梦到自己在公司出了意外电梯坠毁了，父母也在赶来的路上去世了。”\n\n“还好是个梦，这个梦还挺好，我们俩在一个城市工作，25岁还有父母，多想一直活着梦里。”\n\n“昨天我以为我肺炎要去世了，怎么也想不起来漪怎么写。我怎么也写不出来，好难过啊，明天我们是不是要结婚了。”\n\n你跟我说：“你明天要跟我结婚，肺炎去世才是个梦。”\n\n“你现在就是才25岁被电梯砸伤了，我就来看看你而已。还有就是你现在25岁也没有父母了，他们来深圳的飞机上出意外了😶”\n","slug":"头脑特工队观赏报告-重要","published":1,"updated":"2023-10-01T03:14:49.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sg0002lcwfch4h0p3t","content":"<p>被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay2.png\"></p>\n<p>我打了好多好多字啊，</p>\n<p>可我都删了。</p>\n<p>我想说很多话，有时候都说不出来。</p>\n<p>就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。</p>\n<p>内心的复杂，是多么纤细而又值得赞颂的。</p>\n<p>”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png\"></p>\n<p>Rilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。</p>\n<p>我以为我会一直这样，直到我兜兜转转。</p>\n<p>遇到你的时候，</p>\n<p>我发现我好想跟你玩啊？</p>\n<p>我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？</p>\n<p>你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。</p>\n<p>哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，</p>\n<p>原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。</p>\n<p>那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。</p>\n<p>谢谢你，lyh，带给我这么多完整的情绪。</p>\n<p>搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。</p>\n<p>头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。</p>\n<p><img src=\"/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%854.png\"></p>\n<p>最近总做梦</p>\n<p>做了一个很短的梦\t</p>\n<p>梦到我在公司加班</p>\n<p>上电梯的时候电梯在四楼坏了一直往下坠</p>\n<p>电梯里就我一个人</p>\n<p>我重重的跟电梯一起坠到了一楼</p>\n<p>头顶的钢板把我砸晕了</p>\n<p>昏迷了好久好久</p>\n<p>公司给紧急联系人打电话</p>\n<p>我的紧急联系人是已经去世的外婆</p>\n<p>找不到紧急联系人</p>\n<p>不知怎么的，爸爸妈妈还是得到了这个消息，火急火燎的坐飞机来深圳</p>\n<p>结果在飞机上出了意外</p>\n<p>我昏迷后 醒来了</p>\n<p>啥也不记得</p>\n<p>我看到你在病床旁边陪着我高兴坏了</p>\n<p>我跟你讲：“我做了个梦，梦到自己在公司出了意外电梯坠毁了，父母也在赶来的路上去世了。”</p>\n<p>“还好是个梦，这个梦还挺好，我们俩在一个城市工作，25岁还有父母，多想一直活着梦里。”</p>\n<p>“昨天我以为我肺炎要去世了，怎么也想不起来漪怎么写。我怎么也写不出来，好难过啊，明天我们是不是要结婚了。”</p>\n<p>你跟我说：“你明天要跟我结婚，肺炎去世才是个梦。”</p>\n<p>“你现在就是才25岁被电梯砸伤了，我就来看看你而已。还有就是你现在25岁也没有父母了，他们来深圳的飞机上出意外了😶”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay2.png\"></p>\n<p>我打了好多好多字啊，</p>\n<p>可我都删了。</p>\n<p>我想说很多话，有时候都说不出来。</p>\n<p>就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。</p>\n<p>内心的复杂，是多么纤细而又值得赞颂的。</p>\n<p>”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png\"></p>\n<p>Rilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。</p>\n<p>我以为我会一直这样，直到我兜兜转转。</p>\n<p>遇到你的时候，</p>\n<p>我发现我好想跟你玩啊？</p>\n<p>我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？</p>\n<p>你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。</p>\n<p>哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，</p>\n<p>原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。</p>\n<p>那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。</p>\n<p>谢谢你，lyh，带给我这么多完整的情绪。</p>\n<p>搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。</p>\n<p>头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。</p>\n<p><img src=\"/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%854.png\"></p>\n<p>最近总做梦</p>\n<p>做了一个很短的梦\t</p>\n<p>梦到我在公司加班</p>\n<p>上电梯的时候电梯在四楼坏了一直往下坠</p>\n<p>电梯里就我一个人</p>\n<p>我重重的跟电梯一起坠到了一楼</p>\n<p>头顶的钢板把我砸晕了</p>\n<p>昏迷了好久好久</p>\n<p>公司给紧急联系人打电话</p>\n<p>我的紧急联系人是已经去世的外婆</p>\n<p>找不到紧急联系人</p>\n<p>不知怎么的，爸爸妈妈还是得到了这个消息，火急火燎的坐飞机来深圳</p>\n<p>结果在飞机上出了意外</p>\n<p>我昏迷后 醒来了</p>\n<p>啥也不记得</p>\n<p>我看到你在病床旁边陪着我高兴坏了</p>\n<p>我跟你讲：“我做了个梦，梦到自己在公司出了意外电梯坠毁了，父母也在赶来的路上去世了。”</p>\n<p>“还好是个梦，这个梦还挺好，我们俩在一个城市工作，25岁还有父母，多想一直活着梦里。”</p>\n<p>“昨天我以为我肺炎要去世了，怎么也想不起来漪怎么写。我怎么也写不出来，好难过啊，明天我们是不是要结婚了。”</p>\n<p>你跟我说：“你明天要跟我结婚，肺炎去世才是个梦。”</p>\n<p>“你现在就是才25岁被电梯砸伤了，我就来看看你而已。还有就是你现在25岁也没有父母了，他们来深圳的飞机上出意外了😶”</p>\n"},{"title":"字符设备驱动","date":"2023-10-01T01:20:25.000Z","typora-root-url":"./..","_content":"\n<img src=\"/yzb/北京云.jpg\" style=\"zoom:80%;\" />\n\n你根本照顾不好自己，只有我才行。你电动牙刷每天一周了，我好久没去，再次去的时候还是没电，我如果不充，你要手动多久呐？\n","source":"_posts/字符设备驱动.md","raw":"---\ntitle: 字符设备驱动\ndate: 2023-10-01 09:20:25\ntags:\t\n  - Linux Kernel Driver\ntypora-root-url: ./..\n---\n\n<img src=\"/yzb/北京云.jpg\" style=\"zoom:80%;\" />\n\n你根本照顾不好自己，只有我才行。你电动牙刷每天一周了，我好久没去，再次去的时候还是没电，我如果不充，你要手动多久呐？\n","slug":"字符设备驱动","published":1,"updated":"2023-10-01T01:22:48.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sj0005lcwfcc84g0qq","content":"<img src=\"/yzb/北京云.jpg\" style=\"zoom:80%;\" />\n\n<p>你根本照顾不好自己，只有我才行。你电动牙刷每天一周了，我好久没去，再次去的时候还是没电，我如果不充，你要手动多久呐？</p>\n","site":{"data":{}},"excerpt":"","more":"<img src=\"/yzb/北京云.jpg\" style=\"zoom:80%;\" />\n\n<p>你根本照顾不好自己，只有我才行。你电动牙刷每天一周了，我好久没去，再次去的时候还是没电，我如果不充，你要手动多久呐？</p>\n"},{"title":"MissingLi","date":"2023-09-30T08:43:59.000Z","index_img":"https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BD%A9%E8%99%B9.jpg","typora-root-url":"./..","_content":"\n![](/imgs/心情记录/彩虹.jpg)\n\n今天学校里出现了两个彩虹，含娃。\n\n我根本舍不得不找你，我根本舍不得不理你。\n\n我根本不敢找你，我好想你！\n\n我根本不敢找你说那么多次我爱你！你能猜到我会把话都写到这吧？\n\n看到你发消息，我来回的看，不敢点进去，我怕忍不住跟你说一大堆。\n\n好好玩吧！我可以再等等的！\n\n<img src=\"/imgs/心情记录/心情2.png\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情1.png\" alt=\"..\\imgs\\心情1\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情5.jpg\" style=\"zoom:33%;\" />\n\n我有好多话要说啊!我好想你啊!\n\n我知道我要等下去,\n\n上一次,我等了三十年呢\n\n很多次的感受跟现在一样.\n\n我们以后一定会是一家人.\n\n---------------------------------------------------2023-10-1---------------------------------\n我已经接受自己的情绪了奥，我接受自己很喜欢你件事，已经很厉害了！！！！\n\n现在看来，\n\n我的人生有三个遗憾：\n\n不会开车，没法载着你去各种你想去的地方。\n\n学历太低，后悔没去个自己尽力才能去到的学校。\n\n为什么不能早点遇到你，我好想在人生的前25年就能好好保护你啊。\n\n还好我还有60年可以弥补，即使不能娶你回家，也要把你当作我的好大儿，一直努力走下去吧！\n\n今天力竭了，跑了30公里，我知道一直爱你下去是一件很难的事，可是我的这一生好像只有你一个家人了呀，我要试试自己有多大的决心，看来我还是赢了，30公里只要我还有意志就可以做到，爱你也是！！！我的含娃啊！我才不要回报，我就要一直陪着你！\n","source":"_posts/MissingLi.md","raw":"---\ntitle: MissingLi\ndate: 2023-09-30 16:43:59\nindex_img: https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BD%A9%E8%99%B9.jpg\ntags: \n  - MetLee\ntypora-root-url: ./..\n---\n\n![](/imgs/心情记录/彩虹.jpg)\n\n今天学校里出现了两个彩虹，含娃。\n\n我根本舍不得不找你，我根本舍不得不理你。\n\n我根本不敢找你，我好想你！\n\n我根本不敢找你说那么多次我爱你！你能猜到我会把话都写到这吧？\n\n看到你发消息，我来回的看，不敢点进去，我怕忍不住跟你说一大堆。\n\n好好玩吧！我可以再等等的！\n\n<img src=\"/imgs/心情记录/心情2.png\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情1.png\" alt=\"..\\imgs\\心情1\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情5.jpg\" style=\"zoom:33%;\" />\n\n我有好多话要说啊!我好想你啊!\n\n我知道我要等下去,\n\n上一次,我等了三十年呢\n\n很多次的感受跟现在一样.\n\n我们以后一定会是一家人.\n\n---------------------------------------------------2023-10-1---------------------------------\n我已经接受自己的情绪了奥，我接受自己很喜欢你件事，已经很厉害了！！！！\n\n现在看来，\n\n我的人生有三个遗憾：\n\n不会开车，没法载着你去各种你想去的地方。\n\n学历太低，后悔没去个自己尽力才能去到的学校。\n\n为什么不能早点遇到你，我好想在人生的前25年就能好好保护你啊。\n\n还好我还有60年可以弥补，即使不能娶你回家，也要把你当作我的好大儿，一直努力走下去吧！\n\n今天力竭了，跑了30公里，我知道一直爱你下去是一件很难的事，可是我的这一生好像只有你一个家人了呀，我要试试自己有多大的决心，看来我还是赢了，30公里只要我还有意志就可以做到，爱你也是！！！我的含娃啊！我才不要回报，我就要一直陪着你！\n","slug":"MissingLi","published":1,"updated":"2023-10-01T14:23:53.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sk0006lcwf93kb7c1t","content":"<p><img src=\"/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BD%A9%E8%99%B9.jpg\"></p>\n<p>今天学校里出现了两个彩虹，含娃。</p>\n<p>我根本舍不得不找你，我根本舍不得不理你。</p>\n<p>我根本不敢找你，我好想你！</p>\n<p>我根本不敢找你说那么多次我爱你！你能猜到我会把话都写到这吧？</p>\n<p>看到你发消息，我来回的看，不敢点进去，我怕忍不住跟你说一大堆。</p>\n<p>好好玩吧！我可以再等等的！</p>\n<img src=\"/imgs/心情记录/心情2.png\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情1.png\" alt=\"..\\imgs\\心情1\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情5.jpg\" style=\"zoom:33%;\" />\n\n<p>我有好多话要说啊!我好想你啊!</p>\n<p>我知道我要等下去,</p>\n<p>上一次,我等了三十年呢</p>\n<p>很多次的感受跟现在一样.</p>\n<p>我们以后一定会是一家人.</p>\n<p>—————————————————2023-10-1———————————<br>我已经接受自己的情绪了奥，我接受自己很喜欢你件事，已经很厉害了！！！！</p>\n<p>现在看来，</p>\n<p>我的人生有三个遗憾：</p>\n<p>不会开车，没法载着你去各种你想去的地方。</p>\n<p>学历太低，后悔没去个自己尽力才能去到的学校。</p>\n<p>为什么不能早点遇到你，我好想在人生的前25年就能好好保护你啊。</p>\n<p>还好我还有60年可以弥补，即使不能娶你回家，也要把你当作我的好大儿，一直努力走下去吧！</p>\n<p>今天力竭了，跑了30公里，我知道一直爱你下去是一件很难的事，可是我的这一生好像只有你一个家人了呀，我要试试自己有多大的决心，看来我还是赢了，30公里只要我还有意志就可以做到，爱你也是！！！我的含娃啊！我才不要回报，我就要一直陪着你！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BD%A9%E8%99%B9.jpg\"></p>\n<p>今天学校里出现了两个彩虹，含娃。</p>\n<p>我根本舍不得不找你，我根本舍不得不理你。</p>\n<p>我根本不敢找你，我好想你！</p>\n<p>我根本不敢找你说那么多次我爱你！你能猜到我会把话都写到这吧？</p>\n<p>看到你发消息，我来回的看，不敢点进去，我怕忍不住跟你说一大堆。</p>\n<p>好好玩吧！我可以再等等的！</p>\n<img src=\"/imgs/心情记录/心情2.png\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情1.png\" alt=\"..\\imgs\\心情1\" style=\"zoom:33%;\" />\n\n<img src=\"/imgs/心情记录/心情5.jpg\" style=\"zoom:33%;\" />\n\n<p>我有好多话要说啊!我好想你啊!</p>\n<p>我知道我要等下去,</p>\n<p>上一次,我等了三十年呢</p>\n<p>很多次的感受跟现在一样.</p>\n<p>我们以后一定会是一家人.</p>\n<p>—————————————————2023-10-1———————————<br>我已经接受自己的情绪了奥，我接受自己很喜欢你件事，已经很厉害了！！！！</p>\n<p>现在看来，</p>\n<p>我的人生有三个遗憾：</p>\n<p>不会开车，没法载着你去各种你想去的地方。</p>\n<p>学历太低，后悔没去个自己尽力才能去到的学校。</p>\n<p>为什么不能早点遇到你，我好想在人生的前25年就能好好保护你啊。</p>\n<p>还好我还有60年可以弥补，即使不能娶你回家，也要把你当作我的好大儿，一直努力走下去吧！</p>\n<p>今天力竭了，跑了30公里，我知道一直爱你下去是一件很难的事，可是我的这一生好像只有你一个家人了呀，我要试试自己有多大的决心，看来我还是赢了，30公里只要我还有意志就可以做到，爱你也是！！！我的含娃啊！我才不要回报，我就要一直陪着你！</p>\n"},{"title":"广东注意事项","date":"2023-09-30T16:18:59.000Z","typora-root-url":"./..","_content":"\n点餐后问告诉服务员不要生姜，葱，胡椒。\n\n卜卜贝\n\n~~小龙虾~~\n\n夜市\n\n深圳沙滩\n\n摩天轮\n\n木屋烧烤\n\n~~榴莲椰子鸡~~\n\n日料\n\n~~寿司~~\n\n~~西塔老太太烤肉~~\n\n~~铜锣烧~~\n\n~~螺蛳粉火锅~~\n\n哈根达斯巧克力\n\n冰淇凌巧克力火锅\n\n~~jellycat~~\n\n~~酱香拿铁~~\n\n爆炸头企鹅\n\n~~pigu~~\n\n小海豹没有冲浪板\n\n~~接含娃之前买jelly cat~~\n\n甜甜圈 花生 海星 云朵 茄子\n\n海南海边\n\n威海海边\n\n青岛海边\n\n潮汕\n\n牛腩煲\n\n笨的很，还有这么多未完成！\n\n睡醒了突然想到你的膝盖，以前受过伤，是不是年纪大了会不舒服。什么都记不得吃，维生素买了也忘了吃，自己不舒服的地方也不关心。\n\n想买些骨胶原，发现根本也没有用😶为什么会这么喜欢一个人呢？好奇怪，搞不懂。\n\n桔钓沙\n\n<img src=\"/imgs/广东计划/金钓沙露营计划.jpg\" style=\"zoom:33%;\" />\n\n![](/imgs/广东计划/桔钓沙.jpg)\n\n露营计划要到十月21号22号，含娃参加完婚礼回来。这几天去人太多，体验很差（2023-10-2）\n\n第二个计划是不露营，住海边的酒店，晚上可以看海。计划2023年十月二十一号。\n\n![](/imgs/广东计划/桔钓沙2.jpg)\n\n鹿嘴山庄\n\n![](/imgs/广东计划/鹿嘴山庄1.jpg)\n\n![](/imgs/广东计划/鹿嘴山庄2.jpg)\n\n鹿嘴山庄很晒，要去要到十一月份再带lyh去。\n","source":"_posts/广东注意事项.md","raw":"---\ntitle: 广东注意事项\ndate: 2023-10-01 00:18:59\ntags: \n  - 生活注意事项\ntypora-root-url: ./..\n---\n\n点餐后问告诉服务员不要生姜，葱，胡椒。\n\n卜卜贝\n\n~~小龙虾~~\n\n夜市\n\n深圳沙滩\n\n摩天轮\n\n木屋烧烤\n\n~~榴莲椰子鸡~~\n\n日料\n\n~~寿司~~\n\n~~西塔老太太烤肉~~\n\n~~铜锣烧~~\n\n~~螺蛳粉火锅~~\n\n哈根达斯巧克力\n\n冰淇凌巧克力火锅\n\n~~jellycat~~\n\n~~酱香拿铁~~\n\n爆炸头企鹅\n\n~~pigu~~\n\n小海豹没有冲浪板\n\n~~接含娃之前买jelly cat~~\n\n甜甜圈 花生 海星 云朵 茄子\n\n海南海边\n\n威海海边\n\n青岛海边\n\n潮汕\n\n牛腩煲\n\n笨的很，还有这么多未完成！\n\n睡醒了突然想到你的膝盖，以前受过伤，是不是年纪大了会不舒服。什么都记不得吃，维生素买了也忘了吃，自己不舒服的地方也不关心。\n\n想买些骨胶原，发现根本也没有用😶为什么会这么喜欢一个人呢？好奇怪，搞不懂。\n\n桔钓沙\n\n<img src=\"/imgs/广东计划/金钓沙露营计划.jpg\" style=\"zoom:33%;\" />\n\n![](/imgs/广东计划/桔钓沙.jpg)\n\n露营计划要到十月21号22号，含娃参加完婚礼回来。这几天去人太多，体验很差（2023-10-2）\n\n第二个计划是不露营，住海边的酒店，晚上可以看海。计划2023年十月二十一号。\n\n![](/imgs/广东计划/桔钓沙2.jpg)\n\n鹿嘴山庄\n\n![](/imgs/广东计划/鹿嘴山庄1.jpg)\n\n![](/imgs/广东计划/鹿嘴山庄2.jpg)\n\n鹿嘴山庄很晒，要去要到十一月份再带lyh去。\n","slug":"广东注意事项","published":1,"updated":"2023-10-02T12:44:23.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sk0007lcwf017w9pu3","content":"<p>点餐后问告诉服务员不要生姜，葱，胡椒。</p>\n<p>卜卜贝</p>\n<p><del>小龙虾</del></p>\n<p>夜市</p>\n<p>深圳沙滩</p>\n<p>摩天轮</p>\n<p>木屋烧烤</p>\n<p><del>榴莲椰子鸡</del></p>\n<p>日料</p>\n<p><del>寿司</del></p>\n<p><del>西塔老太太烤肉</del></p>\n<p><del>铜锣烧</del></p>\n<p><del>螺蛳粉火锅</del></p>\n<p>哈根达斯巧克力</p>\n<p>冰淇凌巧克力火锅</p>\n<p><del>jellycat</del></p>\n<p><del>酱香拿铁</del></p>\n<p>爆炸头企鹅</p>\n<p><del>pigu</del></p>\n<p>小海豹没有冲浪板</p>\n<p><del>接含娃之前买jelly cat</del></p>\n<p>甜甜圈 花生 海星 云朵 茄子</p>\n<p>海南海边</p>\n<p>威海海边</p>\n<p>青岛海边</p>\n<p>潮汕</p>\n<p>牛腩煲</p>\n<p>笨的很，还有这么多未完成！</p>\n<p>睡醒了突然想到你的膝盖，以前受过伤，是不是年纪大了会不舒服。什么都记不得吃，维生素买了也忘了吃，自己不舒服的地方也不关心。</p>\n<p>想买些骨胶原，发现根本也没有用😶为什么会这么喜欢一个人呢？好奇怪，搞不懂。</p>\n<p>桔钓沙</p>\n<img src=\"/imgs/广东计划/金钓沙露营计划.jpg\" style=\"zoom:33%;\" />\n\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E6%A1%94%E9%92%93%E6%B2%99.jpg\"></p>\n<p>露营计划要到十月21号22号，含娃参加完婚礼回来。这几天去人太多，体验很差（2023-10-2）</p>\n<p>第二个计划是不露营，住海边的酒店，晚上可以看海。计划2023年十月二十一号。</p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E6%A1%94%E9%92%93%E6%B2%992.jpg\"></p>\n<p>鹿嘴山庄</p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E9%B9%BF%E5%98%B4%E5%B1%B1%E5%BA%841.jpg\"></p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E9%B9%BF%E5%98%B4%E5%B1%B1%E5%BA%842.jpg\"></p>\n<p>鹿嘴山庄很晒，要去要到十一月份再带lyh去。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>点餐后问告诉服务员不要生姜，葱，胡椒。</p>\n<p>卜卜贝</p>\n<p><del>小龙虾</del></p>\n<p>夜市</p>\n<p>深圳沙滩</p>\n<p>摩天轮</p>\n<p>木屋烧烤</p>\n<p><del>榴莲椰子鸡</del></p>\n<p>日料</p>\n<p><del>寿司</del></p>\n<p><del>西塔老太太烤肉</del></p>\n<p><del>铜锣烧</del></p>\n<p><del>螺蛳粉火锅</del></p>\n<p>哈根达斯巧克力</p>\n<p>冰淇凌巧克力火锅</p>\n<p><del>jellycat</del></p>\n<p><del>酱香拿铁</del></p>\n<p>爆炸头企鹅</p>\n<p><del>pigu</del></p>\n<p>小海豹没有冲浪板</p>\n<p><del>接含娃之前买jelly cat</del></p>\n<p>甜甜圈 花生 海星 云朵 茄子</p>\n<p>海南海边</p>\n<p>威海海边</p>\n<p>青岛海边</p>\n<p>潮汕</p>\n<p>牛腩煲</p>\n<p>笨的很，还有这么多未完成！</p>\n<p>睡醒了突然想到你的膝盖，以前受过伤，是不是年纪大了会不舒服。什么都记不得吃，维生素买了也忘了吃，自己不舒服的地方也不关心。</p>\n<p>想买些骨胶原，发现根本也没有用😶为什么会这么喜欢一个人呢？好奇怪，搞不懂。</p>\n<p>桔钓沙</p>\n<img src=\"/imgs/广东计划/金钓沙露营计划.jpg\" style=\"zoom:33%;\" />\n\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E6%A1%94%E9%92%93%E6%B2%99.jpg\"></p>\n<p>露营计划要到十月21号22号，含娃参加完婚礼回来。这几天去人太多，体验很差（2023-10-2）</p>\n<p>第二个计划是不露营，住海边的酒店，晚上可以看海。计划2023年十月二十一号。</p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E6%A1%94%E9%92%93%E6%B2%992.jpg\"></p>\n<p>鹿嘴山庄</p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E9%B9%BF%E5%98%B4%E5%B1%B1%E5%BA%841.jpg\"></p>\n<p><img src=\"/imgs/%E5%B9%BF%E4%B8%9C%E8%AE%A1%E5%88%92/%E9%B9%BF%E5%98%B4%E5%B1%B1%E5%BA%842.jpg\"></p>\n<p>鹿嘴山庄很晒，要去要到十一月份再带lyh去。</p>\n"},{"title":"Linux驱动-构造和运行模块个人学习总结","date":"2023-09-29T02:40:26.000Z","Index_img":"https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/yzb/%E5%B0%8F%E7%8B%97%E5%8D%B7%E5%8D%B7.jpg","typora-root-url":"./..","_content":"\n\n我发现对于学习任何一门知识，在最开始只能背诵或抄写别人的一些总结，所以tyro阶段我会抄写一些别人的文章，进行复习总结。<br>\n\n我记得小时候看过一部电影《心灵捕手》，虽然主线剧情不是我要说的，但我仍然记者记忆中有个桥段，Will在哈佛附近的酒吧遇到Skylar的时候，Will最铁的哥们查克冒充历史系学生和美女Skylar搭讪，但哈佛大学的学生克拉克看破了查克是冒牌货，于是过来考查克历史学知识，Will不止回答了这些知识，还输出了一顿自己的理解。我一直不明白，同为学生时代的我们，究竟会有什么差距呢，后来看到这一段，我才发现，只有能输出自己的东西才算是在这个领域有所了解了吧？所以tyro阶段我也只能摘抄一些别人消化的知识点，多希望我也能有一天输出自己的东西。\n\n![](/imgs/外设驱动开发/心灵捕手.webp)\n\n<small>提到《心灵捕手》我又想到:<br>\n你年轻彪悍，我如果和你谈论战争，你大可以向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友”，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。不要以为，我了解你。也许我可以通过“知识”来看你，但那不是你，除非你愿意谈谈你自己，否则我不知道你到底是谁。有时候喜欢是一种非常简单的事，我没有进入过你的世界，只听你讲过自己的故事，你人生的前25年从未参与过，我喜欢的只是我所认识的25岁的你。我不知道为什么，我真真实实的做了一场梦，很久很久的梦，我把人生的25年从头过了一遍，非常真切的感受，30年的人生所有的故事主角都是你，我才发现，我的这份喜欢似乎是贯彻了这痛苦的一生。</small>\n\n<small>ANY WAY，写这些东西的时候我的状态是非常不好的，最近这两年我失去了爱我的外婆，得了很多很重的疾病，毕业选择的第一家公司在春招结束的时候解散了，还有一个她。在这之前我的世界没有什么情绪，对生活也没有热情，感谢她给我平庸的人生带来了一些阳光。让我捡起来对生活的热爱，谢谢你，u complete me。人生太多变化，不知道还能在一起多久，我们已经是家人了吧，不要忘记我奥，死亡不是真的逝去，遗忘才是永恒的消亡。</small>\n\n# 构造和运行模块\n\n### 内核模块与应用程序的对比\n\n大多数中小规模的应用程序是从头到尾执行单个任务。**模块只是预先注册自己以便服务于将来的某个请求**，然后其初始化函数立即结束，模块的退出函数将在模块被卸载之前调用。**内核模块的编程方式和事件驱动的编程有些类似。**\n应用程序在退出时可以不管资源的释放或其他的清除工作。但**模块的退出函数必须仔细撤销初始化函数所作的一切**，否则，在系统重新引导之前某些东西就会残留在系统中。\n应用程序可以调用它并未定义的函数，因为连接过程能够解析外部引用从而使用适当的函数库。但**模块仅被链接到内核，它能调用的函数仅仅是由内核导出的那些函数，而不存在任何可链接的函数库。**\n模块源文件中不能包含通常的头文件，只能使用作为内核一部分的函数。\n应用程序开发过程中的段错误是无害的，并且总是可以使用调试器跟踪到源代码中的问题所在；内核错误即使不影响整个系统，也至少会杀死当前进程。\n\n#### 可重入\n\n可重入性作为多线程编程里面重要的概念，相信大家或多或少都听说过、研究过甚至使用过。目前很多资料都重点在介绍重入锁、CAS等概念，对“可重入性”本身的讲解不是很多，所以JavaCool给大家整理了一些“可重入性”的相关知识，希望能帮助到大家！\n\n* 可重入的定义\n简单定义:\"可以正确重复使用\"，有两个关键：1，可以重复使用；2，并能正确使用。意味着在多次执行的时候能得到正确的值，并不受其他调用的影响。\n官方定义：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\n这里也有一段比较好的英文阐释：\nA computer program or routine is described as reentrant if it can be safely called again before its previous invocation has been completed (i.e it can be safely executed concurrently)\n可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。\n\n* 产生背景\n可重入概念是在单线程操作系统的时代提出的。一个子程序的重入，可能由于自身原因，如执行了jmp或者call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX系统的signal的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。\n\n* 编写可重入代码注意的条件\n若一个函数是可重入的，则该函数应当满足下述条件：\n\n不能含有静态（全局）非常量数据。\n不能返回静态（全局）非常量数据的地址。\n只能处理由调用者提供的数据。\n不能依赖于单实例模式资源的锁。\n调用(call)的函数也必需是可重入的。\n上述条件就是要求可重入函数使用的所有变量都保存在呼叫堆叠的当前函数栈（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。\n\n多“用户/对象/进程优先级”以及多进程（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似编程中的静态、全域）资源。\n\n* 与线程安全的关系\n可重入与线程安全两个概念都关系到函数处理资源的方式。但是，他们有重大区别：可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入同步机制以保护共享的资源，使之不会被几个线程同时访问。\n\n操作系统背景与CPU调度策略：\n可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。\n\n多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的时间片，不断向前推进执行进度。可重入函数未必是线程安全的；线程安全函数未必是可重入的。\n\n例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。\n另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。fprintf函数就是线程安全但不可重入。\n* 可重入锁\n可重入锁也叫递归锁，它俩等同于一回事，指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，同一线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock 和 synchronized 就是典型的可重入锁！\n\n**操作系统的作用**是\n\n- 为应用程序提供一个对计算机硬件的一致视图\n- 负责程序的独立操作并保护资源不受非法访问。该任务只有在CPU能够保护系统软件不受应用程序破坏时才能完成。\n\n人们在CPU中实现不同的操作模式（或者级别）。不同的级别具有不同的功能，在较低的级别中将禁止某些操作。程序代码只能通过有限数目的“门” 从一个级别切换到另一级别。Unix使用了两个这样的级别：内核运行在最高级别（也称作超级用户态），可以进行所有操作；应用程序运行在最低级别（即所谓的用户态），处理器控制着对硬件的直接访问以及对内存的非授权访问。两种模式具有不同的优先权等级，每个模式都有自己的内存映射，即自己的地址空间。\n\n应用程序执行系统调用或者被硬件中断挂起时，Unix将执行模式从用户空间切换到内核空间\n\n- 执行系统调用的内核代码运行在进程上下文中，它代表用户进程执行操作，因此可以访问进程地址空间的所有数据\n- 处理硬件中断的内核代码和进程是异步的，与任何一个特定进程无关。\n\n一个驱动程序通常要执行两类任务\n\n- 某些函数作为系统调用的一部分而执行\n- 其他函数负责中断处理\n\n### 内核中的并发\n\n内核编程区别于常见应用程序编程的地方在于对并发的处理。即使是最简单的内核模块，都需要在编写时铭记：同一时刻，可能会有许多事情正在发生。\n\n##### 内核编程必须考虑并发的原因\n\n- Linux系统中通常正在运行多个并发进程，他们可能同时使用我们的驱动程序。\n\n- 大多数设备能够中断处理器，而中断处理程序异步运行，而且可能在驱动程序试图处理其他任务时被调用。\n- 一些抽象软件，例如内核定时器，也在异步运行。\n- Linux可以运行在SMP系统上，可能同时有不止一个CPU运行我们的驱动程序。\n- 在2.6中内核代码已经是可抢占的，意味着即使在单处理器系统上也存在许多类似多处理器系统的并发问题。\n\nLinux内核代码（包括驱动程序代码）必须是可重入的，它必须能够同时运行在多个上下文中。对编写正确的内核代码来说，优良的并发管理是必需的。\n\n#### 当前进程\n\n虽然内核模块不像应用程序那样顺序执行，然而内核执行的大多数操作还是和某个特定的进程相关。\n内核代码可通过访问全局项current来获得当前进程。它是一个指向struct task_struct的指针。current指针指向当前正在运行的进程。内核代码可以通过current获得与当前进程相关的信息。例如，下面的语句通过访问struct task_struct的某些成员来打印当前进程的ID和命令名：\n\n```c\nprintk(KERN_INFO \"The process is \\\" %s \\\" (pid %i)\\n\",\ncurrent->common,current->pid);\n```\n\n为了支持SMP系统，内核开发这设计了一种能找到运行在相关CPU上的当前进程的机制。它必须是快速的，因为对current的引用会很频繁。一种不依赖于特定架构的机制通常是，**将指向task_struct结构的指针隐藏在内核栈中**。\n\n## 编译和装载\n\n### 编译模块\n\n内核是一个大的、独立的程序，为了将它的各个片段放在一起，要满足很多详细而明确的要求。\n\n在构造内核模块之前，有一些先决条件首先应该得到满足\n\n- 确保具备正确版本的编译器、模块工具和其他必要的工具（Documentation/Changes文件）。注意：使用太新的工具也偶尔会导致问题。\n- 准备内核树，配置并构造内核。\n\n```c\nobj-m := hello.o\n```\n\n上面的赋值语句（它利用了GNU make的扩展语法）说明了有一个模块需要从目标文件hello.o中构造，而从该目标文件中构造的模块名称为hello.ko。\n\n如果要构造的模块名称为module.ko，并由两个源文件生成（file1.c和file2.c），那么makefile可编写如下\n\n```makefile\nobj-m := module.o\nmodule-objs := file1.o file2.o\n```\n\n为了让上面这种类型的makefile文件正常工作，**必须在大的内核构造系统环境中调用它们**。如果内核源代码树保存在~/kernel-2.6目录，则用来构造模块的make命令（在包含模块代码和makefile的目录中输入）\n\n```makefile\nmake -C ~/kernel-2.6 M=`pwd` modules\n```\n\n上述命令**首先改变目录到内核源代码目录**，该目录保存由内核的顶层makefile文件。**M=选项**让该makefile在构造modules目标之前返回到模块源代码目录。然后，**modules目标指向obj-m变量中设定的模块**。\n\n另一种makefile方法，可以使得**内核树之外的模块构造**更加容易。\n\n```makefile\n# If KERNELRELEASE is defined, we've been invoked from the\n# kernel build system and can use its language.\nifneq ($(KERNELRELEASE),)\n    hello_world-objs := main.o\n    obj-m := hello_world.o\n\n# Otherwise we were called directly from the command\n# line; invoke the kernel build system.\nelse\n    KERNELDIR ?= /lib/modules/$(shell uname -r)/build\n    PWD := $(shell pwd)\n\n.PHONY: modules\nmodules:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules\nendif\n\n.PHONY: clean\nclean:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) clean\n\n```\n\n在一个典型的构造过程中，该makefile将被读取两次。当makefile从命令行运调用时，KERNELRELEASE变量并未设置，这个makefile通过已安装的模块目录中指向内核构造树的符号链接，定位内核的源代码目录。如果实际运行的内核并不是要构造的内核，则可以在命令行提供KENELDIR=选项或者设置KERNELDIR环境变量，也可以修改makfile中用来设置KERNELDIR的行。找到内核源代码树之后，这个makefile会调用modules目标，通过之前描述的方法第二次运行make命令，以便运行内核构建系统。\n\n### 装载和卸载模块\n\n**insmod**将模块装入内核。它将模块的代码和数据装入内核，然后使用内核的符号表解析模块中任何为解析的符号。与链接器不同，内核不会修改模块的磁盘文件，仅仅修改内存中的副本。insmod可以接受一些命令行选项，可以在模块链接到内核之前给模块中的整型和字符串变量赋值。一个设计良好的模块，可以在装载时进行配置。\n\n函数**sys_init_module**给模块分配内核内存。有且只有系统调用的名字前带有sys_前缀。\n\n**modprobe**也用来将模块装载到内核中。它与insmod的区别在于，会考虑要装载的模块是否引用了一些当前内核不存在的符号。如果存在这类引用，它会在当前模块搜索路径中查找定义了这些符号的其他模块。如果它找到了这些模块，则会同时将它们装载到内核。\n\n**rmmod**可以从内核中移除模块。如果内核认为模块仍在使用状态或者内核被配置为禁止移除模块，则无法移除该模块。\n\n**lsmod**列出当前装载到内核中的所有模块，它通过读取/proc/modules文件获得这些信息。有关当前已装载模块的信息也可以在/sys/module下找到。\n\n### 版本依赖\n\n在缺少modversion的情况下，我们的**模块代码必须针对要链接的每个版本的内核重新编译**。**模块和特定的内核版本定义的数据结构和函数原型紧密关联**。\n\n内核不会假定一个给定的模块是针对正确的内核版本构造的。在构造过程中，**可以将自己的模块和vermagic.o链接**。该目标文件包含了大量有关内核的信息，在试图装载模块时，这些信息可以用来检查模块和正在运行的内核的兼容性。\n\n如果打算编写一个**能够和多个内核版本一起工作的模块**，则必须**使用宏以及#ifdef**来构造并编译自己的代码。\n\n- UTS_RELEASE，该宏扩展为一个描述内核版本的字符串\n- LINUX_VERSION_CODE，该宏扩展为为内核版本的二进制表示，版本发行号中的每一部分对应一个字节\n- KERNEL_VERSION(major,minor,release)，该宏以组成版本号的三个部分，创建整数的版本号\n\n**不应随意使用#ifdef条件语句**将驱动程序代码弄得杂乱无章。最好的一个解决方法就是**将所有相关的预处理条件语句集中存放在一个特定的头文件中**。一般而言，**依赖于特定版本的代码应该隐藏在低层宏或函数之中**。\n\n### 平台依赖\n\n如果模块和某个给定内核工作，它也**必须和内核一样了解目标处理器**。通过**链接vermagic.o**，在装载模块时，内核会检查处理器相关的配置选项以便确保模块匹配于运行中的内核。\n\n### 内核符号表\n\ninsmod使用**公共内核符号表**来解析模块中未定义的符号。**公共内核符号表**包含了**所有的全局内核项（函数和变量）的地址**，它是实现模块化驱动程序所必须的。\n\n当模块被装入内核后，它所**导出的任何符号**都会变成内核符号表的一部分。通常情况下，模块只需实现自己的功能，而无需导出任何符号。如果其他模块要从某个模块获得好处，则需要导出符号。这样就可以在其他模块上**层叠新的模块**，即**模块层叠技术**。\n\n如果一个模块要向其他模块导出符号，则应该使用下面的宏\n\n```c\nEXPORT_SYMBOL(name);\nEXPORT_SYMBOL_GPL(name);\n```\n\nGPL版本使得要导出的模块只能被GPL许可证下的模块使用。**符号必须在模块文件的全局部分导出**，不能在函数中导出。\n\n### 预备知识\n\n内核是一个特定的环境，对需要和它接口的代码有其自己的一些要求。\n\n所有的模块代码中都包含下面两行代码\n\n```c\n#include <linux/module.h> \n#include <linux/init.h>\n```\n\n**module.h**包含可装载模块需要的大量符号和函数的定义。**init.h**是为了指定初始化和清除函数。\n\n大部分模块还包含**moduleparam.h**头文件，这样就可以**在装载模块时向模块传递参数**。\n\n尽管不是严格要求，模块应该指定所使用的许可证，例如\n\n```c\nMODULE_LICENSE(\"GPL\")\n```\n\n内核可以识别\n\n- GPL\n- GPL v2\n- GPL and additional rights\n- Dual BSD/GPL\n- Dual MPL/GPL\n- Proprietary\n\n如果模块没有显式地标记为上述可识别的许可证，就会被假定是专有的，内核装在这种模块就会被“污染”。\n\n还可包含其他描述性定义\n\n```c\nMODULE_AUTHOR\nMODULE_DESCRIPTION\nMODULE_VERSION\nMODULE_ALIAS\nMODULE_DEVICE_TABLE\n```\n\n这些MODULE_声明，一般**放在文件的最后**。\n\n### 初始化和关闭\n\n模块的**初始化函数**负责**注册**模块所提供的任何**设施**。这里的**设施**指的是一个可以被应用程序访问的新功能，例如一个完整的驱动程序或一个新的软件抽象。\n\n```c\nstatic int __init initialization_function(void)\n{\n\t/*Initialization codes*/\n}\n\nmodule_init(initialization_function);\n```\n\n初始化函数被声明为static，它在特定文件之外没有其他意义。但这并不是一个强制性规则，因为一个模块函数如果要对内核其他部分可见，则必须被显式导出。\n\n__init标记表明该函数仅在初始化期间使用。载模块被装载后，模块装载器会将初始化函数丢弃，以释放其占用的内存。__init和 __initdata很值得使用，但请注意，不要在结束初始化之后仍要使用的函数或数据上使用它们。\n\nmodule_init的使用是强制的。这个宏会在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置。\n\n模块可以注册许多不同类型的设施。对每种设施，对应有具体的内核函数用来完成注册。传递到内核注册函数的参数通常是指向用来描述新设施及设施名称的数据结构指针，而数据结构通常包含指向模块函数的指针。这样，模块中的函数就会在恰当的时间被内核调用。\n\n#### 清除函数\n\n每个重要的模块都需要一个清除函数，它在模块被移除前注销接口并向系统返回所有资源。该函数定义如下\n\n```c\nstatic void __exit cleanup_function(void)\n{\n\t/*Cleanup codes*/\n}\nmodule_exit(cleanup_function);\n```\n\n清除函数没有返回值。\n__exit修饰词标记改代码仅用于模块卸载，编译器将把该函数放在特殊的ELF段中。被标记为__exit的函数只能在模块被卸载或者系统关闭时调用。\n\nmodule_exit声明帮助内核找到模块的清除函数。\n\n如果一个模块未定义清除函数，则内核不允许卸载该模块。\n\n#### 初始化过程中的错误处理\n\n在内核中注册设施时，**时刻铭记注册可能会失败**。模块代码必须始终检查返回值，确保所有的操作已真正成功。\n\n如果在注册设施时遇到任何错误，首先要判断模块是否可以继续初始化。通常在某个注册失败后可以通过降低功能来继续运转。\n\n如果在发生了某个特定类型的错误之后无法继续装载模块，则要将出错之前的任何注册工作撤销掉。\n\n错误恢复的**处理有时使用goto语句**比较有效，可以避免大量复杂的、高度缩进的“结构化”逻辑。\n\n```c\nint __init my_init_func(void)\n{\n\tint err;\n\t/*Register using pointers and names */\n\terr = register_this(ptr1,\"skull\");\n\tif(err)\n\t\tgoto fail_this;\n\terr = register_that(ptr2,\"skull\");\n\tif(err)\n\t\tgoto fail_that;\n\terr = register_those(ptr3,\"skull\");\n\tif(err)\n\t\tgoto fail_those;\n\t/*Success*/\n\treturn 0;\n\nfail_those:\n\tunregister_that(ptr2,\"skull\");\nfail_that:\n\tunregister_this(ptr1,\"skull\");\nfail_this:\n\treturn err;\n}\n```\n\n以上的代码再出错的时候使用goto语句，它将只撤销出错时刻以前所成功注册的那些设施。\nmy_init_module的返回值err是一个错误编码，它是定义在<linux/error.h>中的负整数。每次返回合适的错误编码是一个好习惯。\n\n模块的清除函数需要撤销初始化函数所注册的所有设施，习惯上，以相反于注册的顺序撤销设施。\n\n```c\nvoid __exit my_cleanup_function(void)\n{\n\tunregister_those(ptr3,\"skull\");\n\tunregister_that(ptr2,\"skull\");\n\tunregister_this(ptr1,\"skull\");\n\treturn\n}\n```\n\n**每当发生错误时从初始化函数中调用清除函数**，将减少代码的重复并使代码更清晰、更有条理。当然，清除函数**必须在撤销每项设施的注册之前检查它的状态**。\n\n```c\nstruct something *item1;\nstruct somethingelse *item2;\nint stuff_ok;\n\nvoid my_cleanup(void)\n{\n\tif(item1)\n\t\trelease_thing(item1);\n\tif(item2)\n\t\trelease_thing2(item2);\n\tif(stuff_ok)\n\t\tunregister_stuff();\n\treturn;\n}\n\nint __init my_init(void)\n{\n\tint err = -ENOMEM;\n\titem1 = allocate_thing(arguments);\n\titem2 = allocate_thing2(arguments2);\n\tif(!item1 || !item2)\n\t\tgoto fail;\n\terr = register_stuff(item1,item2);\n\tif(!err)\n\t\tstuff_ok = 1;\n\telse\n\t\tstuff_ok = 0;\n\treturn 0;\n\nfail:\n\tmy_cleanup();\n\treturn err;\n}\n```\n\n以上代码中的初始化方式可以扩展到对大量设施的支持。需要注意的是，因为清除函数被非退出代码调用，因此**不能将清除函数标记为__exit**。\n\n#### 模块装载竞争\n\n首先要始终铭记的是，**在注册完成后，内核的某些部分可能会立即使用我们刚刚注册的任何设施**。也就是说，**初始化函数还在运行的时候，内核就完全可能调用我们的模块**。\n\n所以，**在首次注册完成后，代码就应该准备好被内核的其他部分调用，在用来支持某个设施的所有内部初始化完成之前，不要注册任何设施。**\n\n### 模块参数\n\n由于系统的不同，**驱动程序需要的参数也会发生变化**，例如设备编号和一些用来控制驱动程序操作方式的参数。为满足这种需求，**内核允许对驱动程序指定参数**，而这些参数**可在装载驱动程序模块时改变。**\n\n这些**参数的值可在运行insmod或modprobe命令时赋值**，而**modprobe还可以从其配置文件（/etc/modprobe.conf）中读取参数值**。这两个命令可以接受几种参数类型的赋值\n\n- bool\n- invbool：bool和invbool关联的变量应该是int类型\n- charp：字符指针值。\n- int\n- long\n- short\n- uint\n- ulong\n- ushort\n\n在insmod改变模块参数之前，**模块必须让这些参数对insmod命令可见**。参数必须**通过module_param宏来声明**，它有三个参数\n\n- 变量的名称\n- 类型\n- 用于sysfs入口项的访问许可掩码\n\n这个宏**必须放在任何函数之外**，通常是在源文件的头部。\n\n模块的装载器**也支持数组参数**，在**提供数组值时用逗号划分各数组成员**。要声明数组参数，使用**宏module_param_array(name,type,num,perm)**。模块装载器会**拒绝接受超过数组大小的值**。\n\n如果我们**需要的类型不在上面列出的清单中**，可以使用**模块代码中的钩子**来定义这些类型。\n\n**所有模块参数都应给定一个默认值**，insmod只会在用户明确设置了参数的值的情况下参会改变参数的值。\n\n**module_param的最后一个参数**是访问许可值，它用来**控制谁能访问sysfs中对模块参数的表述**\n\n- 如果perm被设置为0，就不会有对应的sysfs入口项\n- 否则模块参数会在sys/module中出现，并设置为给定的访问许可\n\n如果一个参数通过sysfs被修改，内核不会以任何方式通知模块。大多数情况下，不应该让模块参数可写。\n\n```c\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic char *whom = \"Mom\";\nstatic int howmany = 1;\n\nmodule_param(howmany, int,   S_IRUGO);\nmodule_param(whom,    charp, S_IRUGO);\n\nstatic\nint __init m_init(void)\n{\n\tprintk(KERN_WARNING \"parameters test module is loaded\\n\");\n\n\tfor (int i = 0; i < howmany; ++i) {\n\t\tprintk(KERN_WARNING \"#%d Hello, %s\\n\", i, whom);\n\t}\n\treturn 0;\n}\n\nstatic\nvoid __exit m_exit(void)\n{\n\tprintk(KERN_WARNING \"parameters test module is unloaded\\n\");\n}\n\nmodule_init(m_init);\nmodule_exit(m_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bryan\");\nMODULE_DESCRIPTION(\"Module parameters test program\");\n\n```\n\n直接使用insmod，装载模块\n\n```\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko \nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ dmesg | tail -10\n[  282.742416] raid6: .... xor() 21210 MB/s, rmw enabled\n[  282.742417] raid6: using avx2x2 recovery algorithm\n[  282.783190] xor: automatically using best checksumming function   avx       \n[  282.877516] Btrfs loaded, crc32c=crc32c-intel\n[  367.429218] parameters test module is unloaded\n[  378.711958] parameters test module is loaded\n[  378.711959] #0 Hello, Mom\n[  470.278217] parameters test module is unloaded\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n使用insmod装载模块时，携带参数\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo rmmod module_parameters \nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ dmesg | tail -10\n[  378.711959] #0 Hello, Mom\n[  470.278217] parameters test module is unloaded\n[  473.729918] parameters test module is loaded\n[  473.729919] #0 Hello, Mom\n[  556.020495] parameters test module is unloaded\n[  578.373167] parameters test module is loaded\n[  578.373168] #0 Hello, dady\n[  578.373168] #1 Hello, dady\n[  578.373169] #2 Hello, dady\n[  582.573809] parameters test module is unloaded\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n在insmod装载模块之前，在/sys/module目录下无法找到module_parameters目录\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters\nls: cannot access '/sys/module/module_parameters': No such file or directory\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\ninsmod装在模块后，可以在/sys/module目录下找到module_parameters目录，并在/sys/module/module_parameters/parameters目录下看到两个参数\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters\ncoresize  initsize   notes       refcnt    srcversion  uevent\nholders   initstate  parameters  sections  taint\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters/parameters/\nhowmany  whom\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters/parameters/howmany \n/sys/module/module_parameters/parameters/howmany\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ cat /sys/module/module_parameters/parameters/howmany \n3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ cat /sys/module/module_parameters/parameters/whom \ndady\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n","source":"_posts/Linux驱动-构造和运行模块个人学习总结.md","raw":"---\ntitle: Linux驱动-构造和运行模块个人学习总结\ndate: 2023-09-29 10:40:26\nIndex_img: https://github.com/Ricardo0106/Ricardo0106.github.io/blob/master/yzb/%E5%B0%8F%E7%8B%97%E5%8D%B7%E5%8D%B7.jpg\ntags:\n  - Linux Kernel Driver\ntypora-root-url: ./..\n---\n\n\n我发现对于学习任何一门知识，在最开始只能背诵或抄写别人的一些总结，所以tyro阶段我会抄写一些别人的文章，进行复习总结。<br>\n\n我记得小时候看过一部电影《心灵捕手》，虽然主线剧情不是我要说的，但我仍然记者记忆中有个桥段，Will在哈佛附近的酒吧遇到Skylar的时候，Will最铁的哥们查克冒充历史系学生和美女Skylar搭讪，但哈佛大学的学生克拉克看破了查克是冒牌货，于是过来考查克历史学知识，Will不止回答了这些知识，还输出了一顿自己的理解。我一直不明白，同为学生时代的我们，究竟会有什么差距呢，后来看到这一段，我才发现，只有能输出自己的东西才算是在这个领域有所了解了吧？所以tyro阶段我也只能摘抄一些别人消化的知识点，多希望我也能有一天输出自己的东西。\n\n![](/imgs/外设驱动开发/心灵捕手.webp)\n\n<small>提到《心灵捕手》我又想到:<br>\n你年轻彪悍，我如果和你谈论战争，你大可以向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友”，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。不要以为，我了解你。也许我可以通过“知识”来看你，但那不是你，除非你愿意谈谈你自己，否则我不知道你到底是谁。有时候喜欢是一种非常简单的事，我没有进入过你的世界，只听你讲过自己的故事，你人生的前25年从未参与过，我喜欢的只是我所认识的25岁的你。我不知道为什么，我真真实实的做了一场梦，很久很久的梦，我把人生的25年从头过了一遍，非常真切的感受，30年的人生所有的故事主角都是你，我才发现，我的这份喜欢似乎是贯彻了这痛苦的一生。</small>\n\n<small>ANY WAY，写这些东西的时候我的状态是非常不好的，最近这两年我失去了爱我的外婆，得了很多很重的疾病，毕业选择的第一家公司在春招结束的时候解散了，还有一个她。在这之前我的世界没有什么情绪，对生活也没有热情，感谢她给我平庸的人生带来了一些阳光。让我捡起来对生活的热爱，谢谢你，u complete me。人生太多变化，不知道还能在一起多久，我们已经是家人了吧，不要忘记我奥，死亡不是真的逝去，遗忘才是永恒的消亡。</small>\n\n# 构造和运行模块\n\n### 内核模块与应用程序的对比\n\n大多数中小规模的应用程序是从头到尾执行单个任务。**模块只是预先注册自己以便服务于将来的某个请求**，然后其初始化函数立即结束，模块的退出函数将在模块被卸载之前调用。**内核模块的编程方式和事件驱动的编程有些类似。**\n应用程序在退出时可以不管资源的释放或其他的清除工作。但**模块的退出函数必须仔细撤销初始化函数所作的一切**，否则，在系统重新引导之前某些东西就会残留在系统中。\n应用程序可以调用它并未定义的函数，因为连接过程能够解析外部引用从而使用适当的函数库。但**模块仅被链接到内核，它能调用的函数仅仅是由内核导出的那些函数，而不存在任何可链接的函数库。**\n模块源文件中不能包含通常的头文件，只能使用作为内核一部分的函数。\n应用程序开发过程中的段错误是无害的，并且总是可以使用调试器跟踪到源代码中的问题所在；内核错误即使不影响整个系统，也至少会杀死当前进程。\n\n#### 可重入\n\n可重入性作为多线程编程里面重要的概念，相信大家或多或少都听说过、研究过甚至使用过。目前很多资料都重点在介绍重入锁、CAS等概念，对“可重入性”本身的讲解不是很多，所以JavaCool给大家整理了一些“可重入性”的相关知识，希望能帮助到大家！\n\n* 可重入的定义\n简单定义:\"可以正确重复使用\"，有两个关键：1，可以重复使用；2，并能正确使用。意味着在多次执行的时候能得到正确的值，并不受其他调用的影响。\n官方定义：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\n这里也有一段比较好的英文阐释：\nA computer program or routine is described as reentrant if it can be safely called again before its previous invocation has been completed (i.e it can be safely executed concurrently)\n可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。\n\n* 产生背景\n可重入概念是在单线程操作系统的时代提出的。一个子程序的重入，可能由于自身原因，如执行了jmp或者call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX系统的signal的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。\n\n* 编写可重入代码注意的条件\n若一个函数是可重入的，则该函数应当满足下述条件：\n\n不能含有静态（全局）非常量数据。\n不能返回静态（全局）非常量数据的地址。\n只能处理由调用者提供的数据。\n不能依赖于单实例模式资源的锁。\n调用(call)的函数也必需是可重入的。\n上述条件就是要求可重入函数使用的所有变量都保存在呼叫堆叠的当前函数栈（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。\n\n多“用户/对象/进程优先级”以及多进程（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似编程中的静态、全域）资源。\n\n* 与线程安全的关系\n可重入与线程安全两个概念都关系到函数处理资源的方式。但是，他们有重大区别：可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入同步机制以保护共享的资源，使之不会被几个线程同时访问。\n\n操作系统背景与CPU调度策略：\n可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。\n\n多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的时间片，不断向前推进执行进度。可重入函数未必是线程安全的；线程安全函数未必是可重入的。\n\n例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。\n另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。fprintf函数就是线程安全但不可重入。\n* 可重入锁\n可重入锁也叫递归锁，它俩等同于一回事，指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，同一线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock 和 synchronized 就是典型的可重入锁！\n\n**操作系统的作用**是\n\n- 为应用程序提供一个对计算机硬件的一致视图\n- 负责程序的独立操作并保护资源不受非法访问。该任务只有在CPU能够保护系统软件不受应用程序破坏时才能完成。\n\n人们在CPU中实现不同的操作模式（或者级别）。不同的级别具有不同的功能，在较低的级别中将禁止某些操作。程序代码只能通过有限数目的“门” 从一个级别切换到另一级别。Unix使用了两个这样的级别：内核运行在最高级别（也称作超级用户态），可以进行所有操作；应用程序运行在最低级别（即所谓的用户态），处理器控制着对硬件的直接访问以及对内存的非授权访问。两种模式具有不同的优先权等级，每个模式都有自己的内存映射，即自己的地址空间。\n\n应用程序执行系统调用或者被硬件中断挂起时，Unix将执行模式从用户空间切换到内核空间\n\n- 执行系统调用的内核代码运行在进程上下文中，它代表用户进程执行操作，因此可以访问进程地址空间的所有数据\n- 处理硬件中断的内核代码和进程是异步的，与任何一个特定进程无关。\n\n一个驱动程序通常要执行两类任务\n\n- 某些函数作为系统调用的一部分而执行\n- 其他函数负责中断处理\n\n### 内核中的并发\n\n内核编程区别于常见应用程序编程的地方在于对并发的处理。即使是最简单的内核模块，都需要在编写时铭记：同一时刻，可能会有许多事情正在发生。\n\n##### 内核编程必须考虑并发的原因\n\n- Linux系统中通常正在运行多个并发进程，他们可能同时使用我们的驱动程序。\n\n- 大多数设备能够中断处理器，而中断处理程序异步运行，而且可能在驱动程序试图处理其他任务时被调用。\n- 一些抽象软件，例如内核定时器，也在异步运行。\n- Linux可以运行在SMP系统上，可能同时有不止一个CPU运行我们的驱动程序。\n- 在2.6中内核代码已经是可抢占的，意味着即使在单处理器系统上也存在许多类似多处理器系统的并发问题。\n\nLinux内核代码（包括驱动程序代码）必须是可重入的，它必须能够同时运行在多个上下文中。对编写正确的内核代码来说，优良的并发管理是必需的。\n\n#### 当前进程\n\n虽然内核模块不像应用程序那样顺序执行，然而内核执行的大多数操作还是和某个特定的进程相关。\n内核代码可通过访问全局项current来获得当前进程。它是一个指向struct task_struct的指针。current指针指向当前正在运行的进程。内核代码可以通过current获得与当前进程相关的信息。例如，下面的语句通过访问struct task_struct的某些成员来打印当前进程的ID和命令名：\n\n```c\nprintk(KERN_INFO \"The process is \\\" %s \\\" (pid %i)\\n\",\ncurrent->common,current->pid);\n```\n\n为了支持SMP系统，内核开发这设计了一种能找到运行在相关CPU上的当前进程的机制。它必须是快速的，因为对current的引用会很频繁。一种不依赖于特定架构的机制通常是，**将指向task_struct结构的指针隐藏在内核栈中**。\n\n## 编译和装载\n\n### 编译模块\n\n内核是一个大的、独立的程序，为了将它的各个片段放在一起，要满足很多详细而明确的要求。\n\n在构造内核模块之前，有一些先决条件首先应该得到满足\n\n- 确保具备正确版本的编译器、模块工具和其他必要的工具（Documentation/Changes文件）。注意：使用太新的工具也偶尔会导致问题。\n- 准备内核树，配置并构造内核。\n\n```c\nobj-m := hello.o\n```\n\n上面的赋值语句（它利用了GNU make的扩展语法）说明了有一个模块需要从目标文件hello.o中构造，而从该目标文件中构造的模块名称为hello.ko。\n\n如果要构造的模块名称为module.ko，并由两个源文件生成（file1.c和file2.c），那么makefile可编写如下\n\n```makefile\nobj-m := module.o\nmodule-objs := file1.o file2.o\n```\n\n为了让上面这种类型的makefile文件正常工作，**必须在大的内核构造系统环境中调用它们**。如果内核源代码树保存在~/kernel-2.6目录，则用来构造模块的make命令（在包含模块代码和makefile的目录中输入）\n\n```makefile\nmake -C ~/kernel-2.6 M=`pwd` modules\n```\n\n上述命令**首先改变目录到内核源代码目录**，该目录保存由内核的顶层makefile文件。**M=选项**让该makefile在构造modules目标之前返回到模块源代码目录。然后，**modules目标指向obj-m变量中设定的模块**。\n\n另一种makefile方法，可以使得**内核树之外的模块构造**更加容易。\n\n```makefile\n# If KERNELRELEASE is defined, we've been invoked from the\n# kernel build system and can use its language.\nifneq ($(KERNELRELEASE),)\n    hello_world-objs := main.o\n    obj-m := hello_world.o\n\n# Otherwise we were called directly from the command\n# line; invoke the kernel build system.\nelse\n    KERNELDIR ?= /lib/modules/$(shell uname -r)/build\n    PWD := $(shell pwd)\n\n.PHONY: modules\nmodules:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules\nendif\n\n.PHONY: clean\nclean:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) clean\n\n```\n\n在一个典型的构造过程中，该makefile将被读取两次。当makefile从命令行运调用时，KERNELRELEASE变量并未设置，这个makefile通过已安装的模块目录中指向内核构造树的符号链接，定位内核的源代码目录。如果实际运行的内核并不是要构造的内核，则可以在命令行提供KENELDIR=选项或者设置KERNELDIR环境变量，也可以修改makfile中用来设置KERNELDIR的行。找到内核源代码树之后，这个makefile会调用modules目标，通过之前描述的方法第二次运行make命令，以便运行内核构建系统。\n\n### 装载和卸载模块\n\n**insmod**将模块装入内核。它将模块的代码和数据装入内核，然后使用内核的符号表解析模块中任何为解析的符号。与链接器不同，内核不会修改模块的磁盘文件，仅仅修改内存中的副本。insmod可以接受一些命令行选项，可以在模块链接到内核之前给模块中的整型和字符串变量赋值。一个设计良好的模块，可以在装载时进行配置。\n\n函数**sys_init_module**给模块分配内核内存。有且只有系统调用的名字前带有sys_前缀。\n\n**modprobe**也用来将模块装载到内核中。它与insmod的区别在于，会考虑要装载的模块是否引用了一些当前内核不存在的符号。如果存在这类引用，它会在当前模块搜索路径中查找定义了这些符号的其他模块。如果它找到了这些模块，则会同时将它们装载到内核。\n\n**rmmod**可以从内核中移除模块。如果内核认为模块仍在使用状态或者内核被配置为禁止移除模块，则无法移除该模块。\n\n**lsmod**列出当前装载到内核中的所有模块，它通过读取/proc/modules文件获得这些信息。有关当前已装载模块的信息也可以在/sys/module下找到。\n\n### 版本依赖\n\n在缺少modversion的情况下，我们的**模块代码必须针对要链接的每个版本的内核重新编译**。**模块和特定的内核版本定义的数据结构和函数原型紧密关联**。\n\n内核不会假定一个给定的模块是针对正确的内核版本构造的。在构造过程中，**可以将自己的模块和vermagic.o链接**。该目标文件包含了大量有关内核的信息，在试图装载模块时，这些信息可以用来检查模块和正在运行的内核的兼容性。\n\n如果打算编写一个**能够和多个内核版本一起工作的模块**，则必须**使用宏以及#ifdef**来构造并编译自己的代码。\n\n- UTS_RELEASE，该宏扩展为一个描述内核版本的字符串\n- LINUX_VERSION_CODE，该宏扩展为为内核版本的二进制表示，版本发行号中的每一部分对应一个字节\n- KERNEL_VERSION(major,minor,release)，该宏以组成版本号的三个部分，创建整数的版本号\n\n**不应随意使用#ifdef条件语句**将驱动程序代码弄得杂乱无章。最好的一个解决方法就是**将所有相关的预处理条件语句集中存放在一个特定的头文件中**。一般而言，**依赖于特定版本的代码应该隐藏在低层宏或函数之中**。\n\n### 平台依赖\n\n如果模块和某个给定内核工作，它也**必须和内核一样了解目标处理器**。通过**链接vermagic.o**，在装载模块时，内核会检查处理器相关的配置选项以便确保模块匹配于运行中的内核。\n\n### 内核符号表\n\ninsmod使用**公共内核符号表**来解析模块中未定义的符号。**公共内核符号表**包含了**所有的全局内核项（函数和变量）的地址**，它是实现模块化驱动程序所必须的。\n\n当模块被装入内核后，它所**导出的任何符号**都会变成内核符号表的一部分。通常情况下，模块只需实现自己的功能，而无需导出任何符号。如果其他模块要从某个模块获得好处，则需要导出符号。这样就可以在其他模块上**层叠新的模块**，即**模块层叠技术**。\n\n如果一个模块要向其他模块导出符号，则应该使用下面的宏\n\n```c\nEXPORT_SYMBOL(name);\nEXPORT_SYMBOL_GPL(name);\n```\n\nGPL版本使得要导出的模块只能被GPL许可证下的模块使用。**符号必须在模块文件的全局部分导出**，不能在函数中导出。\n\n### 预备知识\n\n内核是一个特定的环境，对需要和它接口的代码有其自己的一些要求。\n\n所有的模块代码中都包含下面两行代码\n\n```c\n#include <linux/module.h> \n#include <linux/init.h>\n```\n\n**module.h**包含可装载模块需要的大量符号和函数的定义。**init.h**是为了指定初始化和清除函数。\n\n大部分模块还包含**moduleparam.h**头文件，这样就可以**在装载模块时向模块传递参数**。\n\n尽管不是严格要求，模块应该指定所使用的许可证，例如\n\n```c\nMODULE_LICENSE(\"GPL\")\n```\n\n内核可以识别\n\n- GPL\n- GPL v2\n- GPL and additional rights\n- Dual BSD/GPL\n- Dual MPL/GPL\n- Proprietary\n\n如果模块没有显式地标记为上述可识别的许可证，就会被假定是专有的，内核装在这种模块就会被“污染”。\n\n还可包含其他描述性定义\n\n```c\nMODULE_AUTHOR\nMODULE_DESCRIPTION\nMODULE_VERSION\nMODULE_ALIAS\nMODULE_DEVICE_TABLE\n```\n\n这些MODULE_声明，一般**放在文件的最后**。\n\n### 初始化和关闭\n\n模块的**初始化函数**负责**注册**模块所提供的任何**设施**。这里的**设施**指的是一个可以被应用程序访问的新功能，例如一个完整的驱动程序或一个新的软件抽象。\n\n```c\nstatic int __init initialization_function(void)\n{\n\t/*Initialization codes*/\n}\n\nmodule_init(initialization_function);\n```\n\n初始化函数被声明为static，它在特定文件之外没有其他意义。但这并不是一个强制性规则，因为一个模块函数如果要对内核其他部分可见，则必须被显式导出。\n\n__init标记表明该函数仅在初始化期间使用。载模块被装载后，模块装载器会将初始化函数丢弃，以释放其占用的内存。__init和 __initdata很值得使用，但请注意，不要在结束初始化之后仍要使用的函数或数据上使用它们。\n\nmodule_init的使用是强制的。这个宏会在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置。\n\n模块可以注册许多不同类型的设施。对每种设施，对应有具体的内核函数用来完成注册。传递到内核注册函数的参数通常是指向用来描述新设施及设施名称的数据结构指针，而数据结构通常包含指向模块函数的指针。这样，模块中的函数就会在恰当的时间被内核调用。\n\n#### 清除函数\n\n每个重要的模块都需要一个清除函数，它在模块被移除前注销接口并向系统返回所有资源。该函数定义如下\n\n```c\nstatic void __exit cleanup_function(void)\n{\n\t/*Cleanup codes*/\n}\nmodule_exit(cleanup_function);\n```\n\n清除函数没有返回值。\n__exit修饰词标记改代码仅用于模块卸载，编译器将把该函数放在特殊的ELF段中。被标记为__exit的函数只能在模块被卸载或者系统关闭时调用。\n\nmodule_exit声明帮助内核找到模块的清除函数。\n\n如果一个模块未定义清除函数，则内核不允许卸载该模块。\n\n#### 初始化过程中的错误处理\n\n在内核中注册设施时，**时刻铭记注册可能会失败**。模块代码必须始终检查返回值，确保所有的操作已真正成功。\n\n如果在注册设施时遇到任何错误，首先要判断模块是否可以继续初始化。通常在某个注册失败后可以通过降低功能来继续运转。\n\n如果在发生了某个特定类型的错误之后无法继续装载模块，则要将出错之前的任何注册工作撤销掉。\n\n错误恢复的**处理有时使用goto语句**比较有效，可以避免大量复杂的、高度缩进的“结构化”逻辑。\n\n```c\nint __init my_init_func(void)\n{\n\tint err;\n\t/*Register using pointers and names */\n\terr = register_this(ptr1,\"skull\");\n\tif(err)\n\t\tgoto fail_this;\n\terr = register_that(ptr2,\"skull\");\n\tif(err)\n\t\tgoto fail_that;\n\terr = register_those(ptr3,\"skull\");\n\tif(err)\n\t\tgoto fail_those;\n\t/*Success*/\n\treturn 0;\n\nfail_those:\n\tunregister_that(ptr2,\"skull\");\nfail_that:\n\tunregister_this(ptr1,\"skull\");\nfail_this:\n\treturn err;\n}\n```\n\n以上的代码再出错的时候使用goto语句，它将只撤销出错时刻以前所成功注册的那些设施。\nmy_init_module的返回值err是一个错误编码，它是定义在<linux/error.h>中的负整数。每次返回合适的错误编码是一个好习惯。\n\n模块的清除函数需要撤销初始化函数所注册的所有设施，习惯上，以相反于注册的顺序撤销设施。\n\n```c\nvoid __exit my_cleanup_function(void)\n{\n\tunregister_those(ptr3,\"skull\");\n\tunregister_that(ptr2,\"skull\");\n\tunregister_this(ptr1,\"skull\");\n\treturn\n}\n```\n\n**每当发生错误时从初始化函数中调用清除函数**，将减少代码的重复并使代码更清晰、更有条理。当然，清除函数**必须在撤销每项设施的注册之前检查它的状态**。\n\n```c\nstruct something *item1;\nstruct somethingelse *item2;\nint stuff_ok;\n\nvoid my_cleanup(void)\n{\n\tif(item1)\n\t\trelease_thing(item1);\n\tif(item2)\n\t\trelease_thing2(item2);\n\tif(stuff_ok)\n\t\tunregister_stuff();\n\treturn;\n}\n\nint __init my_init(void)\n{\n\tint err = -ENOMEM;\n\titem1 = allocate_thing(arguments);\n\titem2 = allocate_thing2(arguments2);\n\tif(!item1 || !item2)\n\t\tgoto fail;\n\terr = register_stuff(item1,item2);\n\tif(!err)\n\t\tstuff_ok = 1;\n\telse\n\t\tstuff_ok = 0;\n\treturn 0;\n\nfail:\n\tmy_cleanup();\n\treturn err;\n}\n```\n\n以上代码中的初始化方式可以扩展到对大量设施的支持。需要注意的是，因为清除函数被非退出代码调用，因此**不能将清除函数标记为__exit**。\n\n#### 模块装载竞争\n\n首先要始终铭记的是，**在注册完成后，内核的某些部分可能会立即使用我们刚刚注册的任何设施**。也就是说，**初始化函数还在运行的时候，内核就完全可能调用我们的模块**。\n\n所以，**在首次注册完成后，代码就应该准备好被内核的其他部分调用，在用来支持某个设施的所有内部初始化完成之前，不要注册任何设施。**\n\n### 模块参数\n\n由于系统的不同，**驱动程序需要的参数也会发生变化**，例如设备编号和一些用来控制驱动程序操作方式的参数。为满足这种需求，**内核允许对驱动程序指定参数**，而这些参数**可在装载驱动程序模块时改变。**\n\n这些**参数的值可在运行insmod或modprobe命令时赋值**，而**modprobe还可以从其配置文件（/etc/modprobe.conf）中读取参数值**。这两个命令可以接受几种参数类型的赋值\n\n- bool\n- invbool：bool和invbool关联的变量应该是int类型\n- charp：字符指针值。\n- int\n- long\n- short\n- uint\n- ulong\n- ushort\n\n在insmod改变模块参数之前，**模块必须让这些参数对insmod命令可见**。参数必须**通过module_param宏来声明**，它有三个参数\n\n- 变量的名称\n- 类型\n- 用于sysfs入口项的访问许可掩码\n\n这个宏**必须放在任何函数之外**，通常是在源文件的头部。\n\n模块的装载器**也支持数组参数**，在**提供数组值时用逗号划分各数组成员**。要声明数组参数，使用**宏module_param_array(name,type,num,perm)**。模块装载器会**拒绝接受超过数组大小的值**。\n\n如果我们**需要的类型不在上面列出的清单中**，可以使用**模块代码中的钩子**来定义这些类型。\n\n**所有模块参数都应给定一个默认值**，insmod只会在用户明确设置了参数的值的情况下参会改变参数的值。\n\n**module_param的最后一个参数**是访问许可值，它用来**控制谁能访问sysfs中对模块参数的表述**\n\n- 如果perm被设置为0，就不会有对应的sysfs入口项\n- 否则模块参数会在sys/module中出现，并设置为给定的访问许可\n\n如果一个参数通过sysfs被修改，内核不会以任何方式通知模块。大多数情况下，不应该让模块参数可写。\n\n```c\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic char *whom = \"Mom\";\nstatic int howmany = 1;\n\nmodule_param(howmany, int,   S_IRUGO);\nmodule_param(whom,    charp, S_IRUGO);\n\nstatic\nint __init m_init(void)\n{\n\tprintk(KERN_WARNING \"parameters test module is loaded\\n\");\n\n\tfor (int i = 0; i < howmany; ++i) {\n\t\tprintk(KERN_WARNING \"#%d Hello, %s\\n\", i, whom);\n\t}\n\treturn 0;\n}\n\nstatic\nvoid __exit m_exit(void)\n{\n\tprintk(KERN_WARNING \"parameters test module is unloaded\\n\");\n}\n\nmodule_init(m_init);\nmodule_exit(m_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bryan\");\nMODULE_DESCRIPTION(\"Module parameters test program\");\n\n```\n\n直接使用insmod，装载模块\n\n```\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko \nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ dmesg | tail -10\n[  282.742416] raid6: .... xor() 21210 MB/s, rmw enabled\n[  282.742417] raid6: using avx2x2 recovery algorithm\n[  282.783190] xor: automatically using best checksumming function   avx       \n[  282.877516] Btrfs loaded, crc32c=crc32c-intel\n[  367.429218] parameters test module is unloaded\n[  378.711958] parameters test module is loaded\n[  378.711959] #0 Hello, Mom\n[  470.278217] parameters test module is unloaded\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n使用insmod装载模块时，携带参数\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo rmmod module_parameters \nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ dmesg | tail -10\n[  378.711959] #0 Hello, Mom\n[  470.278217] parameters test module is unloaded\n[  473.729918] parameters test module is loaded\n[  473.729919] #0 Hello, Mom\n[  556.020495] parameters test module is unloaded\n[  578.373167] parameters test module is loaded\n[  578.373168] #0 Hello, dady\n[  578.373168] #1 Hello, dady\n[  578.373169] #2 Hello, dady\n[  582.573809] parameters test module is unloaded\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n在insmod装载模块之前，在/sys/module目录下无法找到module_parameters目录\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters\nls: cannot access '/sys/module/module_parameters': No such file or directory\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\ninsmod装在模块后，可以在/sys/module目录下找到module_parameters目录，并在/sys/module/module_parameters/parameters目录下看到两个参数\n\n```c\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters\ncoresize  initsize   notes       refcnt    srcversion  uevent\nholders   initstate  parameters  sections  taint\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters/parameters/\nhowmany  whom\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ ls /sys/module/module_parameters/parameters/howmany \n/sys/module/module_parameters/parameters/howmany\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ cat /sys/module/module_parameters/parameters/howmany \n3\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ cat /sys/module/module_parameters/parameters/whom \ndady\nbryan@ubuntu:~/Desktop/Linux-Device-Driver-master/02_module_parameters$ \n```\n\n","slug":"Linux驱动-构造和运行模块个人学习总结","published":1,"updated":"2023-09-30T16:09:10.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sl000alcwf11r70m5q","content":"<p>我发现对于学习任何一门知识，在最开始只能背诵或抄写别人的一些总结，所以tyro阶段我会抄写一些别人的文章，进行复习总结。<br></p>\n<p>我记得小时候看过一部电影《心灵捕手》，虽然主线剧情不是我要说的，但我仍然记者记忆中有个桥段，Will在哈佛附近的酒吧遇到Skylar的时候，Will最铁的哥们查克冒充历史系学生和美女Skylar搭讪，但哈佛大学的学生克拉克看破了查克是冒牌货，于是过来考查克历史学知识，Will不止回答了这些知识，还输出了一顿自己的理解。我一直不明白，同为学生时代的我们，究竟会有什么差距呢，后来看到这一段，我才发现，只有能输出自己的东西才算是在这个领域有所了解了吧？所以tyro阶段我也只能摘抄一些别人消化的知识点，多希望我也能有一天输出自己的东西。</p>\n<p><img src=\"/imgs/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E5%BF%83%E7%81%B5%E6%8D%95%E6%89%8B.webp\"></p>\n<p><small>提到《心灵捕手》我又想到:<br><br>你年轻彪悍，我如果和你谈论战争，你大可以向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友”，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。不要以为，我了解你。也许我可以通过“知识”来看你，但那不是你，除非你愿意谈谈你自己，否则我不知道你到底是谁。有时候喜欢是一种非常简单的事，我没有进入过你的世界，只听你讲过自己的故事，你人生的前25年从未参与过，我喜欢的只是我所认识的25岁的你。我不知道为什么，我真真实实的做了一场梦，很久很久的梦，我把人生的25年从头过了一遍，非常真切的感受，30年的人生所有的故事主角都是你，我才发现，我的这份喜欢似乎是贯彻了这痛苦的一生。</small></p>\n<p><small>ANY WAY，写这些东西的时候我的状态是非常不好的，最近这两年我失去了爱我的外婆，得了很多很重的疾病，毕业选择的第一家公司在春招结束的时候解散了，还有一个她。在这之前我的世界没有什么情绪，对生活也没有热情，感谢她给我平庸的人生带来了一些阳光。让我捡起来对生活的热爱，谢谢你，u complete me。人生太多变化，不知道还能在一起多久，我们已经是家人了吧，不要忘记我奥，死亡不是真的逝去，遗忘才是永恒的消亡。</small></p>\n<h1 id=\"构造和运行模块\"><a href=\"#构造和运行模块\" class=\"headerlink\" title=\"构造和运行模块\"></a>构造和运行模块</h1><h3 id=\"内核模块与应用程序的对比\"><a href=\"#内核模块与应用程序的对比\" class=\"headerlink\" title=\"内核模块与应用程序的对比\"></a>内核模块与应用程序的对比</h3><p>大多数中小规模的应用程序是从头到尾执行单个任务。<strong>模块只是预先注册自己以便服务于将来的某个请求</strong>，然后其初始化函数立即结束，模块的退出函数将在模块被卸载之前调用。<strong>内核模块的编程方式和事件驱动的编程有些类似。</strong><br>应用程序在退出时可以不管资源的释放或其他的清除工作。但<strong>模块的退出函数必须仔细撤销初始化函数所作的一切</strong>，否则，在系统重新引导之前某些东西就会残留在系统中。<br>应用程序可以调用它并未定义的函数，因为连接过程能够解析外部引用从而使用适当的函数库。但<strong>模块仅被链接到内核，它能调用的函数仅仅是由内核导出的那些函数，而不存在任何可链接的函数库。</strong><br>模块源文件中不能包含通常的头文件，只能使用作为内核一部分的函数。<br>应用程序开发过程中的段错误是无害的，并且总是可以使用调试器跟踪到源代码中的问题所在；内核错误即使不影响整个系统，也至少会杀死当前进程。</p>\n<h4 id=\"可重入\"><a href=\"#可重入\" class=\"headerlink\" title=\"可重入\"></a>可重入</h4><p>可重入性作为多线程编程里面重要的概念，相信大家或多或少都听说过、研究过甚至使用过。目前很多资料都重点在介绍重入锁、CAS等概念，对“可重入性”本身的讲解不是很多，所以JavaCool给大家整理了一些“可重入性”的相关知识，希望能帮助到大家！</p>\n<ul>\n<li><p>可重入的定义<br>简单定义:”可以正确重复使用”，有两个关键：1，可以重复使用；2，并能正确使用。意味着在多次执行的时候能得到正确的值，并不受其他调用的影响。<br>官方定义：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。<br>这里也有一段比较好的英文阐释：<br>A computer program or routine is described as reentrant if it can be safely called again before its previous invocation has been completed (i.e it can be safely executed concurrently)<br>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>\n</li>\n<li><p>产生背景<br>可重入概念是在单线程操作系统的时代提出的。一个子程序的重入，可能由于自身原因，如执行了jmp或者call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX系统的signal的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。</p>\n</li>\n<li><p>编写可重入代码注意的条件<br>若一个函数是可重入的，则该函数应当满足下述条件：</p>\n</li>\n</ul>\n<p>不能含有静态（全局）非常量数据。<br>不能返回静态（全局）非常量数据的地址。<br>只能处理由调用者提供的数据。<br>不能依赖于单实例模式资源的锁。<br>调用(call)的函数也必需是可重入的。<br>上述条件就是要求可重入函数使用的所有变量都保存在呼叫堆叠的当前函数栈（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。</p>\n<p>多“用户&#x2F;对象&#x2F;进程优先级”以及多进程（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似编程中的静态、全域）资源。</p>\n<ul>\n<li>与线程安全的关系<br>可重入与线程安全两个概念都关系到函数处理资源的方式。但是，他们有重大区别：可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入同步机制以保护共享的资源，使之不会被几个线程同时访问。</li>\n</ul>\n<p>操作系统背景与CPU调度策略：<br>可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。</p>\n<p>多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的时间片，不断向前推进执行进度。可重入函数未必是线程安全的；线程安全函数未必是可重入的。</p>\n<p>例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。<br>另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。fprintf函数就是线程安全但不可重入。</p>\n<ul>\n<li>可重入锁<br>可重入锁也叫递归锁，它俩等同于一回事，指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，同一线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock 和 synchronized 就是典型的可重入锁！</li>\n</ul>\n<p><strong>操作系统的作用</strong>是</p>\n<ul>\n<li>为应用程序提供一个对计算机硬件的一致视图</li>\n<li>负责程序的独立操作并保护资源不受非法访问。该任务只有在CPU能够保护系统软件不受应用程序破坏时才能完成。</li>\n</ul>\n<p>人们在CPU中实现不同的操作模式（或者级别）。不同的级别具有不同的功能，在较低的级别中将禁止某些操作。程序代码只能通过有限数目的“门” 从一个级别切换到另一级别。Unix使用了两个这样的级别：内核运行在最高级别（也称作超级用户态），可以进行所有操作；应用程序运行在最低级别（即所谓的用户态），处理器控制着对硬件的直接访问以及对内存的非授权访问。两种模式具有不同的优先权等级，每个模式都有自己的内存映射，即自己的地址空间。</p>\n<p>应用程序执行系统调用或者被硬件中断挂起时，Unix将执行模式从用户空间切换到内核空间</p>\n<ul>\n<li>执行系统调用的内核代码运行在进程上下文中，它代表用户进程执行操作，因此可以访问进程地址空间的所有数据</li>\n<li>处理硬件中断的内核代码和进程是异步的，与任何一个特定进程无关。</li>\n</ul>\n<p>一个驱动程序通常要执行两类任务</p>\n<ul>\n<li>某些函数作为系统调用的一部分而执行</li>\n<li>其他函数负责中断处理</li>\n</ul>\n<h3 id=\"内核中的并发\"><a href=\"#内核中的并发\" class=\"headerlink\" title=\"内核中的并发\"></a>内核中的并发</h3><p>内核编程区别于常见应用程序编程的地方在于对并发的处理。即使是最简单的内核模块，都需要在编写时铭记：同一时刻，可能会有许多事情正在发生。</p>\n<h5 id=\"内核编程必须考虑并发的原因\"><a href=\"#内核编程必须考虑并发的原因\" class=\"headerlink\" title=\"内核编程必须考虑并发的原因\"></a>内核编程必须考虑并发的原因</h5><ul>\n<li><p>Linux系统中通常正在运行多个并发进程，他们可能同时使用我们的驱动程序。</p>\n</li>\n<li><p>大多数设备能够中断处理器，而中断处理程序异步运行，而且可能在驱动程序试图处理其他任务时被调用。</p>\n</li>\n<li><p>一些抽象软件，例如内核定时器，也在异步运行。</p>\n</li>\n<li><p>Linux可以运行在SMP系统上，可能同时有不止一个CPU运行我们的驱动程序。</p>\n</li>\n<li><p>在2.6中内核代码已经是可抢占的，意味着即使在单处理器系统上也存在许多类似多处理器系统的并发问题。</p>\n</li>\n</ul>\n<p>Linux内核代码（包括驱动程序代码）必须是可重入的，它必须能够同时运行在多个上下文中。对编写正确的内核代码来说，优良的并发管理是必需的。</p>\n<h4 id=\"当前进程\"><a href=\"#当前进程\" class=\"headerlink\" title=\"当前进程\"></a>当前进程</h4><p>虽然内核模块不像应用程序那样顺序执行，然而内核执行的大多数操作还是和某个特定的进程相关。<br>内核代码可通过访问全局项current来获得当前进程。它是一个指向struct task_struct的指针。current指针指向当前正在运行的进程。内核代码可以通过current获得与当前进程相关的信息。例如，下面的语句通过访问struct task_struct的某些成员来打印当前进程的ID和命令名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">printk(KERN_INFO <span class=\"hljs-string\">&quot;The process is \\&quot; %s \\&quot; (pid %i)\\n&quot;</span>,<br>current-&gt;common,current-&gt;pid);<br></code></pre></td></tr></table></figure>\n\n<p>为了支持SMP系统，内核开发这设计了一种能找到运行在相关CPU上的当前进程的机制。它必须是快速的，因为对current的引用会很频繁。一种不依赖于特定架构的机制通常是，<strong>将指向task_struct结构的指针隐藏在内核栈中</strong>。</p>\n<h2 id=\"编译和装载\"><a href=\"#编译和装载\" class=\"headerlink\" title=\"编译和装载\"></a>编译和装载</h2><h3 id=\"编译模块\"><a href=\"#编译模块\" class=\"headerlink\" title=\"编译模块\"></a>编译模块</h3><p>内核是一个大的、独立的程序，为了将它的各个片段放在一起，要满足很多详细而明确的要求。</p>\n<p>在构造内核模块之前，有一些先决条件首先应该得到满足</p>\n<ul>\n<li>确保具备正确版本的编译器、模块工具和其他必要的工具（Documentation&#x2F;Changes文件）。注意：使用太新的工具也偶尔会导致问题。</li>\n<li>准备内核树，配置并构造内核。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">obj-m := hello.o<br></code></pre></td></tr></table></figure>\n\n<p>上面的赋值语句（它利用了GNU make的扩展语法）说明了有一个模块需要从目标文件hello.o中构造，而从该目标文件中构造的模块名称为hello.ko。</p>\n<p>如果要构造的模块名称为module.ko，并由两个源文件生成（file1.c和file2.c），那么makefile可编写如下</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">obj-m := module.o<br>module-objs := file1.o file2.o<br></code></pre></td></tr></table></figure>\n\n<p>为了让上面这种类型的makefile文件正常工作，<strong>必须在大的内核构造系统环境中调用它们</strong>。如果内核源代码树保存在~&#x2F;kernel-2.6目录，则用来构造模块的make命令（在包含模块代码和makefile的目录中输入）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">make -C ~/kernel-2.6 M=`pwd` modules<br></code></pre></td></tr></table></figure>\n\n<p>上述命令<strong>首先改变目录到内核源代码目录</strong>，该目录保存由内核的顶层makefile文件。<strong>M&#x3D;选项</strong>让该makefile在构造modules目标之前返回到模块源代码目录。然后，<strong>modules目标指向obj-m变量中设定的模块</strong>。</p>\n<p>另一种makefile方法，可以使得<strong>内核树之外的模块构造</strong>更加容易。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># If KERNELRELEASE is defined, we&#x27;ve been invoked from the</span><br><span class=\"hljs-comment\"># kernel build system and can use its language.</span><br><span class=\"hljs-keyword\">ifneq</span> (<span class=\"hljs-variable\">$(KERNELRELEASE)</span>,)<br>    hello_world-objs := main.o<br>    obj-m := hello_world.o<br><br><span class=\"hljs-comment\"># Otherwise we were called directly from the command</span><br><span class=\"hljs-comment\"># line; invoke the kernel build system.</span><br><span class=\"hljs-keyword\">else</span><br>    KERNELDIR ?= /lib/modules/<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">shell</span> uname -r)</span>/build<br>    PWD := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">shell</span> pwd)</span><br><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: modules</span><br><span class=\"hljs-section\">modules:</span><br>\t<span class=\"hljs-variable\">$(MAKE)</span> -C <span class=\"hljs-variable\">$(KERNELDIR)</span> M=<span class=\"hljs-variable\">$(PWD)</span> modules<br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: clean</span><br><span class=\"hljs-section\">clean:</span><br>\t<span class=\"hljs-variable\">$(MAKE)</span> -C <span class=\"hljs-variable\">$(KERNELDIR)</span> M=<span class=\"hljs-variable\">$(PWD)</span> clean<br><br></code></pre></td></tr></table></figure>\n\n<p>在一个典型的构造过程中，该makefile将被读取两次。当makefile从命令行运调用时，KERNELRELEASE变量并未设置，这个makefile通过已安装的模块目录中指向内核构造树的符号链接，定位内核的源代码目录。如果实际运行的内核并不是要构造的内核，则可以在命令行提供KENELDIR&#x3D;选项或者设置KERNELDIR环境变量，也可以修改makfile中用来设置KERNELDIR的行。找到内核源代码树之后，这个makefile会调用modules目标，通过之前描述的方法第二次运行make命令，以便运行内核构建系统。</p>\n<h3 id=\"装载和卸载模块\"><a href=\"#装载和卸载模块\" class=\"headerlink\" title=\"装载和卸载模块\"></a>装载和卸载模块</h3><p><strong>insmod</strong>将模块装入内核。它将模块的代码和数据装入内核，然后使用内核的符号表解析模块中任何为解析的符号。与链接器不同，内核不会修改模块的磁盘文件，仅仅修改内存中的副本。insmod可以接受一些命令行选项，可以在模块链接到内核之前给模块中的整型和字符串变量赋值。一个设计良好的模块，可以在装载时进行配置。</p>\n<p>函数<strong>sys_init_module</strong>给模块分配内核内存。有且只有系统调用的名字前带有sys_前缀。</p>\n<p><strong>modprobe</strong>也用来将模块装载到内核中。它与insmod的区别在于，会考虑要装载的模块是否引用了一些当前内核不存在的符号。如果存在这类引用，它会在当前模块搜索路径中查找定义了这些符号的其他模块。如果它找到了这些模块，则会同时将它们装载到内核。</p>\n<p><strong>rmmod</strong>可以从内核中移除模块。如果内核认为模块仍在使用状态或者内核被配置为禁止移除模块，则无法移除该模块。</p>\n<p><strong>lsmod</strong>列出当前装载到内核中的所有模块，它通过读取&#x2F;proc&#x2F;modules文件获得这些信息。有关当前已装载模块的信息也可以在&#x2F;sys&#x2F;module下找到。</p>\n<h3 id=\"版本依赖\"><a href=\"#版本依赖\" class=\"headerlink\" title=\"版本依赖\"></a>版本依赖</h3><p>在缺少modversion的情况下，我们的<strong>模块代码必须针对要链接的每个版本的内核重新编译</strong>。<strong>模块和特定的内核版本定义的数据结构和函数原型紧密关联</strong>。</p>\n<p>内核不会假定一个给定的模块是针对正确的内核版本构造的。在构造过程中，<strong>可以将自己的模块和vermagic.o链接</strong>。该目标文件包含了大量有关内核的信息，在试图装载模块时，这些信息可以用来检查模块和正在运行的内核的兼容性。</p>\n<p>如果打算编写一个<strong>能够和多个内核版本一起工作的模块</strong>，则必须<strong>使用宏以及#ifdef</strong>来构造并编译自己的代码。</p>\n<ul>\n<li>UTS_RELEASE，该宏扩展为一个描述内核版本的字符串</li>\n<li>LINUX_VERSION_CODE，该宏扩展为为内核版本的二进制表示，版本发行号中的每一部分对应一个字节</li>\n<li>KERNEL_VERSION(major,minor,release)，该宏以组成版本号的三个部分，创建整数的版本号</li>\n</ul>\n<p><strong>不应随意使用#ifdef条件语句</strong>将驱动程序代码弄得杂乱无章。最好的一个解决方法就是<strong>将所有相关的预处理条件语句集中存放在一个特定的头文件中</strong>。一般而言，<strong>依赖于特定版本的代码应该隐藏在低层宏或函数之中</strong>。</p>\n<h3 id=\"平台依赖\"><a href=\"#平台依赖\" class=\"headerlink\" title=\"平台依赖\"></a>平台依赖</h3><p>如果模块和某个给定内核工作，它也<strong>必须和内核一样了解目标处理器</strong>。通过<strong>链接vermagic.o</strong>，在装载模块时，内核会检查处理器相关的配置选项以便确保模块匹配于运行中的内核。</p>\n<h3 id=\"内核符号表\"><a href=\"#内核符号表\" class=\"headerlink\" title=\"内核符号表\"></a>内核符号表</h3><p>insmod使用<strong>公共内核符号表</strong>来解析模块中未定义的符号。<strong>公共内核符号表</strong>包含了<strong>所有的全局内核项（函数和变量）的地址</strong>，它是实现模块化驱动程序所必须的。</p>\n<p>当模块被装入内核后，它所<strong>导出的任何符号</strong>都会变成内核符号表的一部分。通常情况下，模块只需实现自己的功能，而无需导出任何符号。如果其他模块要从某个模块获得好处，则需要导出符号。这样就可以在其他模块上<strong>层叠新的模块</strong>，即<strong>模块层叠技术</strong>。</p>\n<p>如果一个模块要向其他模块导出符号，则应该使用下面的宏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">EXPORT_SYMBOL(name);<br>EXPORT_SYMBOL_GPL(name);<br></code></pre></td></tr></table></figure>\n\n<p>GPL版本使得要导出的模块只能被GPL许可证下的模块使用。<strong>符号必须在模块文件的全局部分导出</strong>，不能在函数中导出。</p>\n<h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p>内核是一个特定的环境，对需要和它接口的代码有其自己的一些要求。</p>\n<p>所有的模块代码中都包含下面两行代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/module.h&gt;</span> </span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/init.h&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>module.h</strong>包含可装载模块需要的大量符号和函数的定义。<strong>init.h</strong>是为了指定初始化和清除函数。</p>\n<p>大部分模块还包含<strong>moduleparam.h</strong>头文件，这样就可以<strong>在装载模块时向模块传递参数</strong>。</p>\n<p>尽管不是严格要求，模块应该指定所使用的许可证，例如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">MODULE_LICENSE(<span class=\"hljs-string\">&quot;GPL&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>内核可以识别</p>\n<ul>\n<li>GPL</li>\n<li>GPL v2</li>\n<li>GPL and additional rights</li>\n<li>Dual BSD&#x2F;GPL</li>\n<li>Dual MPL&#x2F;GPL</li>\n<li>Proprietary</li>\n</ul>\n<p>如果模块没有显式地标记为上述可识别的许可证，就会被假定是专有的，内核装在这种模块就会被“污染”。</p>\n<p>还可包含其他描述性定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">MODULE_AUTHOR<br>MODULE_DESCRIPTION<br>MODULE_VERSION<br>MODULE_ALIAS<br>MODULE_DEVICE_TABLE<br></code></pre></td></tr></table></figure>\n\n<p>这些MODULE_声明，一般<strong>放在文件的最后</strong>。</p>\n<h3 id=\"初始化和关闭\"><a href=\"#初始化和关闭\" class=\"headerlink\" title=\"初始化和关闭\"></a>初始化和关闭</h3><p>模块的<strong>初始化函数</strong>负责<strong>注册</strong>模块所提供的任何<strong>设施</strong>。这里的<strong>设施</strong>指的是一个可以被应用程序访问的新功能，例如一个完整的驱动程序或一个新的软件抽象。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">initialization_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-comment\">/*Initialization codes*/</span><br>&#125;<br><br>module_init(initialization_function);<br></code></pre></td></tr></table></figure>\n\n<p>初始化函数被声明为static，它在特定文件之外没有其他意义。但这并不是一个强制性规则，因为一个模块函数如果要对内核其他部分可见，则必须被显式导出。</p>\n<p>__init标记表明该函数仅在初始化期间使用。载模块被装载后，模块装载器会将初始化函数丢弃，以释放其占用的内存。__init和 __initdata很值得使用，但请注意，不要在结束初始化之后仍要使用的函数或数据上使用它们。</p>\n<p>module_init的使用是强制的。这个宏会在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置。</p>\n<p>模块可以注册许多不同类型的设施。对每种设施，对应有具体的内核函数用来完成注册。传递到内核注册函数的参数通常是指向用来描述新设施及设施名称的数据结构指针，而数据结构通常包含指向模块函数的指针。这样，模块中的函数就会在恰当的时间被内核调用。</p>\n<h4 id=\"清除函数\"><a href=\"#清除函数\" class=\"headerlink\" title=\"清除函数\"></a>清除函数</h4><p>每个重要的模块都需要一个清除函数，它在模块被移除前注销接口并向系统返回所有资源。该函数定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">cleanup_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-comment\">/*Cleanup codes*/</span><br>&#125;<br>module_exit(cleanup_function);<br></code></pre></td></tr></table></figure>\n\n<p>清除函数没有返回值。<br>__exit修饰词标记改代码仅用于模块卸载，编译器将把该函数放在特殊的ELF段中。被标记为__exit的函数只能在模块被卸载或者系统关闭时调用。</p>\n<p>module_exit声明帮助内核找到模块的清除函数。</p>\n<p>如果一个模块未定义清除函数，则内核不允许卸载该模块。</p>\n<h4 id=\"初始化过程中的错误处理\"><a href=\"#初始化过程中的错误处理\" class=\"headerlink\" title=\"初始化过程中的错误处理\"></a>初始化过程中的错误处理</h4><p>在内核中注册设施时，<strong>时刻铭记注册可能会失败</strong>。模块代码必须始终检查返回值，确保所有的操作已真正成功。</p>\n<p>如果在注册设施时遇到任何错误，首先要判断模块是否可以继续初始化。通常在某个注册失败后可以通过降低功能来继续运转。</p>\n<p>如果在发生了某个特定类型的错误之后无法继续装载模块，则要将出错之前的任何注册工作撤销掉。</p>\n<p>错误恢复的<strong>处理有时使用goto语句</strong>比较有效，可以避免大量复杂的、高度缩进的“结构化”逻辑。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">my_init_func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> err;<br>\t<span class=\"hljs-comment\">/*Register using pointers and names */</span><br>\terr = register_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_this;<br>\terr = register_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_that;<br>\terr = register_those(ptr3,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_those;<br>\t<span class=\"hljs-comment\">/*Success*/</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>fail_those:<br>\tunregister_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>fail_that:<br>\tunregister_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>fail_this:<br>\t<span class=\"hljs-keyword\">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上的代码再出错的时候使用goto语句，它将只撤销出错时刻以前所成功注册的那些设施。<br>my_init_module的返回值err是一个错误编码，它是定义在&lt;linux&#x2F;error.h&gt;中的负整数。每次返回合适的错误编码是一个好习惯。</p>\n<p>模块的清除函数需要撤销初始化函数所注册的所有设施，习惯上，以相反于注册的顺序撤销设施。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">my_cleanup_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tunregister_those(ptr3,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\tunregister_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\tunregister_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>每当发生错误时从初始化函数中调用清除函数</strong>，将减少代码的重复并使代码更清晰、更有条理。当然，清除函数<strong>必须在撤销每项设施的注册之前检查它的状态</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">something</span> *<span class=\"hljs-title\">item1</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">somethingelse</span> *<span class=\"hljs-title\">item2</span>;</span><br><span class=\"hljs-type\">int</span> stuff_ok;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">my_cleanup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(item1)<br>\t\trelease_thing(item1);<br>\t<span class=\"hljs-keyword\">if</span>(item2)<br>\t\trelease_thing2(item2);<br>\t<span class=\"hljs-keyword\">if</span>(stuff_ok)<br>\t\tunregister_stuff();<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">my_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> err = -ENOMEM;<br>\titem1 = allocate_thing(arguments);<br>\titem2 = allocate_thing2(arguments2);<br>\t<span class=\"hljs-keyword\">if</span>(!item1 || !item2)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail;<br>\terr = register_stuff(item1,item2);<br>\t<span class=\"hljs-keyword\">if</span>(!err)<br>\t\tstuff_ok = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tstuff_ok = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>fail:<br>\tmy_cleanup();<br>\t<span class=\"hljs-keyword\">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上代码中的初始化方式可以扩展到对大量设施的支持。需要注意的是，因为清除函数被非退出代码调用，因此<strong>不能将清除函数标记为__exit</strong>。</p>\n<h4 id=\"模块装载竞争\"><a href=\"#模块装载竞争\" class=\"headerlink\" title=\"模块装载竞争\"></a>模块装载竞争</h4><p>首先要始终铭记的是，<strong>在注册完成后，内核的某些部分可能会立即使用我们刚刚注册的任何设施</strong>。也就是说，<strong>初始化函数还在运行的时候，内核就完全可能调用我们的模块</strong>。</p>\n<p>所以，<strong>在首次注册完成后，代码就应该准备好被内核的其他部分调用，在用来支持某个设施的所有内部初始化完成之前，不要注册任何设施。</strong></p>\n<h3 id=\"模块参数\"><a href=\"#模块参数\" class=\"headerlink\" title=\"模块参数\"></a>模块参数</h3><p>由于系统的不同，<strong>驱动程序需要的参数也会发生变化</strong>，例如设备编号和一些用来控制驱动程序操作方式的参数。为满足这种需求，<strong>内核允许对驱动程序指定参数</strong>，而这些参数<strong>可在装载驱动程序模块时改变。</strong></p>\n<p>这些<strong>参数的值可在运行insmod或modprobe命令时赋值</strong>，而<strong>modprobe还可以从其配置文件（&#x2F;etc&#x2F;modprobe.conf）中读取参数值</strong>。这两个命令可以接受几种参数类型的赋值</p>\n<ul>\n<li>bool</li>\n<li>invbool：bool和invbool关联的变量应该是int类型</li>\n<li>charp：字符指针值。</li>\n<li>int</li>\n<li>long</li>\n<li>short</li>\n<li>uint</li>\n<li>ulong</li>\n<li>ushort</li>\n</ul>\n<p>在insmod改变模块参数之前，<strong>模块必须让这些参数对insmod命令可见</strong>。参数必须<strong>通过module_param宏来声明</strong>，它有三个参数</p>\n<ul>\n<li>变量的名称</li>\n<li>类型</li>\n<li>用于sysfs入口项的访问许可掩码</li>\n</ul>\n<p>这个宏<strong>必须放在任何函数之外</strong>，通常是在源文件的头部。</p>\n<p>模块的装载器<strong>也支持数组参数</strong>，在<strong>提供数组值时用逗号划分各数组成员</strong>。要声明数组参数，使用<strong>宏module_param_array(name,type,num,perm)<strong>。模块装载器会</strong>拒绝接受超过数组大小的值</strong>。</p>\n<p>如果我们<strong>需要的类型不在上面列出的清单中</strong>，可以使用<strong>模块代码中的钩子</strong>来定义这些类型。</p>\n<p><strong>所有模块参数都应给定一个默认值</strong>，insmod只会在用户明确设置了参数的值的情况下参会改变参数的值。</p>\n<p><strong>module_param的最后一个参数</strong>是访问许可值，它用来<strong>控制谁能访问sysfs中对模块参数的表述</strong></p>\n<ul>\n<li>如果perm被设置为0，就不会有对应的sysfs入口项</li>\n<li>否则模块参数会在sys&#x2F;module中出现，并设置为给定的访问许可</li>\n</ul>\n<p>如果一个参数通过sysfs被修改，内核不会以任何方式通知模块。大多数情况下，不应该让模块参数可写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/module.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/init.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/kernel.h&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *whom = <span class=\"hljs-string\">&quot;Mom&quot;</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> howmany = <span class=\"hljs-number\">1</span>;<br><br>module_param(howmany, <span class=\"hljs-type\">int</span>,   S_IRUGO);<br>module_param(whom,    charp, S_IRUGO);<br><br><span class=\"hljs-type\">static</span><br><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">m_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;parameters test module is loaded\\n&quot;</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; howmany; ++i) &#123;<br>\t\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;#%d Hello, %s\\n&quot;</span>, i, whom);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-type\">static</span><br><span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">m_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;parameters test module is unloaded\\n&quot;</span>);<br>&#125;<br><br>module_init(m_init);<br>module_exit(m_exit);<br><br>MODULE_LICENSE(<span class=\"hljs-string\">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class=\"hljs-string\">&quot;Bryan&quot;</span>);<br>MODULE_DESCRIPTION(<span class=\"hljs-string\">&quot;Module parameters test program&quot;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>直接使用insmod，装载模块</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span>sudo insmod module_parameters.ko <br>bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span>dmesg | tail <span class=\"hljs-number\">-10</span><br>[  <span class=\"hljs-number\">282.742416</span>] <span class=\"hljs-symbol\">raid6:</span> .... xor() <span class=\"hljs-number\">21210</span> <span class=\"hljs-title class_\">MB</span>/s, rmw enabled<br>[  <span class=\"hljs-number\">282.742417</span>] <span class=\"hljs-symbol\">raid6:</span> using avx2x2 recovery algorithm<br>[  <span class=\"hljs-number\">282.783190</span>] <span class=\"hljs-symbol\">xor:</span> automatically using best checksumming function   avx       <br>[  <span class=\"hljs-number\">282.877516</span>] <span class=\"hljs-title class_\">Btrfs</span> loaded, crc32c=crc32c-intel<br>[  <span class=\"hljs-number\">367.429218</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">378.711958</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">378.711959</span>] <span class=\"hljs-comment\">#0 Hello, Mom</span><br>[  <span class=\"hljs-number\">470.278217</span>] parameters test module is unloaded<br>bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span><br></code></pre></td></tr></table></figure>\n\n<p>使用insmod装载模块时，携带参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=<span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo rmmod module_parameters <br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ dmesg | tail <span class=\"hljs-number\">-10</span><br>[  <span class=\"hljs-number\">378.711959</span>] #<span class=\"hljs-number\">0</span> Hello, Mom<br>[  <span class=\"hljs-number\">470.278217</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">473.729918</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">473.729919</span>] #<span class=\"hljs-number\">0</span> Hello, Mom<br>[  <span class=\"hljs-number\">556.020495</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">578.373167</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">578.373168</span>] #<span class=\"hljs-number\">0</span> Hello, dady<br>[  <span class=\"hljs-number\">578.373168</span>] #<span class=\"hljs-number\">1</span> Hello, dady<br>[  <span class=\"hljs-number\">578.373169</span>] #<span class=\"hljs-number\">2</span> Hello, dady<br>[  <span class=\"hljs-number\">582.573809</span>] parameters test module is unloaded<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n<p>在insmod装载模块之前，在&#x2F;sys&#x2F;module目录下无法找到module_parameters目录</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters<br>ls: cannot access <span class=\"hljs-string\">&#x27;/sys/module/module_parameters&#x27;</span>: No such file or directory<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n<p>insmod装在模块后，可以在&#x2F;sys&#x2F;module目录下找到module_parameters目录，并在&#x2F;sys&#x2F;module&#x2F;module_parameters&#x2F;parameters目录下看到两个参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=<span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters<br>coresize  initsize   notes       refcnt    srcversion  uevent<br>holders   initstate  parameters  sections  taint<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters/parameters/<br>howmany  whom<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters/parameters/howmany <br>/sys/module/module_parameters/parameters/howmany<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ cat /sys/module/module_parameters/parameters/howmany <br><span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ cat /sys/module/module_parameters/parameters/whom <br>dady<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>我发现对于学习任何一门知识，在最开始只能背诵或抄写别人的一些总结，所以tyro阶段我会抄写一些别人的文章，进行复习总结。<br></p>\n<p>我记得小时候看过一部电影《心灵捕手》，虽然主线剧情不是我要说的，但我仍然记者记忆中有个桥段，Will在哈佛附近的酒吧遇到Skylar的时候，Will最铁的哥们查克冒充历史系学生和美女Skylar搭讪，但哈佛大学的学生克拉克看破了查克是冒牌货，于是过来考查克历史学知识，Will不止回答了这些知识，还输出了一顿自己的理解。我一直不明白，同为学生时代的我们，究竟会有什么差距呢，后来看到这一段，我才发现，只有能输出自己的东西才算是在这个领域有所了解了吧？所以tyro阶段我也只能摘抄一些别人消化的知识点，多希望我也能有一天输出自己的东西。</p>\n<p><img src=\"/imgs/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E5%BF%83%E7%81%B5%E6%8D%95%E6%89%8B.webp\"></p>\n<p><small>提到《心灵捕手》我又想到:<br><br>你年轻彪悍，我如果和你谈论战争，你大可以向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友”，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。不要以为，我了解你。也许我可以通过“知识”来看你，但那不是你，除非你愿意谈谈你自己，否则我不知道你到底是谁。有时候喜欢是一种非常简单的事，我没有进入过你的世界，只听你讲过自己的故事，你人生的前25年从未参与过，我喜欢的只是我所认识的25岁的你。我不知道为什么，我真真实实的做了一场梦，很久很久的梦，我把人生的25年从头过了一遍，非常真切的感受，30年的人生所有的故事主角都是你，我才发现，我的这份喜欢似乎是贯彻了这痛苦的一生。</small></p>\n<p><small>ANY WAY，写这些东西的时候我的状态是非常不好的，最近这两年我失去了爱我的外婆，得了很多很重的疾病，毕业选择的第一家公司在春招结束的时候解散了，还有一个她。在这之前我的世界没有什么情绪，对生活也没有热情，感谢她给我平庸的人生带来了一些阳光。让我捡起来对生活的热爱，谢谢你，u complete me。人生太多变化，不知道还能在一起多久，我们已经是家人了吧，不要忘记我奥，死亡不是真的逝去，遗忘才是永恒的消亡。</small></p>\n<h1 id=\"构造和运行模块\"><a href=\"#构造和运行模块\" class=\"headerlink\" title=\"构造和运行模块\"></a>构造和运行模块</h1><h3 id=\"内核模块与应用程序的对比\"><a href=\"#内核模块与应用程序的对比\" class=\"headerlink\" title=\"内核模块与应用程序的对比\"></a>内核模块与应用程序的对比</h3><p>大多数中小规模的应用程序是从头到尾执行单个任务。<strong>模块只是预先注册自己以便服务于将来的某个请求</strong>，然后其初始化函数立即结束，模块的退出函数将在模块被卸载之前调用。<strong>内核模块的编程方式和事件驱动的编程有些类似。</strong><br>应用程序在退出时可以不管资源的释放或其他的清除工作。但<strong>模块的退出函数必须仔细撤销初始化函数所作的一切</strong>，否则，在系统重新引导之前某些东西就会残留在系统中。<br>应用程序可以调用它并未定义的函数，因为连接过程能够解析外部引用从而使用适当的函数库。但<strong>模块仅被链接到内核，它能调用的函数仅仅是由内核导出的那些函数，而不存在任何可链接的函数库。</strong><br>模块源文件中不能包含通常的头文件，只能使用作为内核一部分的函数。<br>应用程序开发过程中的段错误是无害的，并且总是可以使用调试器跟踪到源代码中的问题所在；内核错误即使不影响整个系统，也至少会杀死当前进程。</p>\n<h4 id=\"可重入\"><a href=\"#可重入\" class=\"headerlink\" title=\"可重入\"></a>可重入</h4><p>可重入性作为多线程编程里面重要的概念，相信大家或多或少都听说过、研究过甚至使用过。目前很多资料都重点在介绍重入锁、CAS等概念，对“可重入性”本身的讲解不是很多，所以JavaCool给大家整理了一些“可重入性”的相关知识，希望能帮助到大家！</p>\n<ul>\n<li><p>可重入的定义<br>简单定义:”可以正确重复使用”，有两个关键：1，可以重复使用；2，并能正确使用。意味着在多次执行的时候能得到正确的值，并不受其他调用的影响。<br>官方定义：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。<br>这里也有一段比较好的英文阐释：<br>A computer program or routine is described as reentrant if it can be safely called again before its previous invocation has been completed (i.e it can be safely executed concurrently)<br>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>\n</li>\n<li><p>产生背景<br>可重入概念是在单线程操作系统的时代提出的。一个子程序的重入，可能由于自身原因，如执行了jmp或者call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX系统的signal的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。</p>\n</li>\n<li><p>编写可重入代码注意的条件<br>若一个函数是可重入的，则该函数应当满足下述条件：</p>\n</li>\n</ul>\n<p>不能含有静态（全局）非常量数据。<br>不能返回静态（全局）非常量数据的地址。<br>只能处理由调用者提供的数据。<br>不能依赖于单实例模式资源的锁。<br>调用(call)的函数也必需是可重入的。<br>上述条件就是要求可重入函数使用的所有变量都保存在呼叫堆叠的当前函数栈（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。</p>\n<p>多“用户&#x2F;对象&#x2F;进程优先级”以及多进程（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似编程中的静态、全域）资源。</p>\n<ul>\n<li>与线程安全的关系<br>可重入与线程安全两个概念都关系到函数处理资源的方式。但是，他们有重大区别：可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入同步机制以保护共享的资源，使之不会被几个线程同时访问。</li>\n</ul>\n<p>操作系统背景与CPU调度策略：<br>可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。</p>\n<p>多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的时间片，不断向前推进执行进度。可重入函数未必是线程安全的；线程安全函数未必是可重入的。</p>\n<p>例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。<br>另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。fprintf函数就是线程安全但不可重入。</p>\n<ul>\n<li>可重入锁<br>可重入锁也叫递归锁，它俩等同于一回事，指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，同一线程在外层方法获取锁的时候，再进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock 和 synchronized 就是典型的可重入锁！</li>\n</ul>\n<p><strong>操作系统的作用</strong>是</p>\n<ul>\n<li>为应用程序提供一个对计算机硬件的一致视图</li>\n<li>负责程序的独立操作并保护资源不受非法访问。该任务只有在CPU能够保护系统软件不受应用程序破坏时才能完成。</li>\n</ul>\n<p>人们在CPU中实现不同的操作模式（或者级别）。不同的级别具有不同的功能，在较低的级别中将禁止某些操作。程序代码只能通过有限数目的“门” 从一个级别切换到另一级别。Unix使用了两个这样的级别：内核运行在最高级别（也称作超级用户态），可以进行所有操作；应用程序运行在最低级别（即所谓的用户态），处理器控制着对硬件的直接访问以及对内存的非授权访问。两种模式具有不同的优先权等级，每个模式都有自己的内存映射，即自己的地址空间。</p>\n<p>应用程序执行系统调用或者被硬件中断挂起时，Unix将执行模式从用户空间切换到内核空间</p>\n<ul>\n<li>执行系统调用的内核代码运行在进程上下文中，它代表用户进程执行操作，因此可以访问进程地址空间的所有数据</li>\n<li>处理硬件中断的内核代码和进程是异步的，与任何一个特定进程无关。</li>\n</ul>\n<p>一个驱动程序通常要执行两类任务</p>\n<ul>\n<li>某些函数作为系统调用的一部分而执行</li>\n<li>其他函数负责中断处理</li>\n</ul>\n<h3 id=\"内核中的并发\"><a href=\"#内核中的并发\" class=\"headerlink\" title=\"内核中的并发\"></a>内核中的并发</h3><p>内核编程区别于常见应用程序编程的地方在于对并发的处理。即使是最简单的内核模块，都需要在编写时铭记：同一时刻，可能会有许多事情正在发生。</p>\n<h5 id=\"内核编程必须考虑并发的原因\"><a href=\"#内核编程必须考虑并发的原因\" class=\"headerlink\" title=\"内核编程必须考虑并发的原因\"></a>内核编程必须考虑并发的原因</h5><ul>\n<li><p>Linux系统中通常正在运行多个并发进程，他们可能同时使用我们的驱动程序。</p>\n</li>\n<li><p>大多数设备能够中断处理器，而中断处理程序异步运行，而且可能在驱动程序试图处理其他任务时被调用。</p>\n</li>\n<li><p>一些抽象软件，例如内核定时器，也在异步运行。</p>\n</li>\n<li><p>Linux可以运行在SMP系统上，可能同时有不止一个CPU运行我们的驱动程序。</p>\n</li>\n<li><p>在2.6中内核代码已经是可抢占的，意味着即使在单处理器系统上也存在许多类似多处理器系统的并发问题。</p>\n</li>\n</ul>\n<p>Linux内核代码（包括驱动程序代码）必须是可重入的，它必须能够同时运行在多个上下文中。对编写正确的内核代码来说，优良的并发管理是必需的。</p>\n<h4 id=\"当前进程\"><a href=\"#当前进程\" class=\"headerlink\" title=\"当前进程\"></a>当前进程</h4><p>虽然内核模块不像应用程序那样顺序执行，然而内核执行的大多数操作还是和某个特定的进程相关。<br>内核代码可通过访问全局项current来获得当前进程。它是一个指向struct task_struct的指针。current指针指向当前正在运行的进程。内核代码可以通过current获得与当前进程相关的信息。例如，下面的语句通过访问struct task_struct的某些成员来打印当前进程的ID和命令名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">printk(KERN_INFO <span class=\"hljs-string\">&quot;The process is \\&quot; %s \\&quot; (pid %i)\\n&quot;</span>,<br>current-&gt;common,current-&gt;pid);<br></code></pre></td></tr></table></figure>\n\n<p>为了支持SMP系统，内核开发这设计了一种能找到运行在相关CPU上的当前进程的机制。它必须是快速的，因为对current的引用会很频繁。一种不依赖于特定架构的机制通常是，<strong>将指向task_struct结构的指针隐藏在内核栈中</strong>。</p>\n<h2 id=\"编译和装载\"><a href=\"#编译和装载\" class=\"headerlink\" title=\"编译和装载\"></a>编译和装载</h2><h3 id=\"编译模块\"><a href=\"#编译模块\" class=\"headerlink\" title=\"编译模块\"></a>编译模块</h3><p>内核是一个大的、独立的程序，为了将它的各个片段放在一起，要满足很多详细而明确的要求。</p>\n<p>在构造内核模块之前，有一些先决条件首先应该得到满足</p>\n<ul>\n<li>确保具备正确版本的编译器、模块工具和其他必要的工具（Documentation&#x2F;Changes文件）。注意：使用太新的工具也偶尔会导致问题。</li>\n<li>准备内核树，配置并构造内核。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">obj-m := hello.o<br></code></pre></td></tr></table></figure>\n\n<p>上面的赋值语句（它利用了GNU make的扩展语法）说明了有一个模块需要从目标文件hello.o中构造，而从该目标文件中构造的模块名称为hello.ko。</p>\n<p>如果要构造的模块名称为module.ko，并由两个源文件生成（file1.c和file2.c），那么makefile可编写如下</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">obj-m := module.o<br>module-objs := file1.o file2.o<br></code></pre></td></tr></table></figure>\n\n<p>为了让上面这种类型的makefile文件正常工作，<strong>必须在大的内核构造系统环境中调用它们</strong>。如果内核源代码树保存在~&#x2F;kernel-2.6目录，则用来构造模块的make命令（在包含模块代码和makefile的目录中输入）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">make -C ~/kernel-2.6 M=`pwd` modules<br></code></pre></td></tr></table></figure>\n\n<p>上述命令<strong>首先改变目录到内核源代码目录</strong>，该目录保存由内核的顶层makefile文件。<strong>M&#x3D;选项</strong>让该makefile在构造modules目标之前返回到模块源代码目录。然后，<strong>modules目标指向obj-m变量中设定的模块</strong>。</p>\n<p>另一种makefile方法，可以使得<strong>内核树之外的模块构造</strong>更加容易。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># If KERNELRELEASE is defined, we&#x27;ve been invoked from the</span><br><span class=\"hljs-comment\"># kernel build system and can use its language.</span><br><span class=\"hljs-keyword\">ifneq</span> (<span class=\"hljs-variable\">$(KERNELRELEASE)</span>,)<br>    hello_world-objs := main.o<br>    obj-m := hello_world.o<br><br><span class=\"hljs-comment\"># Otherwise we were called directly from the command</span><br><span class=\"hljs-comment\"># line; invoke the kernel build system.</span><br><span class=\"hljs-keyword\">else</span><br>    KERNELDIR ?= /lib/modules/<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">shell</span> uname -r)</span>/build<br>    PWD := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">shell</span> pwd)</span><br><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: modules</span><br><span class=\"hljs-section\">modules:</span><br>\t<span class=\"hljs-variable\">$(MAKE)</span> -C <span class=\"hljs-variable\">$(KERNELDIR)</span> M=<span class=\"hljs-variable\">$(PWD)</span> modules<br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: clean</span><br><span class=\"hljs-section\">clean:</span><br>\t<span class=\"hljs-variable\">$(MAKE)</span> -C <span class=\"hljs-variable\">$(KERNELDIR)</span> M=<span class=\"hljs-variable\">$(PWD)</span> clean<br><br></code></pre></td></tr></table></figure>\n\n<p>在一个典型的构造过程中，该makefile将被读取两次。当makefile从命令行运调用时，KERNELRELEASE变量并未设置，这个makefile通过已安装的模块目录中指向内核构造树的符号链接，定位内核的源代码目录。如果实际运行的内核并不是要构造的内核，则可以在命令行提供KENELDIR&#x3D;选项或者设置KERNELDIR环境变量，也可以修改makfile中用来设置KERNELDIR的行。找到内核源代码树之后，这个makefile会调用modules目标，通过之前描述的方法第二次运行make命令，以便运行内核构建系统。</p>\n<h3 id=\"装载和卸载模块\"><a href=\"#装载和卸载模块\" class=\"headerlink\" title=\"装载和卸载模块\"></a>装载和卸载模块</h3><p><strong>insmod</strong>将模块装入内核。它将模块的代码和数据装入内核，然后使用内核的符号表解析模块中任何为解析的符号。与链接器不同，内核不会修改模块的磁盘文件，仅仅修改内存中的副本。insmod可以接受一些命令行选项，可以在模块链接到内核之前给模块中的整型和字符串变量赋值。一个设计良好的模块，可以在装载时进行配置。</p>\n<p>函数<strong>sys_init_module</strong>给模块分配内核内存。有且只有系统调用的名字前带有sys_前缀。</p>\n<p><strong>modprobe</strong>也用来将模块装载到内核中。它与insmod的区别在于，会考虑要装载的模块是否引用了一些当前内核不存在的符号。如果存在这类引用，它会在当前模块搜索路径中查找定义了这些符号的其他模块。如果它找到了这些模块，则会同时将它们装载到内核。</p>\n<p><strong>rmmod</strong>可以从内核中移除模块。如果内核认为模块仍在使用状态或者内核被配置为禁止移除模块，则无法移除该模块。</p>\n<p><strong>lsmod</strong>列出当前装载到内核中的所有模块，它通过读取&#x2F;proc&#x2F;modules文件获得这些信息。有关当前已装载模块的信息也可以在&#x2F;sys&#x2F;module下找到。</p>\n<h3 id=\"版本依赖\"><a href=\"#版本依赖\" class=\"headerlink\" title=\"版本依赖\"></a>版本依赖</h3><p>在缺少modversion的情况下，我们的<strong>模块代码必须针对要链接的每个版本的内核重新编译</strong>。<strong>模块和特定的内核版本定义的数据结构和函数原型紧密关联</strong>。</p>\n<p>内核不会假定一个给定的模块是针对正确的内核版本构造的。在构造过程中，<strong>可以将自己的模块和vermagic.o链接</strong>。该目标文件包含了大量有关内核的信息，在试图装载模块时，这些信息可以用来检查模块和正在运行的内核的兼容性。</p>\n<p>如果打算编写一个<strong>能够和多个内核版本一起工作的模块</strong>，则必须<strong>使用宏以及#ifdef</strong>来构造并编译自己的代码。</p>\n<ul>\n<li>UTS_RELEASE，该宏扩展为一个描述内核版本的字符串</li>\n<li>LINUX_VERSION_CODE，该宏扩展为为内核版本的二进制表示，版本发行号中的每一部分对应一个字节</li>\n<li>KERNEL_VERSION(major,minor,release)，该宏以组成版本号的三个部分，创建整数的版本号</li>\n</ul>\n<p><strong>不应随意使用#ifdef条件语句</strong>将驱动程序代码弄得杂乱无章。最好的一个解决方法就是<strong>将所有相关的预处理条件语句集中存放在一个特定的头文件中</strong>。一般而言，<strong>依赖于特定版本的代码应该隐藏在低层宏或函数之中</strong>。</p>\n<h3 id=\"平台依赖\"><a href=\"#平台依赖\" class=\"headerlink\" title=\"平台依赖\"></a>平台依赖</h3><p>如果模块和某个给定内核工作，它也<strong>必须和内核一样了解目标处理器</strong>。通过<strong>链接vermagic.o</strong>，在装载模块时，内核会检查处理器相关的配置选项以便确保模块匹配于运行中的内核。</p>\n<h3 id=\"内核符号表\"><a href=\"#内核符号表\" class=\"headerlink\" title=\"内核符号表\"></a>内核符号表</h3><p>insmod使用<strong>公共内核符号表</strong>来解析模块中未定义的符号。<strong>公共内核符号表</strong>包含了<strong>所有的全局内核项（函数和变量）的地址</strong>，它是实现模块化驱动程序所必须的。</p>\n<p>当模块被装入内核后，它所<strong>导出的任何符号</strong>都会变成内核符号表的一部分。通常情况下，模块只需实现自己的功能，而无需导出任何符号。如果其他模块要从某个模块获得好处，则需要导出符号。这样就可以在其他模块上<strong>层叠新的模块</strong>，即<strong>模块层叠技术</strong>。</p>\n<p>如果一个模块要向其他模块导出符号，则应该使用下面的宏</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">EXPORT_SYMBOL(name);<br>EXPORT_SYMBOL_GPL(name);<br></code></pre></td></tr></table></figure>\n\n<p>GPL版本使得要导出的模块只能被GPL许可证下的模块使用。<strong>符号必须在模块文件的全局部分导出</strong>，不能在函数中导出。</p>\n<h3 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h3><p>内核是一个特定的环境，对需要和它接口的代码有其自己的一些要求。</p>\n<p>所有的模块代码中都包含下面两行代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/module.h&gt;</span> </span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/init.h&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>module.h</strong>包含可装载模块需要的大量符号和函数的定义。<strong>init.h</strong>是为了指定初始化和清除函数。</p>\n<p>大部分模块还包含<strong>moduleparam.h</strong>头文件，这样就可以<strong>在装载模块时向模块传递参数</strong>。</p>\n<p>尽管不是严格要求，模块应该指定所使用的许可证，例如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">MODULE_LICENSE(<span class=\"hljs-string\">&quot;GPL&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>内核可以识别</p>\n<ul>\n<li>GPL</li>\n<li>GPL v2</li>\n<li>GPL and additional rights</li>\n<li>Dual BSD&#x2F;GPL</li>\n<li>Dual MPL&#x2F;GPL</li>\n<li>Proprietary</li>\n</ul>\n<p>如果模块没有显式地标记为上述可识别的许可证，就会被假定是专有的，内核装在这种模块就会被“污染”。</p>\n<p>还可包含其他描述性定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">MODULE_AUTHOR<br>MODULE_DESCRIPTION<br>MODULE_VERSION<br>MODULE_ALIAS<br>MODULE_DEVICE_TABLE<br></code></pre></td></tr></table></figure>\n\n<p>这些MODULE_声明，一般<strong>放在文件的最后</strong>。</p>\n<h3 id=\"初始化和关闭\"><a href=\"#初始化和关闭\" class=\"headerlink\" title=\"初始化和关闭\"></a>初始化和关闭</h3><p>模块的<strong>初始化函数</strong>负责<strong>注册</strong>模块所提供的任何<strong>设施</strong>。这里的<strong>设施</strong>指的是一个可以被应用程序访问的新功能，例如一个完整的驱动程序或一个新的软件抽象。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">initialization_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-comment\">/*Initialization codes*/</span><br>&#125;<br><br>module_init(initialization_function);<br></code></pre></td></tr></table></figure>\n\n<p>初始化函数被声明为static，它在特定文件之外没有其他意义。但这并不是一个强制性规则，因为一个模块函数如果要对内核其他部分可见，则必须被显式导出。</p>\n<p>__init标记表明该函数仅在初始化期间使用。载模块被装载后，模块装载器会将初始化函数丢弃，以释放其占用的内存。__init和 __initdata很值得使用，但请注意，不要在结束初始化之后仍要使用的函数或数据上使用它们。</p>\n<p>module_init的使用是强制的。这个宏会在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置。</p>\n<p>模块可以注册许多不同类型的设施。对每种设施，对应有具体的内核函数用来完成注册。传递到内核注册函数的参数通常是指向用来描述新设施及设施名称的数据结构指针，而数据结构通常包含指向模块函数的指针。这样，模块中的函数就会在恰当的时间被内核调用。</p>\n<h4 id=\"清除函数\"><a href=\"#清除函数\" class=\"headerlink\" title=\"清除函数\"></a>清除函数</h4><p>每个重要的模块都需要一个清除函数，它在模块被移除前注销接口并向系统返回所有资源。该函数定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">cleanup_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-comment\">/*Cleanup codes*/</span><br>&#125;<br>module_exit(cleanup_function);<br></code></pre></td></tr></table></figure>\n\n<p>清除函数没有返回值。<br>__exit修饰词标记改代码仅用于模块卸载，编译器将把该函数放在特殊的ELF段中。被标记为__exit的函数只能在模块被卸载或者系统关闭时调用。</p>\n<p>module_exit声明帮助内核找到模块的清除函数。</p>\n<p>如果一个模块未定义清除函数，则内核不允许卸载该模块。</p>\n<h4 id=\"初始化过程中的错误处理\"><a href=\"#初始化过程中的错误处理\" class=\"headerlink\" title=\"初始化过程中的错误处理\"></a>初始化过程中的错误处理</h4><p>在内核中注册设施时，<strong>时刻铭记注册可能会失败</strong>。模块代码必须始终检查返回值，确保所有的操作已真正成功。</p>\n<p>如果在注册设施时遇到任何错误，首先要判断模块是否可以继续初始化。通常在某个注册失败后可以通过降低功能来继续运转。</p>\n<p>如果在发生了某个特定类型的错误之后无法继续装载模块，则要将出错之前的任何注册工作撤销掉。</p>\n<p>错误恢复的<strong>处理有时使用goto语句</strong>比较有效，可以避免大量复杂的、高度缩进的“结构化”逻辑。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">my_init_func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> err;<br>\t<span class=\"hljs-comment\">/*Register using pointers and names */</span><br>\terr = register_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_this;<br>\terr = register_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_that;<br>\terr = register_those(ptr3,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span>(err)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail_those;<br>\t<span class=\"hljs-comment\">/*Success*/</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>fail_those:<br>\tunregister_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>fail_that:<br>\tunregister_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>fail_this:<br>\t<span class=\"hljs-keyword\">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上的代码再出错的时候使用goto语句，它将只撤销出错时刻以前所成功注册的那些设施。<br>my_init_module的返回值err是一个错误编码，它是定义在&lt;linux&#x2F;error.h&gt;中的负整数。每次返回合适的错误编码是一个好习惯。</p>\n<p>模块的清除函数需要撤销初始化函数所注册的所有设施，习惯上，以相反于注册的顺序撤销设施。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">my_cleanup_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tunregister_those(ptr3,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\tunregister_that(ptr2,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\tunregister_this(ptr1,<span class=\"hljs-string\">&quot;skull&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>每当发生错误时从初始化函数中调用清除函数</strong>，将减少代码的重复并使代码更清晰、更有条理。当然，清除函数<strong>必须在撤销每项设施的注册之前检查它的状态</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">something</span> *<span class=\"hljs-title\">item1</span>;</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">somethingelse</span> *<span class=\"hljs-title\">item2</span>;</span><br><span class=\"hljs-type\">int</span> stuff_ok;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">my_cleanup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(item1)<br>\t\trelease_thing(item1);<br>\t<span class=\"hljs-keyword\">if</span>(item2)<br>\t\trelease_thing2(item2);<br>\t<span class=\"hljs-keyword\">if</span>(stuff_ok)<br>\t\tunregister_stuff();<br>\t<span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">my_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> err = -ENOMEM;<br>\titem1 = allocate_thing(arguments);<br>\titem2 = allocate_thing2(arguments2);<br>\t<span class=\"hljs-keyword\">if</span>(!item1 || !item2)<br>\t\t<span class=\"hljs-keyword\">goto</span> fail;<br>\terr = register_stuff(item1,item2);<br>\t<span class=\"hljs-keyword\">if</span>(!err)<br>\t\tstuff_ok = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tstuff_ok = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>fail:<br>\tmy_cleanup();<br>\t<span class=\"hljs-keyword\">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上代码中的初始化方式可以扩展到对大量设施的支持。需要注意的是，因为清除函数被非退出代码调用，因此<strong>不能将清除函数标记为__exit</strong>。</p>\n<h4 id=\"模块装载竞争\"><a href=\"#模块装载竞争\" class=\"headerlink\" title=\"模块装载竞争\"></a>模块装载竞争</h4><p>首先要始终铭记的是，<strong>在注册完成后，内核的某些部分可能会立即使用我们刚刚注册的任何设施</strong>。也就是说，<strong>初始化函数还在运行的时候，内核就完全可能调用我们的模块</strong>。</p>\n<p>所以，<strong>在首次注册完成后，代码就应该准备好被内核的其他部分调用，在用来支持某个设施的所有内部初始化完成之前，不要注册任何设施。</strong></p>\n<h3 id=\"模块参数\"><a href=\"#模块参数\" class=\"headerlink\" title=\"模块参数\"></a>模块参数</h3><p>由于系统的不同，<strong>驱动程序需要的参数也会发生变化</strong>，例如设备编号和一些用来控制驱动程序操作方式的参数。为满足这种需求，<strong>内核允许对驱动程序指定参数</strong>，而这些参数<strong>可在装载驱动程序模块时改变。</strong></p>\n<p>这些<strong>参数的值可在运行insmod或modprobe命令时赋值</strong>，而<strong>modprobe还可以从其配置文件（&#x2F;etc&#x2F;modprobe.conf）中读取参数值</strong>。这两个命令可以接受几种参数类型的赋值</p>\n<ul>\n<li>bool</li>\n<li>invbool：bool和invbool关联的变量应该是int类型</li>\n<li>charp：字符指针值。</li>\n<li>int</li>\n<li>long</li>\n<li>short</li>\n<li>uint</li>\n<li>ulong</li>\n<li>ushort</li>\n</ul>\n<p>在insmod改变模块参数之前，<strong>模块必须让这些参数对insmod命令可见</strong>。参数必须<strong>通过module_param宏来声明</strong>，它有三个参数</p>\n<ul>\n<li>变量的名称</li>\n<li>类型</li>\n<li>用于sysfs入口项的访问许可掩码</li>\n</ul>\n<p>这个宏<strong>必须放在任何函数之外</strong>，通常是在源文件的头部。</p>\n<p>模块的装载器<strong>也支持数组参数</strong>，在<strong>提供数组值时用逗号划分各数组成员</strong>。要声明数组参数，使用<strong>宏module_param_array(name,type,num,perm)<strong>。模块装载器会</strong>拒绝接受超过数组大小的值</strong>。</p>\n<p>如果我们<strong>需要的类型不在上面列出的清单中</strong>，可以使用<strong>模块代码中的钩子</strong>来定义这些类型。</p>\n<p><strong>所有模块参数都应给定一个默认值</strong>，insmod只会在用户明确设置了参数的值的情况下参会改变参数的值。</p>\n<p><strong>module_param的最后一个参数</strong>是访问许可值，它用来<strong>控制谁能访问sysfs中对模块参数的表述</strong></p>\n<ul>\n<li>如果perm被设置为0，就不会有对应的sysfs入口项</li>\n<li>否则模块参数会在sys&#x2F;module中出现，并设置为给定的访问许可</li>\n</ul>\n<p>如果一个参数通过sysfs被修改，内核不会以任何方式通知模块。大多数情况下，不应该让模块参数可写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/module.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/init.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/kernel.h&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *whom = <span class=\"hljs-string\">&quot;Mom&quot;</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> howmany = <span class=\"hljs-number\">1</span>;<br><br>module_param(howmany, <span class=\"hljs-type\">int</span>,   S_IRUGO);<br>module_param(whom,    charp, S_IRUGO);<br><br><span class=\"hljs-type\">static</span><br><span class=\"hljs-type\">int</span> __init <span class=\"hljs-title function_\">m_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;parameters test module is loaded\\n&quot;</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; howmany; ++i) &#123;<br>\t\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;#%d Hello, %s\\n&quot;</span>, i, whom);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-type\">static</span><br><span class=\"hljs-type\">void</span> __exit <span class=\"hljs-title function_\">m_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tprintk(KERN_WARNING <span class=\"hljs-string\">&quot;parameters test module is unloaded\\n&quot;</span>);<br>&#125;<br><br>module_init(m_init);<br>module_exit(m_exit);<br><br>MODULE_LICENSE(<span class=\"hljs-string\">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class=\"hljs-string\">&quot;Bryan&quot;</span>);<br>MODULE_DESCRIPTION(<span class=\"hljs-string\">&quot;Module parameters test program&quot;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>直接使用insmod，装载模块</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span>sudo insmod module_parameters.ko <br>bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span>dmesg | tail <span class=\"hljs-number\">-10</span><br>[  <span class=\"hljs-number\">282.742416</span>] <span class=\"hljs-symbol\">raid6:</span> .... xor() <span class=\"hljs-number\">21210</span> <span class=\"hljs-title class_\">MB</span>/s, rmw enabled<br>[  <span class=\"hljs-number\">282.742417</span>] <span class=\"hljs-symbol\">raid6:</span> using avx2x2 recovery algorithm<br>[  <span class=\"hljs-number\">282.783190</span>] <span class=\"hljs-symbol\">xor:</span> automatically using best checksumming function   avx       <br>[  <span class=\"hljs-number\">282.877516</span>] <span class=\"hljs-title class_\">Btrfs</span> loaded, crc32c=crc32c-intel<br>[  <span class=\"hljs-number\">367.429218</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">378.711958</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">378.711959</span>] <span class=\"hljs-comment\">#0 Hello, Mom</span><br>[  <span class=\"hljs-number\">470.278217</span>] parameters test module is unloaded<br>bryan<span class=\"hljs-variable\">@ubuntu</span><span class=\"hljs-symbol\">:~/Desktop/Linux-Device-Driver-master/</span><span class=\"hljs-number\">02_</span>module_parameters<span class=\"hljs-variable\">$ </span><br></code></pre></td></tr></table></figure>\n\n<p>使用insmod装载模块时，携带参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=<span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo rmmod module_parameters <br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ dmesg | tail <span class=\"hljs-number\">-10</span><br>[  <span class=\"hljs-number\">378.711959</span>] #<span class=\"hljs-number\">0</span> Hello, Mom<br>[  <span class=\"hljs-number\">470.278217</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">473.729918</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">473.729919</span>] #<span class=\"hljs-number\">0</span> Hello, Mom<br>[  <span class=\"hljs-number\">556.020495</span>] parameters test module is unloaded<br>[  <span class=\"hljs-number\">578.373167</span>] parameters test module is loaded<br>[  <span class=\"hljs-number\">578.373168</span>] #<span class=\"hljs-number\">0</span> Hello, dady<br>[  <span class=\"hljs-number\">578.373168</span>] #<span class=\"hljs-number\">1</span> Hello, dady<br>[  <span class=\"hljs-number\">578.373169</span>] #<span class=\"hljs-number\">2</span> Hello, dady<br>[  <span class=\"hljs-number\">582.573809</span>] parameters test module is unloaded<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n<p>在insmod装载模块之前，在&#x2F;sys&#x2F;module目录下无法找到module_parameters目录</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters<br>ls: cannot access <span class=\"hljs-string\">&#x27;/sys/module/module_parameters&#x27;</span>: No such file or directory<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n<p>insmod装在模块后，可以在&#x2F;sys&#x2F;module目录下找到module_parameters目录，并在&#x2F;sys&#x2F;module&#x2F;module_parameters&#x2F;parameters目录下看到两个参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ sudo insmod module_parameters.ko  whom=dady howmany=<span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters<br>coresize  initsize   notes       refcnt    srcversion  uevent<br>holders   initstate  parameters  sections  taint<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters/parameters/<br>howmany  whom<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ ls /sys/module/module_parameters/parameters/howmany <br>/sys/module/module_parameters/parameters/howmany<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ cat /sys/module/module_parameters/parameters/howmany <br><span class=\"hljs-number\">3</span><br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ cat /sys/module/module_parameters/parameters/whom <br>dady<br>bryan@ubuntu:~/Desktop/Linux-Device-Driver-master/<span class=\"hljs-number\">02</span>_module_parameters$ <br></code></pre></td></tr></table></figure>\n\n"},{"title":"深度学习分享","date":"2023-10-01T08:34:29.000Z","typora-root-url":"./..","_content":"\n深度学习分享：\n\n你怎么不找我说话啊！！！！20231002-15：06\n\n俩小时了，好难熬啊！！！！20231002-17：07\n\n怎么通俗易懂的给从没有接触过深度学习的同事们介绍深度学习，是个让人非常头疼的问题。\n\n<small>为了让各位前辈更迅速更简单的了解深度学习，我将大量的其他信息都进行了过滤，我们只聊最简单最基础最能抓住这些信息的东西，所有我对大量的内容进行了删除，总结。如果深入理解，有一些说法是不那么正确的。</small>\n\n## 机器学习\n\n机器学习，顾名思义，机器具备有学习的能力。具体来讲，机器学习就是让机器具备找一个函数的能力。\n\n以图像识别为例，图像识别函数的输入是一张图片，输出是这个图片里面的内容。根据要找的函数不同，机器学习有不同的类别。\n\n- 假设要找的函数的输出是一个数值，这种机器学习的任务称为回归。\n- 函数的输出就是从设定好的选项里面选择一个当作输出，该任务称为分类。\n\n机器学习找函数的过程，分成3 个步骤。\n\n**第一个步骤**是写出一个带有未知参数的函数$f$，其能预测未来点击次数。比如将函数写成\n$$\ny = b + wx_1\n$$\n其中$y$是要预测的东西，$x_1$是输入的数据，而$w$跟$b$是未知的，$w$称为权重，$b$称为偏置。\n\n**第二个步骤**是定义损失（loss），损失也是一个函数。这个函数的输入是模型里面的参数，模型是$y = b + w ∗ x1$，而$b $跟$w $是未知的，损失是函数$L(b,w)$，其输入是模型参数$b $跟$w$，假设真是的结果是$\\hat{y}$。\n\n每一个数据的预测差距可以这么表示：\n$$\ne_i=|y-\\hat{y}|\n$$\n把所有数据的差距加起来求平均就是损失：\n$$\nL=\\frac{1}{N} \\sum_{n}\n$$\n**第三个步骤**是找到一个最优解，找到一个$w$跟$b$能让损失尽可能小，让预测的结果跟真实的结果尽可能接近。\n\n![](/imgs/深度学习/损失L.jpg)\n\nw在不同大小的时候会有不同的损失，为了让损失尽可能小，需要先随机找到一个初始点$w^0$，$w^0$就是这个时刻的切线斜率。\n\n把$w0 $往右移一步，新的位置为$w1$，这一步的步伐是$η(学习率) $乘上$L$关于$w$的偏微分的结果就是：\n$$\nw^1 << w^0-η\\frac{\\partial{L}}{\\partial{w}}|(w=w^0)\n$$\n接下来反复进行刚才的操作，最终求得最优解。当然这其中有很多策略和其他的知识点，对于我们要简单的了解深度学习来说是不需要探讨的。\n\n所以各位前辈大概已经清楚了机器学习损失反向传播的一种大致思维，这种反复对损失进行优化的过程，我们就把他简单的看成一个训练过程。\n\n## 深度学习\n\n对于我们简单的了解深度学习来说，我们这里不讨论：过拟合、优化问题、交叉验证、局部极小值与鞍点、批量与动量、自适应与学习率。我们从全局来了解深度学习网络方便我们对CAI（生成式AI有所了解）。\n\n深度学习是机器学习的一个分支(最重要的分支)，我们之前假设机器学习就是简单的一个函数处理优化流程，这只是我总结的一个大貌，但各位前辈们如果有意深入了解会发现机器学习包含很多东西，我的总结也并不全对。\n\n这里我们假设深度学习是要处理信息的“水流”，处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。\n\n这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。\n\n而这一个一个的小水管都是可控制他们的水流速度，水流体积。我们也可以把每一个水管都当作一个函数，控制水流就靠w和b，而这些一个一个小函数，小的神经单元组成一个大的函数，大的神经网络。\n\n![](/imgs/深度学习/深度网络.png)\n\n那么这么复杂的网络它带来的第一个优势就是他的学习能力强，表示覆盖的范围广，也同事让深度学习对计算量这些要求比较高。\n\n## 卷积神经网络\n\n我们从卷积神经网络（Convolutional Neural Network，CNN）开始，探讨网络的架构设计。卷积神经网络是一种非常典型的网络架构，常用于图像的处理等任务。\n\n对于卷积神经网络来说，我们不考虑池化下采样、上采样、反向传播这些内容，仅仅是了解它大致的一个处理思路。\n\n我们从一个图像分类任务入手，所谓图像分类，就是给机器一张图像，由机器去判断这张图像里面有什么样的东西——是猫还是狗、是飞机还是汽车。\n\n而怎么把图像作为模型的输入呢？？对于机器，图像可以描述为三维张量（我们可以把这个张量看作一个浮点型多维矩阵，存储在Double类型的数组里）。一张图像是一个三维的张量，其中一维代表图像的宽，另外一维代表图像的高，还有一维代表图像的通道（channel）的数目。\n\n<small>channel是什么：彩色图像的每个像素都可以描述为红色（red）、绿色（green）、蓝色（blue）的组合，这3 种颜色就称为图像的3 个色彩通.</small>\n\n![](/imgs/深度学习/图像输入.jpg)\n\n我们可以看到把一个100$\\times$100像素的图片分解为rgb三个通道后，再把每个像素看成一个元素$x_i$，将这些元素展开拉平到一个1维数组中去，这个数组大小就是100$\\times$100$\\times$3。\n\n![](/imgs/深度学习/CNN输入到网络.jpg)\n\n对一个图像识别的类神经网络里面的神经元（每个水龙头）而言，它要做的就是检测图像里面有没有出现一些特别重要的模式（pattern），这些模式是代表了某种物件的。\n\n举例来说，如果现在有三个神经元分别看到鸟嘴、眼睛、鸟爪3 个模式，这就代表类神经网络看到了一只鸟。\n\n![](/imgs/深度学习/鸟识别1.jpg)\n\n为了方便大家理解我们可以我用像素画了一只鸟，和一个过滤器来给大家演示。\n\n![](/imgs/深度学习/鸟.png)\n\n我用visio随便画了只鸟，空白的格子我们姑且让他的值为0，右侧的卷积核（水龙头）通过一步步滑动窗口对图像矩阵的元素进行比对。\n\n![image-20231003142939167](/imgs/深度学习/移动1)\n\n![image-20231003143036998](/imgs/深度学习/移动2)\n\n最终找到极其相似的值，如下图所示：\n\n![image-20231003143105899](/imgs/深度学习/移动3)\n\n这样就是卷积神经网络的滑动窗口，它像人一样，在识别或观察一个物体时从细微着手慢慢扫描。我们可以把这么一个卷积核作为一个水龙头，那么他同时就对应我们在机器学习介绍的一个函数，所以这个卷积核的权重也是可以学习的。\n\n对于卷积神经网络我想大家也只是明白了一个大致的流程，但我想这就够了，因为对于任何一个模型我们要深入都要花费很长的时间，而我也只能描述一些大概。来方便各位前辈了解CNN。\n\n## 循环神经网络\n\n对于自然语言来说，我们每说一句话，每个单词与单词之间其实是有联系的。每个结果预测的输出结果其实都依赖之前的数据。比如一句话：我想吃饭。饭这个词很多时候是需要依赖前面的谓语。所以一个网络想要处理好自然语言，他是需要记忆功能的。这种有记忆的神经网络称为循环神经网络（Recurrent Neural Network，RNN）。在RNN里面，每一次隐藏层的神经元产生输出的时候，该输出会被存到记忆元（memory cell）中的蓝色方块表示记忆元。下一次有输入时，这些神经元不仅会考虑输入x1, x2，还会考虑存到记忆元里的值。\n\n![](/imgs/深度学习/RNN.jpg)\n\n接下来我简单的介绍一下RNN是怎么工作的。\n\n假如需要判断用户的说话意图，用户说了句“what time is it？”我们需要先对这句话进行分词：\n\n![](/imgs/深度学习/RNN1.gif)\n\n然后按照顺序输入 RNN ，我们先将 “what”作为 RNN 的输入，得到输出「01」\n\n![](/imgs/深度学习/RNN2.gif)\n\n然后，我们按照顺序，将“time”输入到 RNN 网络，得到输出「02」。\n\n这个过程我们可以看到，输入 “time” 的时候，前面 **“what” 的输出也产生了影响**。\n\n![](/imgs/深度学习/RNN3.gif)\n\n以此类推，前面所有的输入都对未来的输出产生了影响，大家可以看到圆形隐藏层中包含了前面所有的颜色。如下图所示：\n\n![](/imgs/深度学习/RNN4.gif)\n\n当我们判断意图的时候，只需要最后一层的输出「05」，如下图所示：\n\n![](/imgs/深度学习/RNN5.gif)\n\n通过上面的例子，我们已经发现，短期的记忆影响较大（如橙色区域），但是长期的记忆影响就很小（如黑色和绿色区域），这就是 RNN 存在的短期记忆问题。\n\n因此对于这些问题有很多RNN的变体，但是我们今天就不介绍了。\n\n## 自注意力机制\n\nAttention（注意力）机制如果浅层的理解，跟他的名字非常匹配。他的核心逻辑就是**“从关注全部到关注重点”**。\n\nAttention 机制很像人类看图片的逻辑，当我们看一张图片的时候，我们并没有看清图片的全部内容，而是将注意力集中在了图片的焦点上。大家看一下下面这张图：\n\n![](/imgs/深度学习/注意力1.png)\n\n我们一定会看清“锦江饭店”4个字，但是我相信没人会意识到“锦江饭店”上面还有一串“电话号码”，也不会意识到“喜运来大酒家”。\n\n![](/imgs/深度学习/注意力.png)\n\n所以，当我们看一张图片的时候，其实是这样的：\n\n![](/imgs/深度学习/注意力2.png)\n\n上面所说的，我们的视觉系统就是一种 Attention机制，**将有限的注意力集中在重点信息上，从而节省资源，快速获得最有效的信息。**\n\n### AI领域注意力机制就是GPT最核心的组件：\n\n如果用图来表达 Attention 的位置大致是下面的样子：\n\n![](/imgs/深度学习/注意力3.png)\n\n\n\n\n\n注意力机制的优势：\n\n**参数少**：模型复杂度跟 CNN、RNN 相比，复杂度更小，参数也更少。所以对算力的要求也就更小。\n\n**速度快**：Attention 解决了 RNN 不能并行计算的问题。Attention机制每一步计算不依赖于上一步的计算结果，因此可以和CNN一样并行处理。\n\n**效果好**：在 Attention 机制引入之前，有一个问题大家一直很苦恼：长距离的信息会被弱化，就好像记忆能力弱的人，记不住过去的事情是一样的。\n\nAttention 是挑重点，就算文本比较长，也能从中间抓住重点，不丢失重要的信息。下图红色的预期就是被挑出来的重点。\n\n对于注意力的运算来说，其主要原理就是通过对数据集处理，获得三个矩阵，并且生成对应的权重向量，然后对进行相似度计算，之后进行归一化处理，出于对这篇文章最开始目的的把握，所以我不再介绍这些计算。\n\n## Transformer\n\nTransformer在2017年由Google在题为《Attention Is All You Need》的论文中提出。Transformer是一个完全基于注意力机制的编解码器模型，它抛弃了之前其它模型引入注意力机制后仍然保留的循环与卷积结构，而采用了自注意力（Self-attention）机制，在任务表现、并行能力和易于训练性方面都有大幅的提高。\n\n<img src=\"/imgs/深度学习/Transformer.jpg\" style=\"zoom: 50%;\" />\n\n如果CNN、RNN、注意力机制都算是一个基础的组件的话，那么Transformer就是一个模型了\n\n## 生成对抗模型GAN\n\n\n\n## ChatGPT\n\nChatGPT 真正在做的事情是什么呢？一言以蔽之就是做文字“接龙”，正确理解ChatGPT 的方式是它就是一个函数，就是输入一些东西，就输出一些东西。可以以一个句子作为输入，它输出这个句子后面应该接的词汇的概率。它会给每一个可能的符号一个概率。\n\n举例来说，如果输入是“什么是机器学习”，也许下一个可以接的中文词汇，概率比较高的是“机”，然后“器”和“好”也许有一些概率，那其他词汇的概率就很低。ChatGPT输出的是这样一个概率的分布，那ChatGPT 输出概率分布以后，接下来会从这个概率分布里面去做采样，根据这个概率分布去采样出一个词汇。举例来说“机”它的概率是最高的，所以从概率分布里面去采样词汇，采样到“机”的概率可能是比较大的，但也有可能采样到其他的词汇，所以这就是为什么ChatGPT 每次的答案都是不一样的，因为他每次产生答案的时候是有随机性的，它是从一个概率分布里面去做取样，所以他每次的答案都是不同的。\n\n## 深度学习对底软的能力提升：\n\n### 代码生成\n\n### 日志分析\n\n### 代码查错\n\n## GAI对软硬件设计的影响\n\n聊聊**生成式AI(GAI)**对今后[软件设计](https://www.zhihu.com/search?q=软件设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})的影响。看了很多业界人士对未来的预测和判断，都感觉有局限性。\n\n这两天在网上看到一篇让人脑洞大开的文章《ChatGPT会在10年内取代程序员》，文章提了两个人们在ChatGPT之类的GAI在软件开发方面的谬误。\n\n- 第一个谬误是“当前的AI会产生bug”，甚至有些代码还不能完全复制粘贴来使用，所以AI不会取代程序员。那么其实人也会产生bug（无论是有意为之还是为了保全工作）。所以有bug的代码并不会阻止GAI最终取代程序员。\n- 二个谬误观点是GAI是用来帮助程序员提高效率的工具。那么从老板的角度来看，如果有机器替代的话，高收入的程序员群体是老板眼中首先要节约的“成本”。尤其是因为软件工程是**数字化的，可指数级扩展的工程问题**。这类工作是AI替代的完美目标。\n\n作者对于未来的预测可以这么总结：\n\n阶段0：原型期（2023年第一季度）失业率预测：2%\n\n虽然当前chatGPT还仅仅是基于浏览器的AI工具且并不稳定，但当微软，谷歌以及每个科技和创业公司都想加入竞争的时候，chatGPT类的GAI演进速度会加快。那么当前受影响的是基于搜索的广告业务，[软件工程师](https://www.zhihu.com/search?q=软件工程师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})还比较安全。\n\n阶段1：规模化的[集成开发环境](https://www.zhihu.com/search?q=集成开发环境&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})（IDE）渗透（2023年第二到第四季度） 失业率预测：5%\n\n这时Copilot，codex及众多的IDE GAI工具将会广泛使用。有大量的Java等语言的样板代码。AI拥有程序上下文分析的能力，GAI将会首先通过微软工具套件等形式被集成。生产力大幅提高，工程速度加快，但项目暂时不会因为提早完成而大量裁员。大多数人还有短暂的安全。\n\n阶段2：高级IDE工具开发与整合（1-2年）失业率预测：25%\n\n该阶段IDE会越来越强大，能分析整个代码库的上下文环境，并提供100%覆盖率的单元测试。编写程序的语言不再重要，用python快速实现的想法，瞬间可以被重写成其他效率更高的代码。真正的**工程清洗( engineering purge)**开始，低效的和拒绝AI的开发者将首当其冲。通用性的软件工程（如web前后端）将是多米诺骨牌的第一张，其次是手机应用开发。VR及游戏等专才仍然安全。\n\n阶段3：[软件即服务](https://www.zhihu.com/search?q=软件即服务&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})（SaaS）和无代码阶段（2-5年）失业率预测：75%\n\n阶段2所遗留下的代码库已经重新被重写和更换。存留下来的代码库在测试覆盖率，安全性及标准化等各个方面都全面碾压前人。软件将不再需要文档。AI一直在基于用户的使用模式，优化自身。软件开发更关注业务本身，一句话就可以生成类似今日头条类的新闻推送系统。没人做全栈了，移动设备[app开发](https://www.zhihu.com/search?q=app开发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})也消失了，开发者转向如机器人及生物技术等专业方向。不会编程的人士只要有好的业务想法，AI便可帮忙实现。\n\n阶段4: 原生AI（5-10年）失业率预测：95%\n\n这个阶段的代码不再由人类维护，单元测试和工程文档这类的事物也早都过时。AI代码并不需要使用人类能理解的汇编及高级语言。更原生的AI指令集会使得软硬件及编译器皆为AI所用，协同优化。写代码将会像公园里的[蒸汽火车](https://www.zhihu.com/search?q=蒸汽火车&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})一样，仅仅是为了缅怀和记忆。\n\n阶段5: 热寂（Heat Death）（10年以后）失业率预测：99%\n\n软件早已无法识别。AI原生标准已经全球化。钢铁侠般的实验室里，AI会通过跟你聊天来完成你想要完成的任务。web 3.0也会在AI的推动下提前到来。\n\n这些东西我们没法真正的预测，但对于底层软件工程师来说，写代码也仅仅只是最基础的环节。和硬件的交互，和各个流程的人沟通这些GAI都很难做到，我想，很多时候我们不能把我他以后发展真正的趋势，可以去拥抱他，先探索着利用他提升我们整体的效能。\n","source":"_posts/深度学习分享.md","raw":"---\ntitle: 深度学习分享\ndate: 2023-10-01 16:34:29\ntags:\n  - Deep Learning\ntypora-root-url: ./..\n---\n\n深度学习分享：\n\n你怎么不找我说话啊！！！！20231002-15：06\n\n俩小时了，好难熬啊！！！！20231002-17：07\n\n怎么通俗易懂的给从没有接触过深度学习的同事们介绍深度学习，是个让人非常头疼的问题。\n\n<small>为了让各位前辈更迅速更简单的了解深度学习，我将大量的其他信息都进行了过滤，我们只聊最简单最基础最能抓住这些信息的东西，所有我对大量的内容进行了删除，总结。如果深入理解，有一些说法是不那么正确的。</small>\n\n## 机器学习\n\n机器学习，顾名思义，机器具备有学习的能力。具体来讲，机器学习就是让机器具备找一个函数的能力。\n\n以图像识别为例，图像识别函数的输入是一张图片，输出是这个图片里面的内容。根据要找的函数不同，机器学习有不同的类别。\n\n- 假设要找的函数的输出是一个数值，这种机器学习的任务称为回归。\n- 函数的输出就是从设定好的选项里面选择一个当作输出，该任务称为分类。\n\n机器学习找函数的过程，分成3 个步骤。\n\n**第一个步骤**是写出一个带有未知参数的函数$f$，其能预测未来点击次数。比如将函数写成\n$$\ny = b + wx_1\n$$\n其中$y$是要预测的东西，$x_1$是输入的数据，而$w$跟$b$是未知的，$w$称为权重，$b$称为偏置。\n\n**第二个步骤**是定义损失（loss），损失也是一个函数。这个函数的输入是模型里面的参数，模型是$y = b + w ∗ x1$，而$b $跟$w $是未知的，损失是函数$L(b,w)$，其输入是模型参数$b $跟$w$，假设真是的结果是$\\hat{y}$。\n\n每一个数据的预测差距可以这么表示：\n$$\ne_i=|y-\\hat{y}|\n$$\n把所有数据的差距加起来求平均就是损失：\n$$\nL=\\frac{1}{N} \\sum_{n}\n$$\n**第三个步骤**是找到一个最优解，找到一个$w$跟$b$能让损失尽可能小，让预测的结果跟真实的结果尽可能接近。\n\n![](/imgs/深度学习/损失L.jpg)\n\nw在不同大小的时候会有不同的损失，为了让损失尽可能小，需要先随机找到一个初始点$w^0$，$w^0$就是这个时刻的切线斜率。\n\n把$w0 $往右移一步，新的位置为$w1$，这一步的步伐是$η(学习率) $乘上$L$关于$w$的偏微分的结果就是：\n$$\nw^1 << w^0-η\\frac{\\partial{L}}{\\partial{w}}|(w=w^0)\n$$\n接下来反复进行刚才的操作，最终求得最优解。当然这其中有很多策略和其他的知识点，对于我们要简单的了解深度学习来说是不需要探讨的。\n\n所以各位前辈大概已经清楚了机器学习损失反向传播的一种大致思维，这种反复对损失进行优化的过程，我们就把他简单的看成一个训练过程。\n\n## 深度学习\n\n对于我们简单的了解深度学习来说，我们这里不讨论：过拟合、优化问题、交叉验证、局部极小值与鞍点、批量与动量、自适应与学习率。我们从全局来了解深度学习网络方便我们对CAI（生成式AI有所了解）。\n\n深度学习是机器学习的一个分支(最重要的分支)，我们之前假设机器学习就是简单的一个函数处理优化流程，这只是我总结的一个大貌，但各位前辈们如果有意深入了解会发现机器学习包含很多东西，我的总结也并不全对。\n\n这里我们假设深度学习是要处理信息的“水流”，处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。\n\n这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。\n\n而这一个一个的小水管都是可控制他们的水流速度，水流体积。我们也可以把每一个水管都当作一个函数，控制水流就靠w和b，而这些一个一个小函数，小的神经单元组成一个大的函数，大的神经网络。\n\n![](/imgs/深度学习/深度网络.png)\n\n那么这么复杂的网络它带来的第一个优势就是他的学习能力强，表示覆盖的范围广，也同事让深度学习对计算量这些要求比较高。\n\n## 卷积神经网络\n\n我们从卷积神经网络（Convolutional Neural Network，CNN）开始，探讨网络的架构设计。卷积神经网络是一种非常典型的网络架构，常用于图像的处理等任务。\n\n对于卷积神经网络来说，我们不考虑池化下采样、上采样、反向传播这些内容，仅仅是了解它大致的一个处理思路。\n\n我们从一个图像分类任务入手，所谓图像分类，就是给机器一张图像，由机器去判断这张图像里面有什么样的东西——是猫还是狗、是飞机还是汽车。\n\n而怎么把图像作为模型的输入呢？？对于机器，图像可以描述为三维张量（我们可以把这个张量看作一个浮点型多维矩阵，存储在Double类型的数组里）。一张图像是一个三维的张量，其中一维代表图像的宽，另外一维代表图像的高，还有一维代表图像的通道（channel）的数目。\n\n<small>channel是什么：彩色图像的每个像素都可以描述为红色（red）、绿色（green）、蓝色（blue）的组合，这3 种颜色就称为图像的3 个色彩通.</small>\n\n![](/imgs/深度学习/图像输入.jpg)\n\n我们可以看到把一个100$\\times$100像素的图片分解为rgb三个通道后，再把每个像素看成一个元素$x_i$，将这些元素展开拉平到一个1维数组中去，这个数组大小就是100$\\times$100$\\times$3。\n\n![](/imgs/深度学习/CNN输入到网络.jpg)\n\n对一个图像识别的类神经网络里面的神经元（每个水龙头）而言，它要做的就是检测图像里面有没有出现一些特别重要的模式（pattern），这些模式是代表了某种物件的。\n\n举例来说，如果现在有三个神经元分别看到鸟嘴、眼睛、鸟爪3 个模式，这就代表类神经网络看到了一只鸟。\n\n![](/imgs/深度学习/鸟识别1.jpg)\n\n为了方便大家理解我们可以我用像素画了一只鸟，和一个过滤器来给大家演示。\n\n![](/imgs/深度学习/鸟.png)\n\n我用visio随便画了只鸟，空白的格子我们姑且让他的值为0，右侧的卷积核（水龙头）通过一步步滑动窗口对图像矩阵的元素进行比对。\n\n![image-20231003142939167](/imgs/深度学习/移动1)\n\n![image-20231003143036998](/imgs/深度学习/移动2)\n\n最终找到极其相似的值，如下图所示：\n\n![image-20231003143105899](/imgs/深度学习/移动3)\n\n这样就是卷积神经网络的滑动窗口，它像人一样，在识别或观察一个物体时从细微着手慢慢扫描。我们可以把这么一个卷积核作为一个水龙头，那么他同时就对应我们在机器学习介绍的一个函数，所以这个卷积核的权重也是可以学习的。\n\n对于卷积神经网络我想大家也只是明白了一个大致的流程，但我想这就够了，因为对于任何一个模型我们要深入都要花费很长的时间，而我也只能描述一些大概。来方便各位前辈了解CNN。\n\n## 循环神经网络\n\n对于自然语言来说，我们每说一句话，每个单词与单词之间其实是有联系的。每个结果预测的输出结果其实都依赖之前的数据。比如一句话：我想吃饭。饭这个词很多时候是需要依赖前面的谓语。所以一个网络想要处理好自然语言，他是需要记忆功能的。这种有记忆的神经网络称为循环神经网络（Recurrent Neural Network，RNN）。在RNN里面，每一次隐藏层的神经元产生输出的时候，该输出会被存到记忆元（memory cell）中的蓝色方块表示记忆元。下一次有输入时，这些神经元不仅会考虑输入x1, x2，还会考虑存到记忆元里的值。\n\n![](/imgs/深度学习/RNN.jpg)\n\n接下来我简单的介绍一下RNN是怎么工作的。\n\n假如需要判断用户的说话意图，用户说了句“what time is it？”我们需要先对这句话进行分词：\n\n![](/imgs/深度学习/RNN1.gif)\n\n然后按照顺序输入 RNN ，我们先将 “what”作为 RNN 的输入，得到输出「01」\n\n![](/imgs/深度学习/RNN2.gif)\n\n然后，我们按照顺序，将“time”输入到 RNN 网络，得到输出「02」。\n\n这个过程我们可以看到，输入 “time” 的时候，前面 **“what” 的输出也产生了影响**。\n\n![](/imgs/深度学习/RNN3.gif)\n\n以此类推，前面所有的输入都对未来的输出产生了影响，大家可以看到圆形隐藏层中包含了前面所有的颜色。如下图所示：\n\n![](/imgs/深度学习/RNN4.gif)\n\n当我们判断意图的时候，只需要最后一层的输出「05」，如下图所示：\n\n![](/imgs/深度学习/RNN5.gif)\n\n通过上面的例子，我们已经发现，短期的记忆影响较大（如橙色区域），但是长期的记忆影响就很小（如黑色和绿色区域），这就是 RNN 存在的短期记忆问题。\n\n因此对于这些问题有很多RNN的变体，但是我们今天就不介绍了。\n\n## 自注意力机制\n\nAttention（注意力）机制如果浅层的理解，跟他的名字非常匹配。他的核心逻辑就是**“从关注全部到关注重点”**。\n\nAttention 机制很像人类看图片的逻辑，当我们看一张图片的时候，我们并没有看清图片的全部内容，而是将注意力集中在了图片的焦点上。大家看一下下面这张图：\n\n![](/imgs/深度学习/注意力1.png)\n\n我们一定会看清“锦江饭店”4个字，但是我相信没人会意识到“锦江饭店”上面还有一串“电话号码”，也不会意识到“喜运来大酒家”。\n\n![](/imgs/深度学习/注意力.png)\n\n所以，当我们看一张图片的时候，其实是这样的：\n\n![](/imgs/深度学习/注意力2.png)\n\n上面所说的，我们的视觉系统就是一种 Attention机制，**将有限的注意力集中在重点信息上，从而节省资源，快速获得最有效的信息。**\n\n### AI领域注意力机制就是GPT最核心的组件：\n\n如果用图来表达 Attention 的位置大致是下面的样子：\n\n![](/imgs/深度学习/注意力3.png)\n\n\n\n\n\n注意力机制的优势：\n\n**参数少**：模型复杂度跟 CNN、RNN 相比，复杂度更小，参数也更少。所以对算力的要求也就更小。\n\n**速度快**：Attention 解决了 RNN 不能并行计算的问题。Attention机制每一步计算不依赖于上一步的计算结果，因此可以和CNN一样并行处理。\n\n**效果好**：在 Attention 机制引入之前，有一个问题大家一直很苦恼：长距离的信息会被弱化，就好像记忆能力弱的人，记不住过去的事情是一样的。\n\nAttention 是挑重点，就算文本比较长，也能从中间抓住重点，不丢失重要的信息。下图红色的预期就是被挑出来的重点。\n\n对于注意力的运算来说，其主要原理就是通过对数据集处理，获得三个矩阵，并且生成对应的权重向量，然后对进行相似度计算，之后进行归一化处理，出于对这篇文章最开始目的的把握，所以我不再介绍这些计算。\n\n## Transformer\n\nTransformer在2017年由Google在题为《Attention Is All You Need》的论文中提出。Transformer是一个完全基于注意力机制的编解码器模型，它抛弃了之前其它模型引入注意力机制后仍然保留的循环与卷积结构，而采用了自注意力（Self-attention）机制，在任务表现、并行能力和易于训练性方面都有大幅的提高。\n\n<img src=\"/imgs/深度学习/Transformer.jpg\" style=\"zoom: 50%;\" />\n\n如果CNN、RNN、注意力机制都算是一个基础的组件的话，那么Transformer就是一个模型了\n\n## 生成对抗模型GAN\n\n\n\n## ChatGPT\n\nChatGPT 真正在做的事情是什么呢？一言以蔽之就是做文字“接龙”，正确理解ChatGPT 的方式是它就是一个函数，就是输入一些东西，就输出一些东西。可以以一个句子作为输入，它输出这个句子后面应该接的词汇的概率。它会给每一个可能的符号一个概率。\n\n举例来说，如果输入是“什么是机器学习”，也许下一个可以接的中文词汇，概率比较高的是“机”，然后“器”和“好”也许有一些概率，那其他词汇的概率就很低。ChatGPT输出的是这样一个概率的分布，那ChatGPT 输出概率分布以后，接下来会从这个概率分布里面去做采样，根据这个概率分布去采样出一个词汇。举例来说“机”它的概率是最高的，所以从概率分布里面去采样词汇，采样到“机”的概率可能是比较大的，但也有可能采样到其他的词汇，所以这就是为什么ChatGPT 每次的答案都是不一样的，因为他每次产生答案的时候是有随机性的，它是从一个概率分布里面去做取样，所以他每次的答案都是不同的。\n\n## 深度学习对底软的能力提升：\n\n### 代码生成\n\n### 日志分析\n\n### 代码查错\n\n## GAI对软硬件设计的影响\n\n聊聊**生成式AI(GAI)**对今后[软件设计](https://www.zhihu.com/search?q=软件设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})的影响。看了很多业界人士对未来的预测和判断，都感觉有局限性。\n\n这两天在网上看到一篇让人脑洞大开的文章《ChatGPT会在10年内取代程序员》，文章提了两个人们在ChatGPT之类的GAI在软件开发方面的谬误。\n\n- 第一个谬误是“当前的AI会产生bug”，甚至有些代码还不能完全复制粘贴来使用，所以AI不会取代程序员。那么其实人也会产生bug（无论是有意为之还是为了保全工作）。所以有bug的代码并不会阻止GAI最终取代程序员。\n- 二个谬误观点是GAI是用来帮助程序员提高效率的工具。那么从老板的角度来看，如果有机器替代的话，高收入的程序员群体是老板眼中首先要节约的“成本”。尤其是因为软件工程是**数字化的，可指数级扩展的工程问题**。这类工作是AI替代的完美目标。\n\n作者对于未来的预测可以这么总结：\n\n阶段0：原型期（2023年第一季度）失业率预测：2%\n\n虽然当前chatGPT还仅仅是基于浏览器的AI工具且并不稳定，但当微软，谷歌以及每个科技和创业公司都想加入竞争的时候，chatGPT类的GAI演进速度会加快。那么当前受影响的是基于搜索的广告业务，[软件工程师](https://www.zhihu.com/search?q=软件工程师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})还比较安全。\n\n阶段1：规模化的[集成开发环境](https://www.zhihu.com/search?q=集成开发环境&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})（IDE）渗透（2023年第二到第四季度） 失业率预测：5%\n\n这时Copilot，codex及众多的IDE GAI工具将会广泛使用。有大量的Java等语言的样板代码。AI拥有程序上下文分析的能力，GAI将会首先通过微软工具套件等形式被集成。生产力大幅提高，工程速度加快，但项目暂时不会因为提早完成而大量裁员。大多数人还有短暂的安全。\n\n阶段2：高级IDE工具开发与整合（1-2年）失业率预测：25%\n\n该阶段IDE会越来越强大，能分析整个代码库的上下文环境，并提供100%覆盖率的单元测试。编写程序的语言不再重要，用python快速实现的想法，瞬间可以被重写成其他效率更高的代码。真正的**工程清洗( engineering purge)**开始，低效的和拒绝AI的开发者将首当其冲。通用性的软件工程（如web前后端）将是多米诺骨牌的第一张，其次是手机应用开发。VR及游戏等专才仍然安全。\n\n阶段3：[软件即服务](https://www.zhihu.com/search?q=软件即服务&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})（SaaS）和无代码阶段（2-5年）失业率预测：75%\n\n阶段2所遗留下的代码库已经重新被重写和更换。存留下来的代码库在测试覆盖率，安全性及标准化等各个方面都全面碾压前人。软件将不再需要文档。AI一直在基于用户的使用模式，优化自身。软件开发更关注业务本身，一句话就可以生成类似今日头条类的新闻推送系统。没人做全栈了，移动设备[app开发](https://www.zhihu.com/search?q=app开发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})也消失了，开发者转向如机器人及生物技术等专业方向。不会编程的人士只要有好的业务想法，AI便可帮忙实现。\n\n阶段4: 原生AI（5-10年）失业率预测：95%\n\n这个阶段的代码不再由人类维护，单元测试和工程文档这类的事物也早都过时。AI代码并不需要使用人类能理解的汇编及高级语言。更原生的AI指令集会使得软硬件及编译器皆为AI所用，协同优化。写代码将会像公园里的[蒸汽火车](https://www.zhihu.com/search?q=蒸汽火车&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A\"618256622\"})一样，仅仅是为了缅怀和记忆。\n\n阶段5: 热寂（Heat Death）（10年以后）失业率预测：99%\n\n软件早已无法识别。AI原生标准已经全球化。钢铁侠般的实验室里，AI会通过跟你聊天来完成你想要完成的任务。web 3.0也会在AI的推动下提前到来。\n\n这些东西我们没法真正的预测，但对于底层软件工程师来说，写代码也仅仅只是最基础的环节。和硬件的交互，和各个流程的人沟通这些GAI都很难做到，我想，很多时候我们不能把我他以后发展真正的趋势，可以去拥抱他，先探索着利用他提升我们整体的效能。\n","slug":"深度学习分享","published":1,"updated":"2023-10-03T07:45:43.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clna0n6sm000blcwf35jwa08r","content":"<p>深度学习分享：</p>\n<p>你怎么不找我说话啊！！！！20231002-15：06</p>\n<p>俩小时了，好难熬啊！！！！20231002-17：07</p>\n<p>怎么通俗易懂的给从没有接触过深度学习的同事们介绍深度学习，是个让人非常头疼的问题。</p>\n<p><small>为了让各位前辈更迅速更简单的了解深度学习，我将大量的其他信息都进行了过滤，我们只聊最简单最基础最能抓住这些信息的东西，所有我对大量的内容进行了删除，总结。如果深入理解，有一些说法是不那么正确的。</small></p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p>机器学习，顾名思义，机器具备有学习的能力。具体来讲，机器学习就是让机器具备找一个函数的能力。</p>\n<p>以图像识别为例，图像识别函数的输入是一张图片，输出是这个图片里面的内容。根据要找的函数不同，机器学习有不同的类别。</p>\n<ul>\n<li>假设要找的函数的输出是一个数值，这种机器学习的任务称为回归。</li>\n<li>函数的输出就是从设定好的选项里面选择一个当作输出，该任务称为分类。</li>\n</ul>\n<p>机器学习找函数的过程，分成3 个步骤。</p>\n<p><strong>第一个步骤</strong>是写出一个带有未知参数的函数$f$，其能预测未来点击次数。比如将函数写成<br>$$<br>y &#x3D; b + wx_1<br>$$<br>其中$y$是要预测的东西，$x_1$是输入的数据，而$w$跟$b$是未知的，$w$称为权重，$b$称为偏置。</p>\n<p><strong>第二个步骤</strong>是定义损失（loss），损失也是一个函数。这个函数的输入是模型里面的参数，模型是$y &#x3D; b + w ∗ x1$，而$b $跟$w $是未知的，损失是函数$L(b,w)$，其输入是模型参数$b $跟$w$，假设真是的结果是$\\hat{y}$。</p>\n<p>每一个数据的预测差距可以这么表示：<br>$$<br>e_i&#x3D;|y-\\hat{y}|<br>$$<br>把所有数据的差距加起来求平均就是损失：<br>$$<br>L&#x3D;\\frac{1}{N} \\sum_{n}<br>$$<br><strong>第三个步骤</strong>是找到一个最优解，找到一个$w$跟$b$能让损失尽可能小，让预测的结果跟真实的结果尽可能接近。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1L.jpg\"></p>\n<p>w在不同大小的时候会有不同的损失，为了让损失尽可能小，需要先随机找到一个初始点$w^0$，$w^0$就是这个时刻的切线斜率。</p>\n<p>把$w0 $往右移一步，新的位置为$w1$，这一步的步伐是$η(学习率) $乘上$L$关于$w$的偏微分的结果就是：<br>$$<br>w^1 &lt;&lt; w^0-η\\frac{\\partial{L}}{\\partial{w}}|(w&#x3D;w^0)<br>$$<br>接下来反复进行刚才的操作，最终求得最优解。当然这其中有很多策略和其他的知识点，对于我们要简单的了解深度学习来说是不需要探讨的。</p>\n<p>所以各位前辈大概已经清楚了机器学习损失反向传播的一种大致思维，这种反复对损失进行优化的过程，我们就把他简单的看成一个训练过程。</p>\n<h2 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h2><p>对于我们简单的了解深度学习来说，我们这里不讨论：过拟合、优化问题、交叉验证、局部极小值与鞍点、批量与动量、自适应与学习率。我们从全局来了解深度学习网络方便我们对CAI（生成式AI有所了解）。</p>\n<p>深度学习是机器学习的一个分支(最重要的分支)，我们之前假设机器学习就是简单的一个函数处理优化流程，这只是我总结的一个大貌，但各位前辈们如果有意深入了解会发现机器学习包含很多东西，我的总结也并不全对。</p>\n<p>这里我们假设深度学习是要处理信息的“水流”，处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。</p>\n<p>这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。</p>\n<p>而这一个一个的小水管都是可控制他们的水流速度，水流体积。我们也可以把每一个水管都当作一个函数，控制水流就靠w和b，而这些一个一个小函数，小的神经单元组成一个大的函数，大的神经网络。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C.png\"></p>\n<p>那么这么复杂的网络它带来的第一个优势就是他的学习能力强，表示覆盖的范围广，也同事让深度学习对计算量这些要求比较高。</p>\n<h2 id=\"卷积神经网络\"><a href=\"#卷积神经网络\" class=\"headerlink\" title=\"卷积神经网络\"></a>卷积神经网络</h2><p>我们从卷积神经网络（Convolutional Neural Network，CNN）开始，探讨网络的架构设计。卷积神经网络是一种非常典型的网络架构，常用于图像的处理等任务。</p>\n<p>对于卷积神经网络来说，我们不考虑池化下采样、上采样、反向传播这些内容，仅仅是了解它大致的一个处理思路。</p>\n<p>我们从一个图像分类任务入手，所谓图像分类，就是给机器一张图像，由机器去判断这张图像里面有什么样的东西——是猫还是狗、是飞机还是汽车。</p>\n<p>而怎么把图像作为模型的输入呢？？对于机器，图像可以描述为三维张量（我们可以把这个张量看作一个浮点型多维矩阵，存储在Double类型的数组里）。一张图像是一个三维的张量，其中一维代表图像的宽，另外一维代表图像的高，还有一维代表图像的通道（channel）的数目。</p>\n<p><small>channel是什么：彩色图像的每个像素都可以描述为红色（red）、绿色（green）、蓝色（blue）的组合，这3 种颜色就称为图像的3 个色彩通.</small></p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E8%BE%93%E5%85%A5.jpg\"></p>\n<p>我们可以看到把一个100$\\times$100像素的图片分解为rgb三个通道后，再把每个像素看成一个元素$x_i$，将这些元素展开拉平到一个1维数组中去，这个数组大小就是100$\\times$100$\\times$3。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN%E8%BE%93%E5%85%A5%E5%88%B0%E7%BD%91%E7%BB%9C.jpg\"></p>\n<p>对一个图像识别的类神经网络里面的神经元（每个水龙头）而言，它要做的就是检测图像里面有没有出现一些特别重要的模式（pattern），这些模式是代表了某种物件的。</p>\n<p>举例来说，如果现在有三个神经元分别看到鸟嘴、眼睛、鸟爪3 个模式，这就代表类神经网络看到了一只鸟。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%B8%9F%E8%AF%86%E5%88%AB1.jpg\"></p>\n<p>为了方便大家理解我们可以我用像素画了一只鸟，和一个过滤器来给大家演示。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%B8%9F.png\"></p>\n<p>我用visio随便画了只鸟，空白的格子我们姑且让他的值为0，右侧的卷积核（水龙头）通过一步步滑动窗口对图像矩阵的元素进行比对。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A81\" alt=\"image-20231003142939167\"></p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A82\" alt=\"image-20231003143036998\"></p>\n<p>最终找到极其相似的值，如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A83\" alt=\"image-20231003143105899\"></p>\n<p>这样就是卷积神经网络的滑动窗口，它像人一样，在识别或观察一个物体时从细微着手慢慢扫描。我们可以把这么一个卷积核作为一个水龙头，那么他同时就对应我们在机器学习介绍的一个函数，所以这个卷积核的权重也是可以学习的。</p>\n<p>对于卷积神经网络我想大家也只是明白了一个大致的流程，但我想这就够了，因为对于任何一个模型我们要深入都要花费很长的时间，而我也只能描述一些大概。来方便各位前辈了解CNN。</p>\n<h2 id=\"循环神经网络\"><a href=\"#循环神经网络\" class=\"headerlink\" title=\"循环神经网络\"></a>循环神经网络</h2><p>对于自然语言来说，我们每说一句话，每个单词与单词之间其实是有联系的。每个结果预测的输出结果其实都依赖之前的数据。比如一句话：我想吃饭。饭这个词很多时候是需要依赖前面的谓语。所以一个网络想要处理好自然语言，他是需要记忆功能的。这种有记忆的神经网络称为循环神经网络（Recurrent Neural Network，RNN）。在RNN里面，每一次隐藏层的神经元产生输出的时候，该输出会被存到记忆元（memory cell）中的蓝色方块表示记忆元。下一次有输入时，这些神经元不仅会考虑输入x1, x2，还会考虑存到记忆元里的值。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN.jpg\"></p>\n<p>接下来我简单的介绍一下RNN是怎么工作的。</p>\n<p>假如需要判断用户的说话意图，用户说了句“what time is it？”我们需要先对这句话进行分词：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN1.gif\"></p>\n<p>然后按照顺序输入 RNN ，我们先将 “what”作为 RNN 的输入，得到输出「01」</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN2.gif\"></p>\n<p>然后，我们按照顺序，将“time”输入到 RNN 网络，得到输出「02」。</p>\n<p>这个过程我们可以看到，输入 “time” 的时候，前面 <strong>“what” 的输出也产生了影响</strong>。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN3.gif\"></p>\n<p>以此类推，前面所有的输入都对未来的输出产生了影响，大家可以看到圆形隐藏层中包含了前面所有的颜色。如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN4.gif\"></p>\n<p>当我们判断意图的时候，只需要最后一层的输出「05」，如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN5.gif\"></p>\n<p>通过上面的例子，我们已经发现，短期的记忆影响较大（如橙色区域），但是长期的记忆影响就很小（如黑色和绿色区域），这就是 RNN 存在的短期记忆问题。</p>\n<p>因此对于这些问题有很多RNN的变体，但是我们今天就不介绍了。</p>\n<h2 id=\"自注意力机制\"><a href=\"#自注意力机制\" class=\"headerlink\" title=\"自注意力机制\"></a>自注意力机制</h2><p>Attention（注意力）机制如果浅层的理解，跟他的名字非常匹配。他的核心逻辑就是<strong>“从关注全部到关注重点”</strong>。</p>\n<p>Attention 机制很像人类看图片的逻辑，当我们看一张图片的时候，我们并没有看清图片的全部内容，而是将注意力集中在了图片的焦点上。大家看一下下面这张图：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B1.png\"></p>\n<p>我们一定会看清“锦江饭店”4个字，但是我相信没人会意识到“锦江饭店”上面还有一串“电话号码”，也不会意识到“喜运来大酒家”。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B.png\"></p>\n<p>所以，当我们看一张图片的时候，其实是这样的：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B2.png\"></p>\n<p>上面所说的，我们的视觉系统就是一种 Attention机制，<strong>将有限的注意力集中在重点信息上，从而节省资源，快速获得最有效的信息。</strong></p>\n<h3 id=\"AI领域注意力机制就是GPT最核心的组件：\"><a href=\"#AI领域注意力机制就是GPT最核心的组件：\" class=\"headerlink\" title=\"AI领域注意力机制就是GPT最核心的组件：\"></a>AI领域注意力机制就是GPT最核心的组件：</h3><p>如果用图来表达 Attention 的位置大致是下面的样子：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B3.png\"></p>\n<p>注意力机制的优势：</p>\n<p><strong>参数少</strong>：模型复杂度跟 CNN、RNN 相比，复杂度更小，参数也更少。所以对算力的要求也就更小。</p>\n<p><strong>速度快</strong>：Attention 解决了 RNN 不能并行计算的问题。Attention机制每一步计算不依赖于上一步的计算结果，因此可以和CNN一样并行处理。</p>\n<p><strong>效果好</strong>：在 Attention 机制引入之前，有一个问题大家一直很苦恼：长距离的信息会被弱化，就好像记忆能力弱的人，记不住过去的事情是一样的。</p>\n<p>Attention 是挑重点，就算文本比较长，也能从中间抓住重点，不丢失重要的信息。下图红色的预期就是被挑出来的重点。</p>\n<p>对于注意力的运算来说，其主要原理就是通过对数据集处理，获得三个矩阵，并且生成对应的权重向量，然后对进行相似度计算，之后进行归一化处理，出于对这篇文章最开始目的的把握，所以我不再介绍这些计算。</p>\n<h2 id=\"Transformer\"><a href=\"#Transformer\" class=\"headerlink\" title=\"Transformer\"></a>Transformer</h2><p>Transformer在2017年由Google在题为《Attention Is All You Need》的论文中提出。Transformer是一个完全基于注意力机制的编解码器模型，它抛弃了之前其它模型引入注意力机制后仍然保留的循环与卷积结构，而采用了自注意力（Self-attention）机制，在任务表现、并行能力和易于训练性方面都有大幅的提高。</p>\n<img src=\"/imgs/深度学习/Transformer.jpg\" style=\"zoom: 50%;\" />\n\n<p>如果CNN、RNN、注意力机制都算是一个基础的组件的话，那么Transformer就是一个模型了</p>\n<h2 id=\"生成对抗模型GAN\"><a href=\"#生成对抗模型GAN\" class=\"headerlink\" title=\"生成对抗模型GAN\"></a>生成对抗模型GAN</h2><h2 id=\"ChatGPT\"><a href=\"#ChatGPT\" class=\"headerlink\" title=\"ChatGPT\"></a>ChatGPT</h2><p>ChatGPT 真正在做的事情是什么呢？一言以蔽之就是做文字“接龙”，正确理解ChatGPT 的方式是它就是一个函数，就是输入一些东西，就输出一些东西。可以以一个句子作为输入，它输出这个句子后面应该接的词汇的概率。它会给每一个可能的符号一个概率。</p>\n<p>举例来说，如果输入是“什么是机器学习”，也许下一个可以接的中文词汇，概率比较高的是“机”，然后“器”和“好”也许有一些概率，那其他词汇的概率就很低。ChatGPT输出的是这样一个概率的分布，那ChatGPT 输出概率分布以后，接下来会从这个概率分布里面去做采样，根据这个概率分布去采样出一个词汇。举例来说“机”它的概率是最高的，所以从概率分布里面去采样词汇，采样到“机”的概率可能是比较大的，但也有可能采样到其他的词汇，所以这就是为什么ChatGPT 每次的答案都是不一样的，因为他每次产生答案的时候是有随机性的，它是从一个概率分布里面去做取样，所以他每次的答案都是不同的。</p>\n<h2 id=\"深度学习对底软的能力提升：\"><a href=\"#深度学习对底软的能力提升：\" class=\"headerlink\" title=\"深度学习对底软的能力提升：\"></a>深度学习对底软的能力提升：</h2><h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><h3 id=\"日志分析\"><a href=\"#日志分析\" class=\"headerlink\" title=\"日志分析\"></a>日志分析</h3><h3 id=\"代码查错\"><a href=\"#代码查错\" class=\"headerlink\" title=\"代码查错\"></a>代码查错</h3><h2 id=\"GAI对软硬件设计的影响\"><a href=\"#GAI对软硬件设计的影响\" class=\"headerlink\" title=\"GAI对软硬件设计的影响\"></a>GAI对软硬件设计的影响</h2><p>聊聊**生成式AI(GAI)**对今后<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件设计</a>的影响。看了很多业界人士对未来的预测和判断，都感觉有局限性。</p>\n<p>这两天在网上看到一篇让人脑洞大开的文章《ChatGPT会在10年内取代程序员》，文章提了两个人们在ChatGPT之类的GAI在软件开发方面的谬误。</p>\n<ul>\n<li>第一个谬误是“当前的AI会产生bug”，甚至有些代码还不能完全复制粘贴来使用，所以AI不会取代程序员。那么其实人也会产生bug（无论是有意为之还是为了保全工作）。所以有bug的代码并不会阻止GAI最终取代程序员。</li>\n<li>二个谬误观点是GAI是用来帮助程序员提高效率的工具。那么从老板的角度来看，如果有机器替代的话，高收入的程序员群体是老板眼中首先要节约的“成本”。尤其是因为软件工程是<strong>数字化的，可指数级扩展的工程问题</strong>。这类工作是AI替代的完美目标。</li>\n</ul>\n<p>作者对于未来的预测可以这么总结：</p>\n<p>阶段0：原型期（2023年第一季度）失业率预测：2%</p>\n<p>虽然当前chatGPT还仅仅是基于浏览器的AI工具且并不稳定，但当微软，谷歌以及每个科技和创业公司都想加入竞争的时候，chatGPT类的GAI演进速度会加快。那么当前受影响的是基于搜索的广告业务，<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件工程师</a>还比较安全。</p>\n<p>阶段1：规模化的<a href=\"https://www.zhihu.com/search?q=%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">集成开发环境</a>（IDE）渗透（2023年第二到第四季度） 失业率预测：5%</p>\n<p>这时Copilot，codex及众多的IDE GAI工具将会广泛使用。有大量的Java等语言的样板代码。AI拥有程序上下文分析的能力，GAI将会首先通过微软工具套件等形式被集成。生产力大幅提高，工程速度加快，但项目暂时不会因为提早完成而大量裁员。大多数人还有短暂的安全。</p>\n<p>阶段2：高级IDE工具开发与整合（1-2年）失业率预测：25%</p>\n<p>该阶段IDE会越来越强大，能分析整个代码库的上下文环境，并提供100%覆盖率的单元测试。编写程序的语言不再重要，用python快速实现的想法，瞬间可以被重写成其他效率更高的代码。真正的**工程清洗( engineering purge)**开始，低效的和拒绝AI的开发者将首当其冲。通用性的软件工程（如web前后端）将是多米诺骨牌的第一张，其次是手机应用开发。VR及游戏等专才仍然安全。</p>\n<p>阶段3：<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件即服务</a>（SaaS）和无代码阶段（2-5年）失业率预测：75%</p>\n<p>阶段2所遗留下的代码库已经重新被重写和更换。存留下来的代码库在测试覆盖率，安全性及标准化等各个方面都全面碾压前人。软件将不再需要文档。AI一直在基于用户的使用模式，优化自身。软件开发更关注业务本身，一句话就可以生成类似今日头条类的新闻推送系统。没人做全栈了，移动设备<a href=\"https://www.zhihu.com/search?q=app%E5%BC%80%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">app开发</a>也消失了，开发者转向如机器人及生物技术等专业方向。不会编程的人士只要有好的业务想法，AI便可帮忙实现。</p>\n<p>阶段4: 原生AI（5-10年）失业率预测：95%</p>\n<p>这个阶段的代码不再由人类维护，单元测试和工程文档这类的事物也早都过时。AI代码并不需要使用人类能理解的汇编及高级语言。更原生的AI指令集会使得软硬件及编译器皆为AI所用，协同优化。写代码将会像公园里的<a href=\"https://www.zhihu.com/search?q=%E8%92%B8%E6%B1%BD%E7%81%AB%E8%BD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">蒸汽火车</a>一样，仅仅是为了缅怀和记忆。</p>\n<p>阶段5: 热寂（Heat Death）（10年以后）失业率预测：99%</p>\n<p>软件早已无法识别。AI原生标准已经全球化。钢铁侠般的实验室里，AI会通过跟你聊天来完成你想要完成的任务。web 3.0也会在AI的推动下提前到来。</p>\n<p>这些东西我们没法真正的预测，但对于底层软件工程师来说，写代码也仅仅只是最基础的环节。和硬件的交互，和各个流程的人沟通这些GAI都很难做到，我想，很多时候我们不能把我他以后发展真正的趋势，可以去拥抱他，先探索着利用他提升我们整体的效能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>深度学习分享：</p>\n<p>你怎么不找我说话啊！！！！20231002-15：06</p>\n<p>俩小时了，好难熬啊！！！！20231002-17：07</p>\n<p>怎么通俗易懂的给从没有接触过深度学习的同事们介绍深度学习，是个让人非常头疼的问题。</p>\n<p><small>为了让各位前辈更迅速更简单的了解深度学习，我将大量的其他信息都进行了过滤，我们只聊最简单最基础最能抓住这些信息的东西，所有我对大量的内容进行了删除，总结。如果深入理解，有一些说法是不那么正确的。</small></p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p>机器学习，顾名思义，机器具备有学习的能力。具体来讲，机器学习就是让机器具备找一个函数的能力。</p>\n<p>以图像识别为例，图像识别函数的输入是一张图片，输出是这个图片里面的内容。根据要找的函数不同，机器学习有不同的类别。</p>\n<ul>\n<li>假设要找的函数的输出是一个数值，这种机器学习的任务称为回归。</li>\n<li>函数的输出就是从设定好的选项里面选择一个当作输出，该任务称为分类。</li>\n</ul>\n<p>机器学习找函数的过程，分成3 个步骤。</p>\n<p><strong>第一个步骤</strong>是写出一个带有未知参数的函数$f$，其能预测未来点击次数。比如将函数写成<br>$$<br>y &#x3D; b + wx_1<br>$$<br>其中$y$是要预测的东西，$x_1$是输入的数据，而$w$跟$b$是未知的，$w$称为权重，$b$称为偏置。</p>\n<p><strong>第二个步骤</strong>是定义损失（loss），损失也是一个函数。这个函数的输入是模型里面的参数，模型是$y &#x3D; b + w ∗ x1$，而$b $跟$w $是未知的，损失是函数$L(b,w)$，其输入是模型参数$b $跟$w$，假设真是的结果是$\\hat{y}$。</p>\n<p>每一个数据的预测差距可以这么表示：<br>$$<br>e_i&#x3D;|y-\\hat{y}|<br>$$<br>把所有数据的差距加起来求平均就是损失：<br>$$<br>L&#x3D;\\frac{1}{N} \\sum_{n}<br>$$<br><strong>第三个步骤</strong>是找到一个最优解，找到一个$w$跟$b$能让损失尽可能小，让预测的结果跟真实的结果尽可能接近。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1L.jpg\"></p>\n<p>w在不同大小的时候会有不同的损失，为了让损失尽可能小，需要先随机找到一个初始点$w^0$，$w^0$就是这个时刻的切线斜率。</p>\n<p>把$w0 $往右移一步，新的位置为$w1$，这一步的步伐是$η(学习率) $乘上$L$关于$w$的偏微分的结果就是：<br>$$<br>w^1 &lt;&lt; w^0-η\\frac{\\partial{L}}{\\partial{w}}|(w&#x3D;w^0)<br>$$<br>接下来反复进行刚才的操作，最终求得最优解。当然这其中有很多策略和其他的知识点，对于我们要简单的了解深度学习来说是不需要探讨的。</p>\n<p>所以各位前辈大概已经清楚了机器学习损失反向传播的一种大致思维，这种反复对损失进行优化的过程，我们就把他简单的看成一个训练过程。</p>\n<h2 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h2><p>对于我们简单的了解深度学习来说，我们这里不讨论：过拟合、优化问题、交叉验证、局部极小值与鞍点、批量与动量、自适应与学习率。我们从全局来了解深度学习网络方便我们对CAI（生成式AI有所了解）。</p>\n<p>深度学习是机器学习的一个分支(最重要的分支)，我们之前假设机器学习就是简单的一个函数处理优化流程，这只是我总结的一个大貌，但各位前辈们如果有意深入了解会发现机器学习包含很多东西，我的总结也并不全对。</p>\n<p>这里我们假设深度学习是要处理信息的“水流”，处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。</p>\n<p>这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。</p>\n<p>而这一个一个的小水管都是可控制他们的水流速度，水流体积。我们也可以把每一个水管都当作一个函数，控制水流就靠w和b，而这些一个一个小函数，小的神经单元组成一个大的函数，大的神经网络。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C.png\"></p>\n<p>那么这么复杂的网络它带来的第一个优势就是他的学习能力强，表示覆盖的范围广，也同事让深度学习对计算量这些要求比较高。</p>\n<h2 id=\"卷积神经网络\"><a href=\"#卷积神经网络\" class=\"headerlink\" title=\"卷积神经网络\"></a>卷积神经网络</h2><p>我们从卷积神经网络（Convolutional Neural Network，CNN）开始，探讨网络的架构设计。卷积神经网络是一种非常典型的网络架构，常用于图像的处理等任务。</p>\n<p>对于卷积神经网络来说，我们不考虑池化下采样、上采样、反向传播这些内容，仅仅是了解它大致的一个处理思路。</p>\n<p>我们从一个图像分类任务入手，所谓图像分类，就是给机器一张图像，由机器去判断这张图像里面有什么样的东西——是猫还是狗、是飞机还是汽车。</p>\n<p>而怎么把图像作为模型的输入呢？？对于机器，图像可以描述为三维张量（我们可以把这个张量看作一个浮点型多维矩阵，存储在Double类型的数组里）。一张图像是一个三维的张量，其中一维代表图像的宽，另外一维代表图像的高，还有一维代表图像的通道（channel）的数目。</p>\n<p><small>channel是什么：彩色图像的每个像素都可以描述为红色（red）、绿色（green）、蓝色（blue）的组合，这3 种颜色就称为图像的3 个色彩通.</small></p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E8%BE%93%E5%85%A5.jpg\"></p>\n<p>我们可以看到把一个100$\\times$100像素的图片分解为rgb三个通道后，再把每个像素看成一个元素$x_i$，将这些元素展开拉平到一个1维数组中去，这个数组大小就是100$\\times$100$\\times$3。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN%E8%BE%93%E5%85%A5%E5%88%B0%E7%BD%91%E7%BB%9C.jpg\"></p>\n<p>对一个图像识别的类神经网络里面的神经元（每个水龙头）而言，它要做的就是检测图像里面有没有出现一些特别重要的模式（pattern），这些模式是代表了某种物件的。</p>\n<p>举例来说，如果现在有三个神经元分别看到鸟嘴、眼睛、鸟爪3 个模式，这就代表类神经网络看到了一只鸟。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%B8%9F%E8%AF%86%E5%88%AB1.jpg\"></p>\n<p>为了方便大家理解我们可以我用像素画了一只鸟，和一个过滤器来给大家演示。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%B8%9F.png\"></p>\n<p>我用visio随便画了只鸟，空白的格子我们姑且让他的值为0，右侧的卷积核（水龙头）通过一步步滑动窗口对图像矩阵的元素进行比对。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A81\" alt=\"image-20231003142939167\"></p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A82\" alt=\"image-20231003143036998\"></p>\n<p>最终找到极其相似的值，如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A83\" alt=\"image-20231003143105899\"></p>\n<p>这样就是卷积神经网络的滑动窗口，它像人一样，在识别或观察一个物体时从细微着手慢慢扫描。我们可以把这么一个卷积核作为一个水龙头，那么他同时就对应我们在机器学习介绍的一个函数，所以这个卷积核的权重也是可以学习的。</p>\n<p>对于卷积神经网络我想大家也只是明白了一个大致的流程，但我想这就够了，因为对于任何一个模型我们要深入都要花费很长的时间，而我也只能描述一些大概。来方便各位前辈了解CNN。</p>\n<h2 id=\"循环神经网络\"><a href=\"#循环神经网络\" class=\"headerlink\" title=\"循环神经网络\"></a>循环神经网络</h2><p>对于自然语言来说，我们每说一句话，每个单词与单词之间其实是有联系的。每个结果预测的输出结果其实都依赖之前的数据。比如一句话：我想吃饭。饭这个词很多时候是需要依赖前面的谓语。所以一个网络想要处理好自然语言，他是需要记忆功能的。这种有记忆的神经网络称为循环神经网络（Recurrent Neural Network，RNN）。在RNN里面，每一次隐藏层的神经元产生输出的时候，该输出会被存到记忆元（memory cell）中的蓝色方块表示记忆元。下一次有输入时，这些神经元不仅会考虑输入x1, x2，还会考虑存到记忆元里的值。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN.jpg\"></p>\n<p>接下来我简单的介绍一下RNN是怎么工作的。</p>\n<p>假如需要判断用户的说话意图，用户说了句“what time is it？”我们需要先对这句话进行分词：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN1.gif\"></p>\n<p>然后按照顺序输入 RNN ，我们先将 “what”作为 RNN 的输入，得到输出「01」</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN2.gif\"></p>\n<p>然后，我们按照顺序，将“time”输入到 RNN 网络，得到输出「02」。</p>\n<p>这个过程我们可以看到，输入 “time” 的时候，前面 <strong>“what” 的输出也产生了影响</strong>。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN3.gif\"></p>\n<p>以此类推，前面所有的输入都对未来的输出产生了影响，大家可以看到圆形隐藏层中包含了前面所有的颜色。如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN4.gif\"></p>\n<p>当我们判断意图的时候，只需要最后一层的输出「05」，如下图所示：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN5.gif\"></p>\n<p>通过上面的例子，我们已经发现，短期的记忆影响较大（如橙色区域），但是长期的记忆影响就很小（如黑色和绿色区域），这就是 RNN 存在的短期记忆问题。</p>\n<p>因此对于这些问题有很多RNN的变体，但是我们今天就不介绍了。</p>\n<h2 id=\"自注意力机制\"><a href=\"#自注意力机制\" class=\"headerlink\" title=\"自注意力机制\"></a>自注意力机制</h2><p>Attention（注意力）机制如果浅层的理解，跟他的名字非常匹配。他的核心逻辑就是<strong>“从关注全部到关注重点”</strong>。</p>\n<p>Attention 机制很像人类看图片的逻辑，当我们看一张图片的时候，我们并没有看清图片的全部内容，而是将注意力集中在了图片的焦点上。大家看一下下面这张图：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B1.png\"></p>\n<p>我们一定会看清“锦江饭店”4个字，但是我相信没人会意识到“锦江饭店”上面还有一串“电话号码”，也不会意识到“喜运来大酒家”。</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B.png\"></p>\n<p>所以，当我们看一张图片的时候，其实是这样的：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B2.png\"></p>\n<p>上面所说的，我们的视觉系统就是一种 Attention机制，<strong>将有限的注意力集中在重点信息上，从而节省资源，快速获得最有效的信息。</strong></p>\n<h3 id=\"AI领域注意力机制就是GPT最核心的组件：\"><a href=\"#AI领域注意力机制就是GPT最核心的组件：\" class=\"headerlink\" title=\"AI领域注意力机制就是GPT最核心的组件：\"></a>AI领域注意力机制就是GPT最核心的组件：</h3><p>如果用图来表达 Attention 的位置大致是下面的样子：</p>\n<p><img src=\"/imgs/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B3.png\"></p>\n<p>注意力机制的优势：</p>\n<p><strong>参数少</strong>：模型复杂度跟 CNN、RNN 相比，复杂度更小，参数也更少。所以对算力的要求也就更小。</p>\n<p><strong>速度快</strong>：Attention 解决了 RNN 不能并行计算的问题。Attention机制每一步计算不依赖于上一步的计算结果，因此可以和CNN一样并行处理。</p>\n<p><strong>效果好</strong>：在 Attention 机制引入之前，有一个问题大家一直很苦恼：长距离的信息会被弱化，就好像记忆能力弱的人，记不住过去的事情是一样的。</p>\n<p>Attention 是挑重点，就算文本比较长，也能从中间抓住重点，不丢失重要的信息。下图红色的预期就是被挑出来的重点。</p>\n<p>对于注意力的运算来说，其主要原理就是通过对数据集处理，获得三个矩阵，并且生成对应的权重向量，然后对进行相似度计算，之后进行归一化处理，出于对这篇文章最开始目的的把握，所以我不再介绍这些计算。</p>\n<h2 id=\"Transformer\"><a href=\"#Transformer\" class=\"headerlink\" title=\"Transformer\"></a>Transformer</h2><p>Transformer在2017年由Google在题为《Attention Is All You Need》的论文中提出。Transformer是一个完全基于注意力机制的编解码器模型，它抛弃了之前其它模型引入注意力机制后仍然保留的循环与卷积结构，而采用了自注意力（Self-attention）机制，在任务表现、并行能力和易于训练性方面都有大幅的提高。</p>\n<img src=\"/imgs/深度学习/Transformer.jpg\" style=\"zoom: 50%;\" />\n\n<p>如果CNN、RNN、注意力机制都算是一个基础的组件的话，那么Transformer就是一个模型了</p>\n<h2 id=\"生成对抗模型GAN\"><a href=\"#生成对抗模型GAN\" class=\"headerlink\" title=\"生成对抗模型GAN\"></a>生成对抗模型GAN</h2><h2 id=\"ChatGPT\"><a href=\"#ChatGPT\" class=\"headerlink\" title=\"ChatGPT\"></a>ChatGPT</h2><p>ChatGPT 真正在做的事情是什么呢？一言以蔽之就是做文字“接龙”，正确理解ChatGPT 的方式是它就是一个函数，就是输入一些东西，就输出一些东西。可以以一个句子作为输入，它输出这个句子后面应该接的词汇的概率。它会给每一个可能的符号一个概率。</p>\n<p>举例来说，如果输入是“什么是机器学习”，也许下一个可以接的中文词汇，概率比较高的是“机”，然后“器”和“好”也许有一些概率，那其他词汇的概率就很低。ChatGPT输出的是这样一个概率的分布，那ChatGPT 输出概率分布以后，接下来会从这个概率分布里面去做采样，根据这个概率分布去采样出一个词汇。举例来说“机”它的概率是最高的，所以从概率分布里面去采样词汇，采样到“机”的概率可能是比较大的，但也有可能采样到其他的词汇，所以这就是为什么ChatGPT 每次的答案都是不一样的，因为他每次产生答案的时候是有随机性的，它是从一个概率分布里面去做取样，所以他每次的答案都是不同的。</p>\n<h2 id=\"深度学习对底软的能力提升：\"><a href=\"#深度学习对底软的能力提升：\" class=\"headerlink\" title=\"深度学习对底软的能力提升：\"></a>深度学习对底软的能力提升：</h2><h3 id=\"代码生成\"><a href=\"#代码生成\" class=\"headerlink\" title=\"代码生成\"></a>代码生成</h3><h3 id=\"日志分析\"><a href=\"#日志分析\" class=\"headerlink\" title=\"日志分析\"></a>日志分析</h3><h3 id=\"代码查错\"><a href=\"#代码查错\" class=\"headerlink\" title=\"代码查错\"></a>代码查错</h3><h2 id=\"GAI对软硬件设计的影响\"><a href=\"#GAI对软硬件设计的影响\" class=\"headerlink\" title=\"GAI对软硬件设计的影响\"></a>GAI对软硬件设计的影响</h2><p>聊聊**生成式AI(GAI)**对今后<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件设计</a>的影响。看了很多业界人士对未来的预测和判断，都感觉有局限性。</p>\n<p>这两天在网上看到一篇让人脑洞大开的文章《ChatGPT会在10年内取代程序员》，文章提了两个人们在ChatGPT之类的GAI在软件开发方面的谬误。</p>\n<ul>\n<li>第一个谬误是“当前的AI会产生bug”，甚至有些代码还不能完全复制粘贴来使用，所以AI不会取代程序员。那么其实人也会产生bug（无论是有意为之还是为了保全工作）。所以有bug的代码并不会阻止GAI最终取代程序员。</li>\n<li>二个谬误观点是GAI是用来帮助程序员提高效率的工具。那么从老板的角度来看，如果有机器替代的话，高收入的程序员群体是老板眼中首先要节约的“成本”。尤其是因为软件工程是<strong>数字化的，可指数级扩展的工程问题</strong>。这类工作是AI替代的完美目标。</li>\n</ul>\n<p>作者对于未来的预测可以这么总结：</p>\n<p>阶段0：原型期（2023年第一季度）失业率预测：2%</p>\n<p>虽然当前chatGPT还仅仅是基于浏览器的AI工具且并不稳定，但当微软，谷歌以及每个科技和创业公司都想加入竞争的时候，chatGPT类的GAI演进速度会加快。那么当前受影响的是基于搜索的广告业务，<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件工程师</a>还比较安全。</p>\n<p>阶段1：规模化的<a href=\"https://www.zhihu.com/search?q=%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">集成开发环境</a>（IDE）渗透（2023年第二到第四季度） 失业率预测：5%</p>\n<p>这时Copilot，codex及众多的IDE GAI工具将会广泛使用。有大量的Java等语言的样板代码。AI拥有程序上下文分析的能力，GAI将会首先通过微软工具套件等形式被集成。生产力大幅提高，工程速度加快，但项目暂时不会因为提早完成而大量裁员。大多数人还有短暂的安全。</p>\n<p>阶段2：高级IDE工具开发与整合（1-2年）失业率预测：25%</p>\n<p>该阶段IDE会越来越强大，能分析整个代码库的上下文环境，并提供100%覆盖率的单元测试。编写程序的语言不再重要，用python快速实现的想法，瞬间可以被重写成其他效率更高的代码。真正的**工程清洗( engineering purge)**开始，低效的和拒绝AI的开发者将首当其冲。通用性的软件工程（如web前后端）将是多米诺骨牌的第一张，其次是手机应用开发。VR及游戏等专才仍然安全。</p>\n<p>阶段3：<a href=\"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">软件即服务</a>（SaaS）和无代码阶段（2-5年）失业率预测：75%</p>\n<p>阶段2所遗留下的代码库已经重新被重写和更换。存留下来的代码库在测试覆盖率，安全性及标准化等各个方面都全面碾压前人。软件将不再需要文档。AI一直在基于用户的使用模式，优化自身。软件开发更关注业务本身，一句话就可以生成类似今日头条类的新闻推送系统。没人做全栈了，移动设备<a href=\"https://www.zhihu.com/search?q=app%E5%BC%80%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">app开发</a>也消失了，开发者转向如机器人及生物技术等专业方向。不会编程的人士只要有好的业务想法，AI便可帮忙实现。</p>\n<p>阶段4: 原生AI（5-10年）失业率预测：95%</p>\n<p>这个阶段的代码不再由人类维护，单元测试和工程文档这类的事物也早都过时。AI代码并不需要使用人类能理解的汇编及高级语言。更原生的AI指令集会使得软硬件及编译器皆为AI所用，协同优化。写代码将会像公园里的<a href=\"https://www.zhihu.com/search?q=%E8%92%B8%E6%B1%BD%E7%81%AB%E8%BD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22618256622%22%7D\">蒸汽火车</a>一样，仅仅是为了缅怀和记忆。</p>\n<p>阶段5: 热寂（Heat Death）（10年以后）失业率预测：99%</p>\n<p>软件早已无法识别。AI原生标准已经全球化。钢铁侠般的实验室里，AI会通过跟你聊天来完成你想要完成的任务。web 3.0也会在AI的推动下提前到来。</p>\n<p>这些东西我们没法真正的预测，但对于底层软件工程师来说，写代码也仅仅只是最基础的环节。和硬件的交互，和各个流程的人沟通这些GAI都很难做到，我想，很多时候我们不能把我他以后发展真正的趋势，可以去拥抱他，先探索着利用他提升我们整体的效能。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clna0n6se0001lcwfg1tfc2a4","category_id":"clna0n6si0003lcwf4ccx3l6b","_id":"clna0n6sm000clcwfdcqf1ly1"}],"PostTag":[{"post_id":"clna0n6se0001lcwfg1tfc2a4","tag_id":"clna0n6si0004lcwffumoepq8","_id":"clna0n6sl0009lcwfawfh1p6w"},{"post_id":"clna0n6sg0002lcwfch4h0p3t","tag_id":"clna0n6sl0008lcwf9u945j80","_id":"clna0n6sm000elcwf52lkdvkj"},{"post_id":"clna0n6sj0005lcwfcc84g0qq","tag_id":"clna0n6sm000dlcwf65lj3enk","_id":"clna0n6sn000glcwf5go63m9y"},{"post_id":"clna0n6sk0006lcwf93kb7c1t","tag_id":"clna0n6sl0008lcwf9u945j80","_id":"clna0n6sn000ilcwf0ocf5m1x"},{"post_id":"clna0n6sk0007lcwf017w9pu3","tag_id":"clna0n6sn000hlcwf3symdf86","_id":"clna0n6so000klcwfej805n82"},{"post_id":"clna0n6sl000alcwf11r70m5q","tag_id":"clna0n6sm000dlcwf65lj3enk","_id":"clna0n6so000mlcwf3djfgqsw"},{"post_id":"clna0n6sm000blcwf35jwa08r","tag_id":"clna0n6so000llcwfdpjv6reg","_id":"clna0n6so000nlcwf7k4ogcor"}],"Tag":[{"name":"C","_id":"clna0n6si0004lcwffumoepq8"},{"name":"MetLee","_id":"clna0n6sl0008lcwf9u945j80"},{"name":"Linux Kernel Driver","_id":"clna0n6sm000dlcwf65lj3enk"},{"name":"生活注意事项","_id":"clna0n6sn000hlcwf3symdf86"},{"name":"Deep Learning","_id":"clna0n6so000llcwfdpjv6reg"}]}}