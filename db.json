{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","path":"imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","path":"imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","modified":1,"renderable":0},{"_id":"source/imgs/I2C驱动框架学习/I2C驱动框架.png","path":"imgs/I2C驱动框架学习/I2C驱动框架.png","modified":1,"renderable":0},{"_id":"source/imgs/头脑特工队/rilay1.png","path":"imgs/头脑特工队/rilay1.png","modified":1,"renderable":0},{"_id":"source/imgs/头脑特工队/rilay2.png","path":"imgs/头脑特工队/rilay2.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"ef057967805a3f389b38f5a530b8533bc1bd97f5","modified":1695823037930},{"_id":"source/_posts/I2C驱动框架学习.md","hash":"102c55143ac526efc801e9abe4366921e00cc17b","modified":1695986461202},{"_id":"source/_posts/Linux驱动-构造和运行模块个人学习总结.md","hash":"d06fc2fbb52ecf5cd155242ac8472b75d11e23b8","modified":1695955250803},{"_id":"source/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","hash":"a2a3f2c04a656db334d6a0577297469ceaf288e3","modified":1695985037875},{"_id":"source/_posts/头脑特工队观赏报告-重要.md","hash":"1bd2cbeb00ce110e3f98d2f427c254030344e81b","modified":1695992083066},{"_id":"source/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","hash":"3a8ea5d0782a4f95fd7bdf14ed41653526fae901","modified":1695984344029},{"_id":"source/imgs/I2C驱动框架学习/I2C驱动框架.png","hash":"523d20cbb4d764190a041c57e19ee9701d08fd33","modified":1695984591738},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1695825738249},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1695825738249},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1695825738249},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1695825738249},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1695825738249},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1695825738249},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1695825738249},{"_id":"themes/next/_config.yml","hash":"a2a7887f165a471fda522c376431f9beb4fd492b","modified":1695826164422},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1695825738249},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1695825738249},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1695825738265},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1695825738302},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1695825738249},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1695825738249},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1695825738249},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1695825738249},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1695825738249},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1695825738249},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1695825738249},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1695825738249},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1695825738249},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1695825738249},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1695825738249},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1695825738249},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1695825738249},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1695825738265},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1695825738265},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1695825738265},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1695825738265},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1695825738265},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1695825738265},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1695825738265},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1695825738265},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1695825738265},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1695825738265},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1695825738265},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1695825738265},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1695825738265},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1695825738265},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1695825738265},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1695825738265},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1695825738265},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1695825738265},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1695825738265},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1695825738265},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1695825738265},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1695825738265},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1695825738265},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1695825738265},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1695825738265},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1695825738265},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1695825738265},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1695825738265},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1695825738265},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1695825738265},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1695825738302},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1695825738302},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1695825738302},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1695825738302},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1695825738302},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1695825738302},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1695825738302},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1695825738249},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1695825738249},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1695825738249},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1695825738249},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1695825738265},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1695825738265},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1695825738265},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1695825738265},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1695825738265},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1695825738280},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1695825738280},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1695825738280},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1695825738280},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1695825738280},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1695825738280},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1695825738280},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1695825738287},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1695825738287},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1695825738287},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1695825738287},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1695825738287},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1695825738287},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1695825738287},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1695825738287},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1695825738287},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1695825738287},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1695825738302},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1695825738302},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1695825738302},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1695825738302},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1695825738302},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1695825738302},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1695825738302},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1695825738302},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1695825738302},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1695825738302},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1695825738302},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1695825738302},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1695825738302},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1695825738302},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1695825738302},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1695825738302},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1695825738302},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1695825738302},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1695825738302},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1695825738302},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1695825738302},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1695825738334},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1695825738334},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1695825738334},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1695825738334},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1695825738349},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1695825738349},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1695825738349},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1695825738349},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1695825738349},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1695825738349},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1695825738349},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1695825738349},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1695825738349},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1695825738349},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1695825738349},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1695825738349},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1695825738349},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1695825738349},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1695825738349},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1695825738349},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1695825738366},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1695825738366},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1695825738280},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1695825738280},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1695825738280},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1695825738280},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1695825738280},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1695825738280},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1695825738280},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1695825738280},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1695825738280},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1695825738280},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1695825738287},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1695825738280},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1695825738287},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1695825738287},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1695825738287},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1695825738287},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1695825738287},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1695825738287},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1695825738287},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1695825738287},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1695825738287},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1695825738287},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1695825738287},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1695825738287},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1695825738287},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1695825738287},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1695825738287},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1695825738287},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1695825738287},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1695825738287},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1695825738287},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1695825738287},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1695825738287},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1695825738287},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1695825738287},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1695825738287},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1695825738287},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1695825738287},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1695825738287},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1695825738302},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1695825738302},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1695825738302},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1695825738302},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1695825738302},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1695825738302},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1695825738302},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1695825738302},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1695825738334},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1695825738334},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1695825738334},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1695825738334},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1695825738334},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1695825738366},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1695825738366},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1695825738387},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1695825738387},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1695825738302},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1695825738318},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1695825738318},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1695825738334},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1695825738334},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1695825738366},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1695825738366},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1695825738318},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1695825738318},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1695825738318},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1695825738334},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1695825738334},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1695825738366},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1695825738387},{"_id":"source/imgs/头脑特工队/rilay2.png","hash":"84837115c382196fc5929199d0e50097c3b5ca59","modified":1695991475287},{"_id":"source/imgs/头脑特工队/rilay1.png","hash":"64550a21afaa61c6df1b612f4c5fffc8ec9913ab","modified":1695991465093},{"_id":"public/2023/09/29/头脑特工队观赏报告-重要/index.html","hash":"41cd40f6d5a7eeee4e582951ed7ad9e8b5c35aee","modified":1695992560860},{"_id":"public/2023/09/29/Linux驱动-构造和运行模块个人学习总结/index.html","hash":"11847a64c5630a89fc3d8f6a5afaba0424bf1124","modified":1695992560860},{"_id":"public/archives/index.html","hash":"674b32fa44172b1a88c4396a379e41780e46db25","modified":1695992560860},{"_id":"public/archives/2023/index.html","hash":"6703977ff7229079914e5121071b1871ec541a0d","modified":1695992560860},{"_id":"public/2023/09/28/I2C驱动框架学习/index.html","hash":"dd3f31969dca5a39ec64727058923bea169a10a0","modified":1695992560860},{"_id":"public/archives/2023/09/index.html","hash":"e975391e6fe206988b47c1db25b3110ba88b49dd","modified":1695992560860},{"_id":"public/index.html","hash":"a7de77a6661833525a5a05c323a0d2a982e26184","modified":1695992560860},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1695992560860},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1695992560860},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1695992560860},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1695992560860},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1695992560860},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1695992560860},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1695992560860},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1695992560860},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1695992560860},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1695992560860},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1695992560860},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1695992560860},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1695992560860},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1695992560860},{"_id":"public/CNAME","hash":"ef057967805a3f389b38f5a530b8533bc1bd97f5","modified":1695992560860},{"_id":"public/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png","hash":"a2a3f2c04a656db334d6a0577297469ceaf288e3","modified":1695992560860},{"_id":"public/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif","hash":"3a8ea5d0782a4f95fd7bdf14ed41653526fae901","modified":1695992560860},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1695992560860},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1695992560860},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1695992560860},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1695992560860},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1695992560860},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1695992560860},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1695992560860},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1695992560860},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1695992560860},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1695992560860},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1695992560860},{"_id":"public/css/main.css","hash":"982f9820f73be58c0dc18c1c4f40a10f26cac1ab","modified":1695992560860},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1695992560860},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1695992560860},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1695992560860},{"_id":"public/imgs/I2C驱动框架学习/I2C驱动框架.png","hash":"523d20cbb4d764190a041c57e19ee9701d08fd33","modified":1695992560860},{"_id":"public/imgs/头脑特工队/rilay1.png","hash":"64550a21afaa61c6df1b612f4c5fffc8ec9913ab","modified":1695992560860},{"_id":"public/imgs/头脑特工队/rilay2.png","hash":"84837115c382196fc5929199d0e50097c3b5ca59","modified":1695992560860}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Linux驱动-构造和运行模块个人学习总结","date":"2023-09-29T02:40:26.000Z","typora-root-url":"./..","_content":"","source":"_posts/Linux驱动-构造和运行模块个人学习总结.md","raw":"---\ntitle: Linux驱动-构造和运行模块个人学习总结\ndate: 2023-09-29 10:40:26\ntags:\ntypora-root-url: ./..\n---\n","slug":"Linux驱动-构造和运行模块个人学习总结","published":1,"updated":"2023-09-29T02:40:50.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln4m6ju60000esw80k72g22i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"头脑特工队观赏报告(重要)","date":"2023-09-29T11:24:05.000Z","typora-root-url":"./..","_content":"\n\n\n被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。\n\n![](/imgs/头脑特工队/rilay2.png)\n\n我打了好多好多字啊，\n\n可我都删了。\n\n我想说很多话，有时候都说不出来。\n\n就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。\n\n内心的复杂，是多么纤细而又值得赞颂的。\n\n”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。\n\n![](/imgs/头脑特工队/rilay1.png)\n\nRilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。\n\n我以为我会一直这样，直到我兜兜转转。\n\n遇到你的时候，\n\n我发现我好想跟你玩啊？\n\n我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？\n\n你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。\n\n哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，\n\n原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。\n\n那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。\n\n谢谢你，lyh，带给我这么多完整的情绪。\n\n\n\n搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。\n\n头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。\n","source":"_posts/头脑特工队观赏报告-重要.md","raw":"---\ntitle: 头脑特工队观赏报告(重要)\ndate: 2023-09-29 19:24:05\ntags:\ntypora-root-url: ./..\n---\n\n\n\n被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。\n\n![](/imgs/头脑特工队/rilay2.png)\n\n我打了好多好多字啊，\n\n可我都删了。\n\n我想说很多话，有时候都说不出来。\n\n就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。\n\n内心的复杂，是多么纤细而又值得赞颂的。\n\n”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。\n\n![](/imgs/头脑特工队/rilay1.png)\n\nRilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。\n\n我以为我会一直这样，直到我兜兜转转。\n\n遇到你的时候，\n\n我发现我好想跟你玩啊？\n\n我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？\n\n你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。\n\n哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，\n\n原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。\n\n那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。\n\n谢谢你，lyh，带给我这么多完整的情绪。\n\n\n\n搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。\n\n头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。\n","slug":"头脑特工队观赏报告-重要","published":1,"updated":"2023-09-29T12:54:43.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln4m6jue0001esw80cg19kgn","content":"<p>被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay2.png\"></p>\n<p>我打了好多好多字啊，</p>\n<p>可我都删了。</p>\n<p>我想说很多话，有时候都说不出来。</p>\n<p>就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。</p>\n<p>内心的复杂，是多么纤细而又值得赞颂的。</p>\n<p>”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png\"></p>\n<p>Rilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。</p>\n<p>我以为我会一直这样，直到我兜兜转转。</p>\n<p>遇到你的时候，</p>\n<p>我发现我好想跟你玩啊？</p>\n<p>我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？</p>\n<p>你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。</p>\n<p>哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，</p>\n<p>原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。</p>\n<p>那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。</p>\n<p>谢谢你，lyh，带给我这么多完整的情绪。</p>\n<p>搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。</p>\n<p>头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay2.png\"></p>\n<p>我打了好多好多字啊，</p>\n<p>可我都删了。</p>\n<p>我想说很多话，有时候都说不出来。</p>\n<p>就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。</p>\n<p>内心的复杂，是多么纤细而又值得赞颂的。</p>\n<p>”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。</p>\n<p><img src=\"/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png\"></p>\n<p>Rilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。</p>\n<p>我以为我会一直这样，直到我兜兜转转。</p>\n<p>遇到你的时候，</p>\n<p>我发现我好想跟你玩啊？</p>\n<p>我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？</p>\n<p>你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。</p>\n<p>哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，</p>\n<p>原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。</p>\n<p>那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。</p>\n<p>谢谢你，lyh，带给我这么多完整的情绪。</p>\n<p>搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。</p>\n<p>头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。</p>\n"},{"title":"I2C驱动框架学习","date":"2023-09-28T13:43:49.000Z","typora-root-url":"./..","_content":"\n# I2C通信：\n**I2C集成电路总线是一种串行的通信总线，使用主从架构**\n特点：\n只需要两条双向总线（SDA串行数据线、SCL串行时钟线）\n所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。\nI2C是真正的多主设备总线，可以提供仲裁和冲突检测。\n\n### CAN总线仲裁：\nCAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。\n当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。\nCAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。\n![](/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif)\n如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。\n\n### 数据传输协议：\n主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。\n\n#### 开始条件：\n主设备要开始通信时发送开始信号，执行：\n将SDA线从高压电平转换到低压电平\n将SCL从高电平切换成低压电平\n\n**地址位**：\n\n主机向从机发送/接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。\n\n**读写位**：\n\n指定数据传输方向：主-->从，该位为0。从-->主，该位为1。\n\n**ACK**/**NACK**：\n\n主机每次发送完数据之后会等待从设备的应答信号ACK。\n如果从设备发送应答信号ACK，则SDA会被拉低；\n若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；\n\n**数据块**：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK/NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。\n\n**停止条件**：先将SDA线从低电压电平切换到高电压电平；\n再将SCL线从高电平拉到低电平。\n\n### 架构层次分类\n\n![](/imgs/I2C驱动框架学习/I2C驱动框架.png)\n\n##### 第一层：\n\n提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层\n\n##### 第二层：\n\n提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层\n\n###### 第三层：\n\n实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层\n\n##### 第四层：\n\n实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层\n\n第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c\n\n第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。\n\n#### 具体分析\ni2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。\n\n看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解\n\n##### i2c_driver\n\n```c\nstruct i2c_driver {\n\tint id;\n\tunsigned int class;\n \n\tint (*attach_adapter)(struct i2c_adapter *);\n\tint (*detach_adapter)(struct i2c_adapter *);\n \n\tint (*detach_client)(struct i2c_client *);\n \n\tint (*command)(struct i2c_client *client,unsigned int cmd, void *arg);\n\tstruct device_driver driver;\n\tstruct list_head list;\n};\n```\n};\n##### i2c_client\n\n```c\nstruct i2c_client {\n\tunsigned int flags;\t\t/* div., see below\t\t*/\n\tunsigned short addr;\t\t/* chip address - NOTE: 7bit \t*/\n\t\t\t\t\t/* addresses are stored in the\t*/\n\t\t\t\t\t/* _LOWER_ 7 bits\t\t*/\n\tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/\n\tstruct i2c_driver *driver;\t/* and our access routines\t*/\n\tint usage_count;\t\t/* How many accesses currently  */\n\t\t\t\t\t/* to the client\t\t*/\n\tstruct device dev;\t\t/* the device structure\t\t*/\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion released;\n};\n```\n\n##### i2c_adapter\n\n```c\nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int id;\n\tunsigned int class;\n\tstruct i2c_algorithm *algo;/* the algorithm to access the bus\t*/\n\tvoid *algo_data;\n \n\t/* --- administration stuff. */\n\tint (*client_register)(struct i2c_client *);\n\tint (*client_unregister)(struct i2c_client *);\n \n\t/* data fields that are valid for all devices\t*/\n\tstruct mutex bus_lock;\n\tstruct mutex clist_lock;\n \n\tint timeout;\n\tint retries;\n\tstruct device dev;\t\t/* the adapter device */\n\tstruct class_device class_dev;\t/* the class device */\n \n\tint nr;\n\tstruct list_head clients;\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion dev_released;\n\tstruct completion class_dev_released;\n};\n```\n##### i2c_algorithm\n\n```c\nstruct i2c_algorithm {\n\tint (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, \n\t                   int num);\n\tint (*slave_send)(struct i2c_adapter *,char*,int);\n\tint (*slave_recv)(struct i2c_adapter *,char*,int);\n\tu32 (*functionality) (struct i2c_adapter *);\n};\n```\n\n##### 【i2c_adapter与i2c_algorithm】\ni2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。\n\ni2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体\n\n \t/*\n \t * I2C Message - used for pure i2c transaction, also from /dev interface\n \t */\n \tstruct i2c_msg {\n \t\t__u16 addr;\t/* slave address\t\t\t*/\n \t \t__u16 flags;\t\t\n \t \t__u16 len;\t\t/* msg length\t\t\t\t*/\n \t \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n \t};\n\n##### 【i2c_driver和i2c_client】\ni2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.\n\n##### 【i2c_adapter和i2c_client】\n\ni2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。\n从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。\n\n我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c\n\n```c\nEXPORT_SYMBOL(i2c_add_adapter);\nEXPORT_SYMBOL(i2c_del_adapter);\nEXPORT_SYMBOL(i2c_del_driver);\nEXPORT_SYMBOL(i2c_attach_client);\nEXPORT_SYMBOL(i2c_detach_client);\n\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。\n\n```c\nint i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tif (adap->algo->master_xfer) {//如果master_xfer函数存在，则调用，否则返回错误\n\t\tret = adap->algo->master_xfer(adap,msgs,num);//这个函数在硬件相关的代码中给algorithm赋值\n\t\treturn ret;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n```\n\n当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下\n\n```c\nint i2c_attach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_register(&client->dev);\n\tdevice_create_file(&client->dev, &dev_attr_client_name);\n\t...\n\treturn 0;\n}\n```\n\n```c\nint i2c_detach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_remove_file(&client->dev, &dev_attr_client_name);\n\tdevice_unregister(&client->dev);\n\t...\n\treturn res;\n}\n```\n\ni2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用\n\n```c\n/* -----\n * i2c_add_adapter is called from within the algorithm layer,\n * when a new hw adapter registers. A new device is register to be\n * available for clients.\n */\nint i2c_add_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tdevice_register(&adap->dev);\n\tdevice_create_file(&adap->dev, &dev_attr_name);\n\t...\n\t/* inform drivers of new adapters */\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->attach_adapter)\n\t\t\t/* We ignore the return code; if it fails, too bad */\n\t\t\tdriver->attach_adapter(adap);\n\t}\n\t...\n}\n```\n\n```c\nint i2c_del_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->detach_adapter)\n\t\t\tif ((res = driver->detach_adapter(adap))) {\n\t\t\t}\n\t}\n\t...\n\tlist_for_each_safe(item, _n, &adap->clients) {\n\t\tclient = list_entry(item, struct i2c_client, list);\n \n\t\tif ((res=client->driver->detach_client(client))) {\n \n\t\t}\n\t}\n\t...\n\tdevice_remove_file(&adap->dev, &dev_attr_name);\n\tdevice_unregister(&adap->dev);\n \n}\n```\n\ni2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的\n\n```c\nstatic struct platform_driver davinci_i2c_driver = {\n\t.probe\t\t= davinci_i2c_probe,\n\t.remove\t\t= davinci_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_davinci\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n \n/* I2C may be needed to bring up other drivers */\nstatic int __init davinci_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&davinci_i2c_driver);\n}\nsubsys_initcall(davinci_i2c_init_driver);\n \nstatic void __exit davinci_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&davinci_i2c_driver);\n}\nmodule_exit(davinci_i2c_exit_driver);\n```\n\n并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器\n\n```c\nstatic struct i2c_algorithm i2c_davinci_algo = {\n\t.master_xfer\t= i2c_davinci_xfer,\n\t.functionality\t= i2c_davinci_func,\n};\n```\n\n然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中\n\n```c\nadap->algo = &i2c_davinci_algo;\n```\n\n\n### 梳理图\n有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:\n\n\n![](/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png)\n\nlinux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。\n\n在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。\n\n#### ov2715设备i2c驱动源码分析\nov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。\n该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。\n该字符设备的用到的结构体有两个，如下\n\n```c\ntypedef struct {\n\n  int devAddr;\n\n  struct i2c_client client;   //!< Data structure containing general access routines.\n  struct i2c_driver driver;   //!< Data structure containing information specific to each client.\n\n  char name[20];\n  int nameSize;\n  int users;\n\n} I2C_Obj;\n```\n\n```c\n#define I2C_DEV_MAX_ADDR  (0xFF)\n#define I2C_TRANSFER_BUF_SIZE_MAX   (256)\ntypedef struct {\n \n  struct cdev cdev;             /* Char device structure    */\n  int     major;\n  struct semaphore semLock;\n    \n  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];\n \n  uint8_t reg[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint16_t reg16[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint8_t buffer[I2C_TRANSFER_BUF_SIZE_MAX*4];\n  \n} I2C_Dev;\n```\n\n一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值\n使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。\n下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。\n首先是该字符设备的初始化和退出函数\n\n```c\nint I2C_devInit(void)\n{\n  int     result, i;\n  dev_t   dev = 0;\n \n  result = alloc_chrdev_region(&dev, 0, 1, I2C_DRV_NAME);//分配字符设备空间\n  \n  for(i=0; i<I2C_DEV_MAX_ADDR; i++)\n  {\n    gI2C_dev.pObj[i]=NULL;\n  }\n \n  gI2C_dev.major = MAJOR(dev);//保存设备主编号\n  sema_init(&gI2C_dev.semLock, 1);//信号量初始化\n  cdev_init(&gI2C_dev.cdev, &gI2C_devFileOps);//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文\n  gI2C_dev.cdev.owner = THIS_MODULE;//常规赋值\n gI2C_dev.cdev.ops = &gI2C_devFileOps;//常规赋值 result = cdev_add(&gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;}void I2C_devExit(void){ dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间}\ngI2c_devFileOps全局变量，驱动初始化会用到该结构体变量\nstruct file_operations gI2C_devFileOps = {\n  .owner = THIS_MODULE,\n  .open = I2C_devOpen,\n  .release = I2C_devRelease,\n  .ioctl = I2C_devIoctl,\n};\n```\n\n该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。\n在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）\n\n```c\nint I2C_devIoctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\n{\n  I2C_Obj *pObj;\n  int status=0;\n  I2C_TransferPrm transferPrm;\n  \n  pObj = (I2C_Obj *)filp->private_data;\n \n  if(!I2C_IOCTL_CMD_IS_VALID(cmd))\n    return -1;\n  cmd = I2C_IOCTL_CMD_GET(cmd);//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd\n \n  down_interruptible(&gI2C_dev.semLock);      //信号量down\n  \n  switch(cmd)\n  {\n    case I2C_CMD_SET_DEV_ADDR://命令1，设置设备地址\n      filp->private_data = I2C_create(arg);\n \n    case I2C_CMD_WRITE:  //命令2，写寄存器值\n      \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n            \n      break;\n    case I2C_CMD_READ:  //命令3，读寄存器值\n    \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n      \n      break;\n    default:\n      status = -1;\n      break;    \n  }\n \n  up(&gI2C_dev.semLock);      //信号量up\n \n  return status;\n}\n```\n\n以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码\n\n```c\nvoid *I2C_create(int devAddr) {\n \n    int ret;\n    struct i2c_driver *driver;\n    struct i2c_client *client = client;\n    I2C_Obj *pObj;\n \n    devAddr >>= 1;\n    \n    if(devAddr>I2C_DEV_MAX_ADDR)  //变量合法性判断\n      return NULL;\n   \n    if(gI2C_dev.pObj[devAddr]!=NULL) {\t//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用\n      // already allocated, increment user count, and return the allocated handle\n      gI2C_dev.pObj[devAddr]->users++;\n      return gI2C_dev.pObj[devAddr];\n    }\n    \n    pObj = (void*)kmalloc( sizeof(I2C_Obj), GFP_KERNEL); //为pObj分配空间\n    gI2C_dev.pObj[devAddr] = pObj;  //将分配的空间地址保存在全局变量里\n    memset(pObj, 0, sizeof(I2C_Obj));\n  \n    pObj->client.adapter = NULL;\n    pObj->users++;    //用户基数，初始化为0，当前设为1\n    pObj->devAddr = devAddr;  //保存设备地址\n    \n    gI2C_curAddr = pObj->devAddr;  //gI2C_curAddr为全局的整型变量，用于保存当前的设备地址\n    driver = &pObj->driver;  //将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动\n \n    pObj->nameSize=0;//i2c设备名称，注意，这里不是在/dev下面的设备节点名\n    pObj->name[pObj->nameSize++] = 'I';\n    pObj->name[pObj->nameSize++] = '2';\n    pObj->name[pObj->nameSize++] = 'C';\n    pObj->name[pObj->nameSize++] = '_';   \n    pObj->name[pObj->nameSize++] = 'A' + ((pObj->devAddr >> 0) & 0xF);\n    pObj->name[pObj->nameSize++] = 'B' + ((pObj->devAddr >> 4) & 0xF);\n    pObj->name[pObj->nameSize++] = 0;\n \n    driver->driver.name = pObj->name; //保存刚才设置的name\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;   //这个很重要，将驱动连接到i2c适配器上，在后面分析\n    driver->detach_client = I2C_detachClient;\t//这个很重，在后面分析\n \n    if((ret = i2c_add_driver(driver)))\t//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()\n    {\n        printk( KERN_ERR \"I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n\", pObj->devAddr);\n    }\n \n    if(ret<0) {\n \n      gI2C_dev.pObj[pObj->devAddr] = NULL;\n      kfree(pObj);    \n      return NULL;\n    }\n    return pObj;\n}\n```\n\n其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()\n\n```c\nint I2C_write(I2C_Obj *pObj, uint8_t *reg, uint8_t *buffer, uint8_t count, uint8_t dataSize)\n{\n  uint8_t i;\n  int err;\n  struct i2c_client *client;\n\tstruct i2c_msg msg[1];\n\tunsigned char data[8];\n \n  if(pObj==NULL)\n    return -ENODEV;\n \n  client = &pObj->client;//得到client信息\n  if(!client->adapter)\n    return -ENODEV;  \n  \n  if(dataSize<=0||dataSize>4)\n    return -1;\n    \n  for(i=0; i<count; i++) {\n  \n    msg->addr = client->addr;//设置要写的i2c设备地址\n    msg->flags= 0;//一直为0\n    msg->buf  = data;//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值\n\t\t\n    data[0] = reg[i];//寄存器地址赋值\n\t\t\n    if(dataSize==1) {//寄存器值长度为1\n       data[1]  = buffer[i];//寄存器值赋值\n       msg->len = 2;  \t//设置data长度为2\t\n    }\telse if(dataSize==2) {//寄存器值长度为2\n       data[1] = buffer[2*i+1];\n       data[2] = buffer[2*i];\n       msg->len = 3;\n    } \n    err = i2c_transfer(client->adapter, msg, 1);//调用i2c-core中的i2c_transfer发送i2c数据\n    if( err < 0 )\n      return err;\n    }\n  \n  return 0;\n}\n```\n\n重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的\n\n```c\n    driver->driver.name = pObj->name;\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;\n    driver->detach_client = I2C_detachClient;\n```\n在i2c_driver结构体中针对attach_adapter有这样的说明：\n\n```c\n\t/* Notifies the driver that a new bus has appeared. This routine\n\t * can be used by the driver to test if the bus meets its conditions\n\t * & seek for the presence of the chip(s) it supports. If found, it \n\t * registers the client(s) that are on the bus to the i2c admin. via\n\t * i2c_attach_client.\n\t */\n```\n\n意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示\n\n```c\nint I2C_attachAdapter(struct i2c_adapter *adapter)\n{\n    return I2C_detectClient(adapter, gI2C_curAddr);\n}\n \nint I2C_detectClient(struct i2c_adapter *adapter, int address)\n{\n    I2C_Obj *pObj;\n    struct i2c_client *client;\n    int err = 0;\n    \n    if(address > I2C_DEV_MAX_ADDR) {\n      printk( KERN_ERR \"I2C: ERROR: Invalid device address %x\\n\", address);        \n      return -1;\n    }\n      \n    pObj = gI2C_dev.pObj[address];\n    if(pObj==NULL) {\n      printk( KERN_ERR \"I2C: ERROR: Object not found for address %x\\n\", address);    \n      return -1;\n    }\n \n    client = &pObj->client;\n \n    if(client->adapter)\n      return -EBUSY;  /* our client is already attached */\n \n    memset(client, 0x00, sizeof(struct i2c_client));\n    client->addr = pObj->devAddr;\n    client->adapter = adapter;\n    client->driver = &pObj->driver;\n \n    if((err = i2c_attach_client(client)))\n    {\n        printk( KERN_ERR \"I2C: ERROR: Couldn't attach %s (address=%x)\\n\", pObj->name, pObj->devAddr);\n        client->adapter = NULL;\n        return err;\n    }\n    return 0;\n}\n```\n最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。\n当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：\n\n```c\n\t/* tells the driver that a client is about to be deleted & gives it \n\t * the chance to remove its private data. Also, if the client struct\n\t * has been dynamically allocated by the driver in the function above,\n\t * it must be freed here.\n\t */\n```\n\n下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接\n\n```c\nint I2C_detachClient(struct i2c_client *client)\n{\n    int err;\nif(!client->adapter)\n    return -ENODEV; /* our client isn't attached */\n \nif((err = i2c_detach_client(client))) {\n    printk( KERN_ERR \"Client deregistration failed (address=%x), client not detached.\\n\", client->addr);\n    return err;\n}\n \nclient->adapter = NULL;\n \nreturn 0;\n```\n}\n\n\n\n\n\n\n\n\n<small>misslyh20080512202305122023080719980106202309281520825879280398965</small>\n","source":"_posts/I2C驱动框架学习.md","raw":"---\ntitle: I2C驱动框架学习\ndate: 2023-09-28 21:43:49\ntags:\ntypora-root-url: ./..\n---\n\n# I2C通信：\n**I2C集成电路总线是一种串行的通信总线，使用主从架构**\n特点：\n只需要两条双向总线（SDA串行数据线、SCL串行时钟线）\n所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。\nI2C是真正的多主设备总线，可以提供仲裁和冲突检测。\n\n### CAN总线仲裁：\nCAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。\n当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。\nCAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。\n![](/imgs/I2C驱动框架学习/CAN总线节点访问过程.gif)\n如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。\n\n### 数据传输协议：\n主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。\n\n#### 开始条件：\n主设备要开始通信时发送开始信号，执行：\n将SDA线从高压电平转换到低压电平\n将SCL从高电平切换成低压电平\n\n**地址位**：\n\n主机向从机发送/接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。\n\n**读写位**：\n\n指定数据传输方向：主-->从，该位为0。从-->主，该位为1。\n\n**ACK**/**NACK**：\n\n主机每次发送完数据之后会等待从设备的应答信号ACK。\n如果从设备发送应答信号ACK，则SDA会被拉低；\n若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；\n\n**数据块**：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK/NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。\n\n**停止条件**：先将SDA线从低电压电平切换到高电压电平；\n再将SCL线从高电平拉到低电平。\n\n### 架构层次分类\n\n![](/imgs/I2C驱动框架学习/I2C驱动框架.png)\n\n##### 第一层：\n\n提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层\n\n##### 第二层：\n\n提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层\n\n###### 第三层：\n\n实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层\n\n##### 第四层：\n\n实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层\n\n第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录/drivers/i2c/buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为/drivers/i2c/buses/i2c-s3c2410.c\n\n第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。\n\n#### 具体分析\ni2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。\n\n看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解\n\n##### i2c_driver\n\n```c\nstruct i2c_driver {\n\tint id;\n\tunsigned int class;\n \n\tint (*attach_adapter)(struct i2c_adapter *);\n\tint (*detach_adapter)(struct i2c_adapter *);\n \n\tint (*detach_client)(struct i2c_client *);\n \n\tint (*command)(struct i2c_client *client,unsigned int cmd, void *arg);\n\tstruct device_driver driver;\n\tstruct list_head list;\n};\n```\n};\n##### i2c_client\n\n```c\nstruct i2c_client {\n\tunsigned int flags;\t\t/* div., see below\t\t*/\n\tunsigned short addr;\t\t/* chip address - NOTE: 7bit \t*/\n\t\t\t\t\t/* addresses are stored in the\t*/\n\t\t\t\t\t/* _LOWER_ 7 bits\t\t*/\n\tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/\n\tstruct i2c_driver *driver;\t/* and our access routines\t*/\n\tint usage_count;\t\t/* How many accesses currently  */\n\t\t\t\t\t/* to the client\t\t*/\n\tstruct device dev;\t\t/* the device structure\t\t*/\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion released;\n};\n```\n\n##### i2c_adapter\n\n```c\nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int id;\n\tunsigned int class;\n\tstruct i2c_algorithm *algo;/* the algorithm to access the bus\t*/\n\tvoid *algo_data;\n \n\t/* --- administration stuff. */\n\tint (*client_register)(struct i2c_client *);\n\tint (*client_unregister)(struct i2c_client *);\n \n\t/* data fields that are valid for all devices\t*/\n\tstruct mutex bus_lock;\n\tstruct mutex clist_lock;\n \n\tint timeout;\n\tint retries;\n\tstruct device dev;\t\t/* the adapter device */\n\tstruct class_device class_dev;\t/* the class device */\n \n\tint nr;\n\tstruct list_head clients;\n\tstruct list_head list;\n\tchar name[I2C_NAME_SIZE];\n\tstruct completion dev_released;\n\tstruct completion class_dev_released;\n};\n```\n##### i2c_algorithm\n\n```c\nstruct i2c_algorithm {\n\tint (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs, \n\t                   int num);\n\tint (*slave_send)(struct i2c_adapter *,char*,int);\n\tint (*slave_recv)(struct i2c_adapter *,char*,int);\n\tu32 (*functionality) (struct i2c_adapter *);\n};\n```\n\n##### 【i2c_adapter与i2c_algorithm】\ni2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。\n\ni2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体\n\n \t/*\n \t * I2C Message - used for pure i2c transaction, also from /dev interface\n \t */\n \tstruct i2c_msg {\n \t\t__u16 addr;\t/* slave address\t\t\t*/\n \t \t__u16 flags;\t\t\n \t \t__u16 len;\t\t/* msg length\t\t\t\t*/\n \t \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n \t};\n\n##### 【i2c_driver和i2c_client】\ni2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.\n\n##### 【i2c_adapter和i2c_client】\n\ni2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。\n从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。\n\n我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录/driver/i2c/i2c-core.c\n\n```c\nEXPORT_SYMBOL(i2c_add_adapter);\nEXPORT_SYMBOL(i2c_del_adapter);\nEXPORT_SYMBOL(i2c_del_driver);\nEXPORT_SYMBOL(i2c_attach_client);\nEXPORT_SYMBOL(i2c_detach_client);\n\nEXPORT_SYMBOL(i2c_transfer);\n```\n\ni2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。\n\n```c\nint i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tif (adap->algo->master_xfer) {//如果master_xfer函数存在，则调用，否则返回错误\n\t\tret = adap->algo->master_xfer(adap,msgs,num);//这个函数在硬件相关的代码中给algorithm赋值\n\t\treturn ret;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n```\n\n当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下\n\n```c\nint i2c_attach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_register(&client->dev);\n\tdevice_create_file(&client->dev, &dev_attr_client_name);\n\t...\n\treturn 0;\n}\n```\n\n```c\nint i2c_detach_client(struct i2c_client *client)\n{\n\t...\n\tdevice_remove_file(&client->dev, &dev_attr_client_name);\n\tdevice_unregister(&client->dev);\n\t...\n\treturn res;\n}\n```\n\ni2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用\n\n```c\n/* -----\n * i2c_add_adapter is called from within the algorithm layer,\n * when a new hw adapter registers. A new device is register to be\n * available for clients.\n */\nint i2c_add_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tdevice_register(&adap->dev);\n\tdevice_create_file(&adap->dev, &dev_attr_name);\n\t...\n\t/* inform drivers of new adapters */\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->attach_adapter)\n\t\t\t/* We ignore the return code; if it fails, too bad */\n\t\t\tdriver->attach_adapter(adap);\n\t}\n\t...\n}\n```\n\n```c\nint i2c_del_adapter(struct i2c_adapter *adap)\n{\n\t...\n\tlist_for_each(item,&drivers) {\n\t\tdriver = list_entry(item, struct i2c_driver, list);\n\t\tif (driver->detach_adapter)\n\t\t\tif ((res = driver->detach_adapter(adap))) {\n\t\t\t}\n\t}\n\t...\n\tlist_for_each_safe(item, _n, &adap->clients) {\n\t\tclient = list_entry(item, struct i2c_client, list);\n \n\t\tif ((res=client->driver->detach_client(client))) {\n \n\t\t}\n\t}\n\t...\n\tdevice_remove_file(&adap->dev, &dev_attr_name);\n\tdevice_unregister(&adap->dev);\n \n}\n```\n\ni2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的\n\n```c\nstatic struct platform_driver davinci_i2c_driver = {\n\t.probe\t\t= davinci_i2c_probe,\n\t.remove\t\t= davinci_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_davinci\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n};\n \n/* I2C may be needed to bring up other drivers */\nstatic int __init davinci_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&davinci_i2c_driver);\n}\nsubsys_initcall(davinci_i2c_init_driver);\n \nstatic void __exit davinci_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&davinci_i2c_driver);\n}\nmodule_exit(davinci_i2c_exit_driver);\n```\n\n并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器\n\n```c\nstatic struct i2c_algorithm i2c_davinci_algo = {\n\t.master_xfer\t= i2c_davinci_xfer,\n\t.functionality\t= i2c_davinci_func,\n};\n```\n\n然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中\n\n```c\nadap->algo = &i2c_davinci_algo;\n```\n\n\n### 梳理图\n有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:\n\n\n![](/imgs/I2C驱动框架学习/I2C适配器Dm368硬件.png)\n\nlinux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。\n\n在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。\n\n#### ov2715设备i2c驱动源码分析\nov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。\n该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。\n该字符设备的用到的结构体有两个，如下\n\n```c\ntypedef struct {\n\n  int devAddr;\n\n  struct i2c_client client;   //!< Data structure containing general access routines.\n  struct i2c_driver driver;   //!< Data structure containing information specific to each client.\n\n  char name[20];\n  int nameSize;\n  int users;\n\n} I2C_Obj;\n```\n\n```c\n#define I2C_DEV_MAX_ADDR  (0xFF)\n#define I2C_TRANSFER_BUF_SIZE_MAX   (256)\ntypedef struct {\n \n  struct cdev cdev;             /* Char device structure    */\n  int     major;\n  struct semaphore semLock;\n    \n  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];\n \n  uint8_t reg[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint16_t reg16[I2C_TRANSFER_BUF_SIZE_MAX];\n  uint8_t buffer[I2C_TRANSFER_BUF_SIZE_MAX*4];\n  \n} I2C_Dev;\n```\n\n一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值\n使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。\n下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。\n首先是该字符设备的初始化和退出函数\n\n```c\nint I2C_devInit(void)\n{\n  int     result, i;\n  dev_t   dev = 0;\n \n  result = alloc_chrdev_region(&dev, 0, 1, I2C_DRV_NAME);//分配字符设备空间\n  \n  for(i=0; i<I2C_DEV_MAX_ADDR; i++)\n  {\n    gI2C_dev.pObj[i]=NULL;\n  }\n \n  gI2C_dev.major = MAJOR(dev);//保存设备主编号\n  sema_init(&gI2C_dev.semLock, 1);//信号量初始化\n  cdev_init(&gI2C_dev.cdev, &gI2C_devFileOps);//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文\n  gI2C_dev.cdev.owner = THIS_MODULE;//常规赋值\n gI2C_dev.cdev.ops = &gI2C_devFileOps;//常规赋值 result = cdev_add(&gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;}void I2C_devExit(void){ dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间}\ngI2c_devFileOps全局变量，驱动初始化会用到该结构体变量\nstruct file_operations gI2C_devFileOps = {\n  .owner = THIS_MODULE,\n  .open = I2C_devOpen,\n  .release = I2C_devRelease,\n  .ioctl = I2C_devIoctl,\n};\n```\n\n该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。\n在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）\n\n```c\nint I2C_devIoctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\n{\n  I2C_Obj *pObj;\n  int status=0;\n  I2C_TransferPrm transferPrm;\n  \n  pObj = (I2C_Obj *)filp->private_data;\n \n  if(!I2C_IOCTL_CMD_IS_VALID(cmd))\n    return -1;\n  cmd = I2C_IOCTL_CMD_GET(cmd);//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd\n \n  down_interruptible(&gI2C_dev.semLock);      //信号量down\n  \n  switch(cmd)\n  {\n    case I2C_CMD_SET_DEV_ADDR://命令1，设置设备地址\n      filp->private_data = I2C_create(arg);\n \n    case I2C_CMD_WRITE:  //命令2，写寄存器值\n      \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n            \n      break;\n    case I2C_CMD_READ:  //命令3，读寄存器值\n    \n      status = copy_from_user(&transferPrm, (void *)arg, sizeof(transferPrm));\n      ...\n      \n      break;\n    default:\n      status = -1;\n      break;    \n  }\n \n  up(&gI2C_dev.semLock);      //信号量up\n \n  return status;\n}\n```\n\n以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码\n\n```c\nvoid *I2C_create(int devAddr) {\n \n    int ret;\n    struct i2c_driver *driver;\n    struct i2c_client *client = client;\n    I2C_Obj *pObj;\n \n    devAddr >>= 1;\n    \n    if(devAddr>I2C_DEV_MAX_ADDR)  //变量合法性判断\n      return NULL;\n   \n    if(gI2C_dev.pObj[devAddr]!=NULL) {\t//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用\n      // already allocated, increment user count, and return the allocated handle\n      gI2C_dev.pObj[devAddr]->users++;\n      return gI2C_dev.pObj[devAddr];\n    }\n    \n    pObj = (void*)kmalloc( sizeof(I2C_Obj), GFP_KERNEL); //为pObj分配空间\n    gI2C_dev.pObj[devAddr] = pObj;  //将分配的空间地址保存在全局变量里\n    memset(pObj, 0, sizeof(I2C_Obj));\n  \n    pObj->client.adapter = NULL;\n    pObj->users++;    //用户基数，初始化为0，当前设为1\n    pObj->devAddr = devAddr;  //保存设备地址\n    \n    gI2C_curAddr = pObj->devAddr;  //gI2C_curAddr为全局的整型变量，用于保存当前的设备地址\n    driver = &pObj->driver;  //将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动\n \n    pObj->nameSize=0;//i2c设备名称，注意，这里不是在/dev下面的设备节点名\n    pObj->name[pObj->nameSize++] = 'I';\n    pObj->name[pObj->nameSize++] = '2';\n    pObj->name[pObj->nameSize++] = 'C';\n    pObj->name[pObj->nameSize++] = '_';   \n    pObj->name[pObj->nameSize++] = 'A' + ((pObj->devAddr >> 0) & 0xF);\n    pObj->name[pObj->nameSize++] = 'B' + ((pObj->devAddr >> 4) & 0xF);\n    pObj->name[pObj->nameSize++] = 0;\n \n    driver->driver.name = pObj->name; //保存刚才设置的name\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;   //这个很重要，将驱动连接到i2c适配器上，在后面分析\n    driver->detach_client = I2C_detachClient;\t//这个很重，在后面分析\n \n    if((ret = i2c_add_driver(driver)))\t//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()\n    {\n        printk( KERN_ERR \"I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n\", pObj->devAddr);\n    }\n \n    if(ret<0) {\n \n      gI2C_dev.pObj[pObj->devAddr] = NULL;\n      kfree(pObj);    \n      return NULL;\n    }\n    return pObj;\n}\n```\n\n其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()\n\n```c\nint I2C_write(I2C_Obj *pObj, uint8_t *reg, uint8_t *buffer, uint8_t count, uint8_t dataSize)\n{\n  uint8_t i;\n  int err;\n  struct i2c_client *client;\n\tstruct i2c_msg msg[1];\n\tunsigned char data[8];\n \n  if(pObj==NULL)\n    return -ENODEV;\n \n  client = &pObj->client;//得到client信息\n  if(!client->adapter)\n    return -ENODEV;  \n  \n  if(dataSize<=0||dataSize>4)\n    return -1;\n    \n  for(i=0; i<count; i++) {\n  \n    msg->addr = client->addr;//设置要写的i2c设备地址\n    msg->flags= 0;//一直为0\n    msg->buf  = data;//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值\n\t\t\n    data[0] = reg[i];//寄存器地址赋值\n\t\t\n    if(dataSize==1) {//寄存器值长度为1\n       data[1]  = buffer[i];//寄存器值赋值\n       msg->len = 2;  \t//设置data长度为2\t\n    }\telse if(dataSize==2) {//寄存器值长度为2\n       data[1] = buffer[2*i+1];\n       data[2] = buffer[2*i];\n       msg->len = 3;\n    } \n    err = i2c_transfer(client->adapter, msg, 1);//调用i2c-core中的i2c_transfer发送i2c数据\n    if( err < 0 )\n      return err;\n    }\n  \n  return 0;\n}\n```\n\n重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的\n\n```c\n    driver->driver.name = pObj->name;\n    driver->id = I2C_DRIVERID_MISC;\n    driver->attach_adapter = I2C_attachAdapter;\n    driver->detach_client = I2C_detachClient;\n```\n在i2c_driver结构体中针对attach_adapter有这样的说明：\n\n```c\n\t/* Notifies the driver that a new bus has appeared. This routine\n\t * can be used by the driver to test if the bus meets its conditions\n\t * & seek for the presence of the chip(s) it supports. If found, it \n\t * registers the client(s) that are on the bus to the i2c admin. via\n\t * i2c_attach_client.\n\t */\n```\n\n意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示\n\n```c\nint I2C_attachAdapter(struct i2c_adapter *adapter)\n{\n    return I2C_detectClient(adapter, gI2C_curAddr);\n}\n \nint I2C_detectClient(struct i2c_adapter *adapter, int address)\n{\n    I2C_Obj *pObj;\n    struct i2c_client *client;\n    int err = 0;\n    \n    if(address > I2C_DEV_MAX_ADDR) {\n      printk( KERN_ERR \"I2C: ERROR: Invalid device address %x\\n\", address);        \n      return -1;\n    }\n      \n    pObj = gI2C_dev.pObj[address];\n    if(pObj==NULL) {\n      printk( KERN_ERR \"I2C: ERROR: Object not found for address %x\\n\", address);    \n      return -1;\n    }\n \n    client = &pObj->client;\n \n    if(client->adapter)\n      return -EBUSY;  /* our client is already attached */\n \n    memset(client, 0x00, sizeof(struct i2c_client));\n    client->addr = pObj->devAddr;\n    client->adapter = adapter;\n    client->driver = &pObj->driver;\n \n    if((err = i2c_attach_client(client)))\n    {\n        printk( KERN_ERR \"I2C: ERROR: Couldn't attach %s (address=%x)\\n\", pObj->name, pObj->devAddr);\n        client->adapter = NULL;\n        return err;\n    }\n    return 0;\n}\n```\n最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。\n当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：\n\n```c\n\t/* tells the driver that a client is about to be deleted & gives it \n\t * the chance to remove its private data. Also, if the client struct\n\t * has been dynamically allocated by the driver in the function above,\n\t * it must be freed here.\n\t */\n```\n\n下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接\n\n```c\nint I2C_detachClient(struct i2c_client *client)\n{\n    int err;\nif(!client->adapter)\n    return -ENODEV; /* our client isn't attached */\n \nif((err = i2c_detach_client(client))) {\n    printk( KERN_ERR \"Client deregistration failed (address=%x), client not detached.\\n\", client->addr);\n    return err;\n}\n \nclient->adapter = NULL;\n \nreturn 0;\n```\n}\n\n\n\n\n\n\n\n\n<small>misslyh20080512202305122023080719980106202309281520825879280398965</small>\n","slug":"I2C驱动框架学习","published":1,"updated":"2023-09-29T11:21:01.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cln4m6jug0002esw8fx4efdo2","content":"<h1 id=\"I2C通信：\"><a href=\"#I2C通信：\" class=\"headerlink\" title=\"I2C通信：\"></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>\n<h3 id=\"CAN总线仲裁：\"><a href=\"#CAN总线仲裁：\" class=\"headerlink\" title=\"CAN总线仲裁：\"></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif\"><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>\n<h3 id=\"数据传输协议：\"><a href=\"#数据传输协议：\" class=\"headerlink\" title=\"数据传输协议：\"></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>\n<h4 id=\"开始条件：\"><a href=\"#开始条件：\" class=\"headerlink\" title=\"开始条件：\"></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>\n<p><strong>地址位</strong>：</p>\n<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>\n<p><strong>读写位</strong>：</p>\n<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>\n<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>\n<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>\n<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>\n<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>\n<h3 id=\"架构层次分类\"><a href=\"#架构层次分类\" class=\"headerlink\" title=\"架构层次分类\"></a>架构层次分类</h3><p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png\"></p>\n<h5 id=\"第一层：\"><a href=\"#第一层：\" class=\"headerlink\" title=\"第一层：\"></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>\n<h5 id=\"第二层：\"><a href=\"#第二层：\" class=\"headerlink\" title=\"第二层：\"></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>\n<h6 id=\"第三层：\"><a href=\"#第三层：\" class=\"headerlink\" title=\"第三层：\"></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>\n<h5 id=\"第四层：\"><a href=\"#第四层：\" class=\"headerlink\" title=\"第四层：\"></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>\n<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>\n<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>\n<h4 id=\"具体分析\"><a href=\"#具体分析\" class=\"headerlink\" title=\"具体分析\"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>\n<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>\n<h5 id=\"i2c-driver\"><a href=\"#i2c-driver\" class=\"headerlink\" title=\"i2c_driver\"></a>i2c_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*attach_adapter)(<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*detach_adapter)(<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*detach_client)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*command)(<span class=\"keyword\">struct</span> i2c_client *client,<span class=\"type\">unsigned</span> <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *arg);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>};</p>\n<h5 id=\"i2c-client\"><a href=\"#i2c-client\" class=\"headerlink\" title=\"i2c_client\"></a>i2c_client</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags;\t\t<span class=\"comment\">/* div., see below\t\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> addr;\t\t<span class=\"comment\">/* chip address - <span class=\"doctag\">NOTE:</span> 7bit \t*/</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* addresses are stored in the\t*/</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* _LOWER_ 7 bits\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adapter</span>;</span>\t<span class=\"comment\">/* the adapter we sit on\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> *<span class=\"title\">driver</span>;</span>\t<span class=\"comment\">/* and our access routines\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> usage_count;\t\t<span class=\"comment\">/* How many accesses currently  */</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* to the client\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span>\t\t<span class=\"comment\">/* the device structure\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[I2C_NAME_SIZE];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">released</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"i2c-adapter\"><a href=\"#i2c-adapter\" class=\"headerlink\" title=\"i2c_adapter\"></a>i2c_adapter</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> *<span class=\"title\">algo</span>;</span><span class=\"comment\">/* the algorithm to access the bus\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *algo_data;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">/* --- administration stuff. */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*client_register)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*client_unregister)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">/* data fields that are valid for all devices\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">bus_lock</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">clist_lock</span>;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> retries;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span>\t\t<span class=\"comment\">/* the adapter device */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_device</span> <span class=\"title\">class_dev</span>;</span>\t<span class=\"comment\">/* the class device */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> nr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">clients</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[I2C_NAME_SIZE];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">dev_released</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">class_dev_released</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"i2c-algorithm\"><a href=\"#i2c-algorithm\" class=\"headerlink\" title=\"i2c_algorithm\"></a>i2c_algorithm</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*master_xfer)(<span class=\"keyword\">struct</span> i2c_adapter *adap,<span class=\"keyword\">struct</span> i2c_msg *msgs, </span><br><span class=\"line\">\t                   <span class=\"type\">int</span> num);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*slave_send)(<span class=\"keyword\">struct</span> i2c_adapter *,<span class=\"type\">char</span>*,<span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*slave_recv)(<span class=\"keyword\">struct</span> i2c_adapter *,<span class=\"type\">char</span>*,<span class=\"type\">int</span>);</span><br><span class=\"line\">\tu32 (*functionality) (<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"【i2c-adapter与i2c-algorithm】\"><a href=\"#【i2c-adapter与i2c-algorithm】\" class=\"headerlink\" title=\"【i2c_adapter与i2c_algorithm】\"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>\n<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>\n<pre><code> /*\n  * I2C Message - used for pure i2c transaction, also from /dev interface\n  */\n struct i2c_msg &#123;\n     __u16 addr;\t/* slave address\t\t\t*/\n  \t__u16 flags;\t\t\n  \t__u16 len;\t\t/* msg length\t\t\t\t*/\n  \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n &#125;;\n</code></pre>\n<h5 id=\"【i2c-driver和i2c-client】\"><a href=\"#【i2c-driver和i2c-client】\" class=\"headerlink\" title=\"【i2c_driver和i2c_client】\"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>\n<h5 id=\"【i2c-adapter和i2c-client】\"><a href=\"#【i2c-adapter和i2c-client】\" class=\"headerlink\" title=\"【i2c_adapter和i2c_client】\"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>\n<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class=\"line\"></span><br><span class=\"line\">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_transfer</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter * adap, <span class=\"keyword\">struct</span> i2c_msg *msgs, <span class=\"type\">int</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class=\"comment\">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class=\"line\">\t\tret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class=\"comment\">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ENOSYS;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_attach_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_register(&amp;client-&gt;dev);</span><br><span class=\"line\">\tdevice_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_detach_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class=\"line\">\tdevice_unregister(&amp;client-&gt;dev);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* -----</span></span><br><span class=\"line\"><span class=\"comment\"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class=\"line\"><span class=\"comment\"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class=\"line\"><span class=\"comment\"> * available for clients.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_add_adapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_register(&amp;adap-&gt;dev);</span><br><span class=\"line\">\tdevice_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">/* inform drivers of new adapters */</span></span><br><span class=\"line\">\tlist_for_each(item,&amp;drivers) &#123;</span><br><span class=\"line\">\t\tdriver = list_entry(item, <span class=\"keyword\">struct</span> i2c_driver, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (driver-&gt;attach_adapter)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* We ignore the return code; if it fails, too bad */</span></span><br><span class=\"line\">\t\t\tdriver-&gt;attach_adapter(adap);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_del_adapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tlist_for_each(item,&amp;drivers) &#123;</span><br><span class=\"line\">\t\tdriver = list_entry(item, <span class=\"keyword\">struct</span> i2c_driver, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (driver-&gt;detach_adapter)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tlist_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class=\"line\">\t\tclient = list_entry(item, <span class=\"keyword\">struct</span> i2c_client, <span class=\"built_in\">list</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class=\"line\">\tdevice_unregister(&amp;adap-&gt;dev);</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> <span class=\"title\">davinci_i2c_driver</span> =</span> &#123;</span><br><span class=\"line\">\t.probe\t\t= davinci_i2c_probe,</span><br><span class=\"line\">\t.remove\t\t= davinci_i2c_remove,</span><br><span class=\"line\">\t.driver\t\t= &#123;</span><br><span class=\"line\">\t\t.name\t= <span class=\"string\">&quot;i2c_davinci&quot;</span>,</span><br><span class=\"line\">\t\t.owner\t= THIS_MODULE,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* I2C may be needed to bring up other drivers */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">davinci_i2c_init_driver</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subsys_initcall(davinci_i2c_init_driver);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">davinci_i2c_exit_driver</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tplatform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>\n\n<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> <span class=\"title\">i2c_davinci_algo</span> =</span> &#123;</span><br><span class=\"line\">\t.master_xfer\t= i2c_davinci_xfer,</span><br><span class=\"line\">\t.functionality\t= i2c_davinci_func,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"梳理图\"><a href=\"#梳理图\" class=\"headerlink\" title=\"梳理图\"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>\n<p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png\"></p>\n<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>\n<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>\n<h4 id=\"ov2715设备i2c驱动源码分析\"><a href=\"#ov2715设备i2c驱动源码分析\" class=\"headerlink\" title=\"ov2715设备i2c驱动源码分析\"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> devAddr;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> <span class=\"title\">client</span>;</span>   <span class=\"comment\">//!&lt; Data structure containing general access routines.</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">driver</span>;</span>   <span class=\"comment\">//!&lt; Data structure containing information specific to each client.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">  <span class=\"type\">int</span> nameSize;</span><br><span class=\"line\">  <span class=\"type\">int</span> users;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; I2C_Obj;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> <span class=\"title\">cdev</span>;</span>             <span class=\"comment\">/* Char device structure    */</span></span><br><span class=\"line\">  <span class=\"type\">int</span>     major;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semaphore</span> <span class=\"title\">semLock</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class=\"number\">4</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125; I2C_Dev;</span><br></pre></td></tr></table></figure>\n\n<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_devInit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>     result, i;</span><br><span class=\"line\">  <span class=\"type\">dev_t</span>   dev = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  result = alloc_chrdev_region(&amp;dev, <span class=\"number\">0</span>, <span class=\"number\">1</span>, I2C_DRV_NAME);<span class=\"comment\">//分配字符设备空间</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    gI2C_dev.pObj[i]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  gI2C_dev.major = MAJOR(dev);<span class=\"comment\">//保存设备主编号</span></span><br><span class=\"line\">  sema_init(&amp;gI2C_dev.semLock, <span class=\"number\">1</span>);<span class=\"comment\">//信号量初始化</span></span><br><span class=\"line\">  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class=\"comment\">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span></span><br><span class=\"line\">  gI2C_dev.cdev.owner = THIS_MODULE;<span class=\"comment\">//常规赋值</span></span><br><span class=\"line\"> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class=\"comment\">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span></span><br><span class=\"line\">gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">gI2C_devFileOps</span> =</span> &#123;</span><br><span class=\"line\">  .owner = THIS_MODULE,</span><br><span class=\"line\">  .open = I2C_devOpen,</span><br><span class=\"line\">  .release = I2C_devRelease,</span><br><span class=\"line\">  .ioctl = I2C_devIoctl,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_devIoctl</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> cmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  I2C_Obj *pObj;</span><br><span class=\"line\">  <span class=\"type\">int</span> status=<span class=\"number\">0</span>;</span><br><span class=\"line\">  I2C_TransferPrm transferPrm;</span><br><span class=\"line\">  </span><br><span class=\"line\">  pObj = (I2C_Obj *)filp-&gt;private_data;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  cmd = I2C_IOCTL_CMD_GET(cmd);<span class=\"comment\">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  down_interruptible(&amp;gI2C_dev.semLock);      <span class=\"comment\">//信号量down</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(cmd)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_SET_DEV_ADDR:<span class=\"comment\">//命令1，设置设备地址</span></span><br><span class=\"line\">      filp-&gt;private_data = I2C_create(arg);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_WRITE:  <span class=\"comment\">//命令2，写寄存器值</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      status = copy_from_user(&amp;transferPrm, (<span class=\"type\">void</span> *)arg, <span class=\"keyword\">sizeof</span>(transferPrm));</span><br><span class=\"line\">      ...</span><br><span class=\"line\">            </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_READ:  <span class=\"comment\">//命令3，读寄存器值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      status = copy_from_user(&amp;transferPrm, (<span class=\"type\">void</span> *)arg, <span class=\"keyword\">sizeof</span>(transferPrm));</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      status = <span class=\"number\">-1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  up(&amp;gI2C_dev.semLock);      <span class=\"comment\">//信号量up</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">I2C_create</span><span class=\"params\">(<span class=\"type\">int</span> devAddr)</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> =</span> client;</span><br><span class=\"line\">    I2C_Obj *pObj;</span><br><span class=\"line\"> </span><br><span class=\"line\">    devAddr &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class=\"comment\">//变量合法性判断</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(gI2C_dev.pObj[devAddr]!=<span class=\"literal\">NULL</span>) &#123;\t<span class=\"comment\">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span></span><br><span class=\"line\">      <span class=\"comment\">// already allocated, increment user count, and return the allocated handle</span></span><br><span class=\"line\">      gI2C_dev.pObj[devAddr]-&gt;users++;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> gI2C_dev.pObj[devAddr];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    pObj = (<span class=\"type\">void</span>*)kmalloc( <span class=\"keyword\">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class=\"comment\">//为pObj分配空间</span></span><br><span class=\"line\">    gI2C_dev.pObj[devAddr] = pObj;  <span class=\"comment\">//将分配的空间地址保存在全局变量里</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pObj, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(I2C_Obj));</span><br><span class=\"line\">  </span><br><span class=\"line\">    pObj-&gt;client.adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pObj-&gt;users++;    <span class=\"comment\">//用户基数，初始化为0，当前设为1</span></span><br><span class=\"line\">    pObj-&gt;devAddr = devAddr;  <span class=\"comment\">//保存设备地址</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    gI2C_curAddr = pObj-&gt;devAddr;  <span class=\"comment\">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span></span><br><span class=\"line\">    driver = &amp;pObj-&gt;driver;  <span class=\"comment\">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    pObj-&gt;nameSize=<span class=\"number\">0</span>;<span class=\"comment\">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span></span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;I&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;_&#x27;</span>;   </span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"number\">0</span>) &amp; <span class=\"number\">0xF</span>);</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0xF</span>);</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    driver-&gt;driver.name = pObj-&gt;name; <span class=\"comment\">//保存刚才设置的name</span></span><br><span class=\"line\">    driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class=\"line\">    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class=\"comment\">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span></span><br><span class=\"line\">    driver-&gt;detach_client = I2C_detachClient;\t<span class=\"comment\">//这个很重，在后面分析</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ret = i2c_add_driver(driver)))\t<span class=\"comment\">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n&quot;</span>, pObj-&gt;devAddr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">      kfree(pObj);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_write</span><span class=\"params\">(I2C_Obj *pObj, <span class=\"type\">uint8_t</span> *reg, <span class=\"type\">uint8_t</span> *buffer, <span class=\"type\">uint8_t</span> count, <span class=\"type\">uint8_t</span> dataSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> i;</span><br><span class=\"line\">  <span class=\"type\">int</span> err;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>[1];</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span> data[<span class=\"number\">8</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pObj==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV;</span><br><span class=\"line\"> </span><br><span class=\"line\">  client = &amp;pObj-&gt;client;<span class=\"comment\">//得到client信息</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!client-&gt;adapter)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(dataSize&lt;=<span class=\"number\">0</span>||dataSize&gt;<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    msg-&gt;addr = client-&gt;addr;<span class=\"comment\">//设置要写的i2c设备地址</span></span><br><span class=\"line\">    msg-&gt;flags= <span class=\"number\">0</span>;<span class=\"comment\">//一直为0</span></span><br><span class=\"line\">    msg-&gt;buf  = data;<span class=\"comment\">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = reg[i];<span class=\"comment\">//寄存器地址赋值</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dataSize==<span class=\"number\">1</span>) &#123;<span class=\"comment\">//寄存器值长度为1</span></span><br><span class=\"line\">       data[<span class=\"number\">1</span>]  = buffer[i];<span class=\"comment\">//寄存器值赋值</span></span><br><span class=\"line\">       msg-&gt;len = <span class=\"number\">2</span>;  \t<span class=\"comment\">//设置data长度为2\t</span></span><br><span class=\"line\">    &#125;\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dataSize==<span class=\"number\">2</span>) &#123;<span class=\"comment\">//寄存器值长度为2</span></span><br><span class=\"line\">       data[<span class=\"number\">1</span>] = buffer[<span class=\"number\">2</span>*i+<span class=\"number\">1</span>];</span><br><span class=\"line\">       data[<span class=\"number\">2</span>] = buffer[<span class=\"number\">2</span>*i];</span><br><span class=\"line\">       msg-&gt;len = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    err = i2c_transfer(client-&gt;adapter, msg, <span class=\"number\">1</span>);<span class=\"comment\">//调用i2c-core中的i2c_transfer发送i2c数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( err &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver-&gt;driver.name = pObj-&gt;name;</span><br><span class=\"line\">driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class=\"line\">driver-&gt;attach_adapter = I2C_attachAdapter;</span><br><span class=\"line\">driver-&gt;detach_client = I2C_detachClient;</span><br></pre></td></tr></table></figure>\n<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Notifies the driver that a new bus has appeared. This routine</span></span><br><span class=\"line\"><span class=\"comment\"> * can be used by the driver to test if the bus meets its conditions</span></span><br><span class=\"line\"><span class=\"comment\"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span></span><br><span class=\"line\"><span class=\"comment\"> * registers the client(s) that are on the bus to the i2c admin. via</span></span><br><span class=\"line\"><span class=\"comment\"> * i2c_attach_client.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_attachAdapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adapter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> I2C_detectClient(adapter, gI2C_curAddr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_detectClient</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adapter, <span class=\"type\">int</span> address)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    I2C_Obj *pObj;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;</span><br><span class=\"line\">      printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Invalid device address %x\\n&quot;</span>, address);        </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    pObj = gI2C_dev.pObj[address];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pObj==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Object not found for address %x\\n&quot;</span>, address);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    client = &amp;pObj-&gt;client;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(client-&gt;adapter)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -EBUSY;  <span class=\"comment\">/* our client is already attached */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(client, <span class=\"number\">0x00</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> i2c_client));</span><br><span class=\"line\">    client-&gt;addr = pObj-&gt;devAddr;</span><br><span class=\"line\">    client-&gt;adapter = adapter;</span><br><span class=\"line\">    client-&gt;driver = &amp;pObj-&gt;driver;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((err = i2c_attach_client(client)))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);</span><br><span class=\"line\">        client-&gt;adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* tells the driver that a client is about to be deleted &amp; gives it </span></span><br><span class=\"line\"><span class=\"comment\"> * the chance to remove its private data. Also, if the client struct</span></span><br><span class=\"line\"><span class=\"comment\"> * has been dynamically allocated by the driver in the function above,</span></span><br><span class=\"line\"><span class=\"comment\"> * it must be freed here.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_detachClient</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> err;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!client-&gt;adapter)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV; <span class=\"comment\">/* our client isn&#x27;t attached */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>((err = i2c_detach_client(client))) &#123;</span><br><span class=\"line\">    printk( KERN_ERR <span class=\"string\">&quot;Client deregistration failed (address=%x), client not detached.\\n&quot;</span>, client-&gt;addr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">client-&gt;adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>}</p>\n<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"I2C通信：\"><a href=\"#I2C通信：\" class=\"headerlink\" title=\"I2C通信：\"></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>\n<h3 id=\"CAN总线仲裁：\"><a href=\"#CAN总线仲裁：\" class=\"headerlink\" title=\"CAN总线仲裁：\"></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif\"><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>\n<h3 id=\"数据传输协议：\"><a href=\"#数据传输协议：\" class=\"headerlink\" title=\"数据传输协议：\"></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>\n<h4 id=\"开始条件：\"><a href=\"#开始条件：\" class=\"headerlink\" title=\"开始条件：\"></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>\n<p><strong>地址位</strong>：</p>\n<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>\n<p><strong>读写位</strong>：</p>\n<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>\n<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>\n<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>\n<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>\n<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>\n<h3 id=\"架构层次分类\"><a href=\"#架构层次分类\" class=\"headerlink\" title=\"架构层次分类\"></a>架构层次分类</h3><p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png\"></p>\n<h5 id=\"第一层：\"><a href=\"#第一层：\" class=\"headerlink\" title=\"第一层：\"></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>\n<h5 id=\"第二层：\"><a href=\"#第二层：\" class=\"headerlink\" title=\"第二层：\"></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>\n<h6 id=\"第三层：\"><a href=\"#第三层：\" class=\"headerlink\" title=\"第三层：\"></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>\n<h5 id=\"第四层：\"><a href=\"#第四层：\" class=\"headerlink\" title=\"第四层：\"></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>\n<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>\n<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>\n<h4 id=\"具体分析\"><a href=\"#具体分析\" class=\"headerlink\" title=\"具体分析\"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>\n<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>\n<h5 id=\"i2c-driver\"><a href=\"#i2c-driver\" class=\"headerlink\" title=\"i2c_driver\"></a>i2c_driver</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*attach_adapter)(<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*detach_adapter)(<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*detach_client)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> (*command)(<span class=\"keyword\">struct</span> i2c_client *client,<span class=\"type\">unsigned</span> <span class=\"type\">int</span> cmd, <span class=\"type\">void</span> *arg);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_driver</span> <span class=\"title\">driver</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>};</p>\n<h5 id=\"i2c-client\"><a href=\"#i2c-client\" class=\"headerlink\" title=\"i2c_client\"></a>i2c_client</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags;\t\t<span class=\"comment\">/* div., see below\t\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">short</span> addr;\t\t<span class=\"comment\">/* chip address - <span class=\"doctag\">NOTE:</span> 7bit \t*/</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* addresses are stored in the\t*/</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* _LOWER_ 7 bits\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> *<span class=\"title\">adapter</span>;</span>\t<span class=\"comment\">/* the adapter we sit on\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> *<span class=\"title\">driver</span>;</span>\t<span class=\"comment\">/* and our access routines\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> usage_count;\t\t<span class=\"comment\">/* How many accesses currently  */</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">/* to the client\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span>\t\t<span class=\"comment\">/* the device structure\t\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[I2C_NAME_SIZE];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">released</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"i2c-adapter\"><a href=\"#i2c-adapter\" class=\"headerlink\" title=\"i2c_adapter\"></a>i2c_adapter</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_adapter</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> *<span class=\"title\">algo</span>;</span><span class=\"comment\">/* the algorithm to access the bus\t*/</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> *algo_data;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">/* --- administration stuff. */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*client_register)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*client_unregister)(<span class=\"keyword\">struct</span> i2c_client *);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">/* data fields that are valid for all devices\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">bus_lock</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mutex</span> <span class=\"title\">clist_lock</span>;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> timeout;</span><br><span class=\"line\">\t<span class=\"type\">int</span> retries;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> <span class=\"title\">dev</span>;</span>\t\t<span class=\"comment\">/* the adapter device */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_device</span> <span class=\"title\">class_dev</span>;</span>\t<span class=\"comment\">/* the class device */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"type\">int</span> nr;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">clients</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[I2C_NAME_SIZE];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">dev_released</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">completion</span> <span class=\"title\">class_dev_released</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"i2c-algorithm\"><a href=\"#i2c-algorithm\" class=\"headerlink\" title=\"i2c_algorithm\"></a>i2c_algorithm</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*master_xfer)(<span class=\"keyword\">struct</span> i2c_adapter *adap,<span class=\"keyword\">struct</span> i2c_msg *msgs, </span><br><span class=\"line\">\t                   <span class=\"type\">int</span> num);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*slave_send)(<span class=\"keyword\">struct</span> i2c_adapter *,<span class=\"type\">char</span>*,<span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*slave_recv)(<span class=\"keyword\">struct</span> i2c_adapter *,<span class=\"type\">char</span>*,<span class=\"type\">int</span>);</span><br><span class=\"line\">\tu32 (*functionality) (<span class=\"keyword\">struct</span> i2c_adapter *);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"【i2c-adapter与i2c-algorithm】\"><a href=\"#【i2c-adapter与i2c-algorithm】\" class=\"headerlink\" title=\"【i2c_adapter与i2c_algorithm】\"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>\n<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>\n<pre><code> /*\n  * I2C Message - used for pure i2c transaction, also from /dev interface\n  */\n struct i2c_msg &#123;\n     __u16 addr;\t/* slave address\t\t\t*/\n  \t__u16 flags;\t\t\n  \t__u16 len;\t\t/* msg length\t\t\t\t*/\n  \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n &#125;;\n</code></pre>\n<h5 id=\"【i2c-driver和i2c-client】\"><a href=\"#【i2c-driver和i2c-client】\" class=\"headerlink\" title=\"【i2c_driver和i2c_client】\"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>\n<h5 id=\"【i2c-adapter和i2c-client】\"><a href=\"#【i2c-adapter和i2c-client】\" class=\"headerlink\" title=\"【i2c_adapter和i2c_client】\"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>\n<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class=\"line\">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class=\"line\"></span><br><span class=\"line\">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>\n\n<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_transfer</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter * adap, <span class=\"keyword\">struct</span> i2c_msg *msgs, <span class=\"type\">int</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class=\"comment\">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class=\"line\">\t\tret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class=\"comment\">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -ENOSYS;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_attach_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_register(&amp;client-&gt;dev);</span><br><span class=\"line\">\tdevice_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_detach_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class=\"line\">\tdevice_unregister(&amp;client-&gt;dev);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* -----</span></span><br><span class=\"line\"><span class=\"comment\"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class=\"line\"><span class=\"comment\"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class=\"line\"><span class=\"comment\"> * available for clients.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_add_adapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_register(&amp;adap-&gt;dev);</span><br><span class=\"line\">\tdevice_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">/* inform drivers of new adapters */</span></span><br><span class=\"line\">\tlist_for_each(item,&amp;drivers) &#123;</span><br><span class=\"line\">\t\tdriver = list_entry(item, <span class=\"keyword\">struct</span> i2c_driver, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (driver-&gt;attach_adapter)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* We ignore the return code; if it fails, too bad */</span></span><br><span class=\"line\">\t\t\tdriver-&gt;attach_adapter(adap);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_del_adapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tlist_for_each(item,&amp;drivers) &#123;</span><br><span class=\"line\">\t\tdriver = list_entry(item, <span class=\"keyword\">struct</span> i2c_driver, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (driver-&gt;detach_adapter)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tlist_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class=\"line\">\t\tclient = list_entry(item, <span class=\"keyword\">struct</span> i2c_client, <span class=\"built_in\">list</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tdevice_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class=\"line\">\tdevice_unregister(&amp;adap-&gt;dev);</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">platform_driver</span> <span class=\"title\">davinci_i2c_driver</span> =</span> &#123;</span><br><span class=\"line\">\t.probe\t\t= davinci_i2c_probe,</span><br><span class=\"line\">\t.remove\t\t= davinci_i2c_remove,</span><br><span class=\"line\">\t.driver\t\t= &#123;</span><br><span class=\"line\">\t\t.name\t= <span class=\"string\">&quot;i2c_davinci&quot;</span>,</span><br><span class=\"line\">\t\t.owner\t= THIS_MODULE,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* I2C may be needed to bring up other drivers */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">davinci_i2c_init_driver</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subsys_initcall(davinci_i2c_init_driver);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">davinci_i2c_exit_driver</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tplatform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>\n\n<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_algorithm</span> <span class=\"title\">i2c_davinci_algo</span> =</span> &#123;</span><br><span class=\"line\">\t.master_xfer\t= i2c_davinci_xfer,</span><br><span class=\"line\">\t.functionality\t= i2c_davinci_func,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"梳理图\"><a href=\"#梳理图\" class=\"headerlink\" title=\"梳理图\"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>\n<p><img src=\"/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png\"></p>\n<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>\n<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>\n<h4 id=\"ov2715设备i2c驱动源码分析\"><a href=\"#ov2715设备i2c驱动源码分析\" class=\"headerlink\" title=\"ov2715设备i2c驱动源码分析\"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> devAddr;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> <span class=\"title\">client</span>;</span>   <span class=\"comment\">//!&lt; Data structure containing general access routines.</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> <span class=\"title\">driver</span>;</span>   <span class=\"comment\">//!&lt; Data structure containing information specific to each client.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">  <span class=\"type\">int</span> nameSize;</span><br><span class=\"line\">  <span class=\"type\">int</span> users;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; I2C_Obj;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> <span class=\"title\">cdev</span>;</span>             <span class=\"comment\">/* Char device structure    */</span></span><br><span class=\"line\">  <span class=\"type\">int</span>     major;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semaphore</span> <span class=\"title\">semLock</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class=\"number\">4</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125; I2C_Dev;</span><br></pre></td></tr></table></figure>\n\n<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_devInit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>     result, i;</span><br><span class=\"line\">  <span class=\"type\">dev_t</span>   dev = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  result = alloc_chrdev_region(&amp;dev, <span class=\"number\">0</span>, <span class=\"number\">1</span>, I2C_DRV_NAME);<span class=\"comment\">//分配字符设备空间</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    gI2C_dev.pObj[i]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  gI2C_dev.major = MAJOR(dev);<span class=\"comment\">//保存设备主编号</span></span><br><span class=\"line\">  sema_init(&amp;gI2C_dev.semLock, <span class=\"number\">1</span>);<span class=\"comment\">//信号量初始化</span></span><br><span class=\"line\">  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class=\"comment\">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span></span><br><span class=\"line\">  gI2C_dev.cdev.owner = THIS_MODULE;<span class=\"comment\">//常规赋值</span></span><br><span class=\"line\"> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class=\"comment\">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span></span><br><span class=\"line\">gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">gI2C_devFileOps</span> =</span> &#123;</span><br><span class=\"line\">  .owner = THIS_MODULE,</span><br><span class=\"line\">  .open = I2C_devOpen,</span><br><span class=\"line\">  .release = I2C_devRelease,</span><br><span class=\"line\">  .ioctl = I2C_devIoctl,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_devIoctl</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *filp, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> cmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  I2C_Obj *pObj;</span><br><span class=\"line\">  <span class=\"type\">int</span> status=<span class=\"number\">0</span>;</span><br><span class=\"line\">  I2C_TransferPrm transferPrm;</span><br><span class=\"line\">  </span><br><span class=\"line\">  pObj = (I2C_Obj *)filp-&gt;private_data;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  cmd = I2C_IOCTL_CMD_GET(cmd);<span class=\"comment\">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  down_interruptible(&amp;gI2C_dev.semLock);      <span class=\"comment\">//信号量down</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(cmd)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_SET_DEV_ADDR:<span class=\"comment\">//命令1，设置设备地址</span></span><br><span class=\"line\">      filp-&gt;private_data = I2C_create(arg);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_WRITE:  <span class=\"comment\">//命令2，写寄存器值</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      status = copy_from_user(&amp;transferPrm, (<span class=\"type\">void</span> *)arg, <span class=\"keyword\">sizeof</span>(transferPrm));</span><br><span class=\"line\">      ...</span><br><span class=\"line\">            </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> I2C_CMD_READ:  <span class=\"comment\">//命令3，读寄存器值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">      status = copy_from_user(&amp;transferPrm, (<span class=\"type\">void</span> *)arg, <span class=\"keyword\">sizeof</span>(transferPrm));</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      status = <span class=\"number\">-1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  up(&amp;gI2C_dev.semLock);      <span class=\"comment\">//信号量up</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">I2C_create</span><span class=\"params\">(<span class=\"type\">int</span> devAddr)</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_driver</span> *<span class=\"title\">driver</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span> =</span> client;</span><br><span class=\"line\">    I2C_Obj *pObj;</span><br><span class=\"line\"> </span><br><span class=\"line\">    devAddr &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class=\"comment\">//变量合法性判断</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(gI2C_dev.pObj[devAddr]!=<span class=\"literal\">NULL</span>) &#123;\t<span class=\"comment\">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span></span><br><span class=\"line\">      <span class=\"comment\">// already allocated, increment user count, and return the allocated handle</span></span><br><span class=\"line\">      gI2C_dev.pObj[devAddr]-&gt;users++;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> gI2C_dev.pObj[devAddr];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    pObj = (<span class=\"type\">void</span>*)kmalloc( <span class=\"keyword\">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class=\"comment\">//为pObj分配空间</span></span><br><span class=\"line\">    gI2C_dev.pObj[devAddr] = pObj;  <span class=\"comment\">//将分配的空间地址保存在全局变量里</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pObj, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(I2C_Obj));</span><br><span class=\"line\">  </span><br><span class=\"line\">    pObj-&gt;client.adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pObj-&gt;users++;    <span class=\"comment\">//用户基数，初始化为0，当前设为1</span></span><br><span class=\"line\">    pObj-&gt;devAddr = devAddr;  <span class=\"comment\">//保存设备地址</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    gI2C_curAddr = pObj-&gt;devAddr;  <span class=\"comment\">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span></span><br><span class=\"line\">    driver = &amp;pObj-&gt;driver;  <span class=\"comment\">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    pObj-&gt;nameSize=<span class=\"number\">0</span>;<span class=\"comment\">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span></span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;I&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;C&#x27;</span>;</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;_&#x27;</span>;   </span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"number\">0</span>) &amp; <span class=\"number\">0xF</span>);</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"string\">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class=\"number\">4</span>) &amp; <span class=\"number\">0xF</span>);</span><br><span class=\"line\">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    driver-&gt;driver.name = pObj-&gt;name; <span class=\"comment\">//保存刚才设置的name</span></span><br><span class=\"line\">    driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class=\"line\">    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class=\"comment\">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span></span><br><span class=\"line\">    driver-&gt;detach_client = I2C_detachClient;\t<span class=\"comment\">//这个很重，在后面分析</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ret = i2c_add_driver(driver)))\t<span class=\"comment\">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\\n&quot;</span>, pObj-&gt;devAddr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">      kfree(pObj);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_write</span><span class=\"params\">(I2C_Obj *pObj, <span class=\"type\">uint8_t</span> *reg, <span class=\"type\">uint8_t</span> *buffer, <span class=\"type\">uint8_t</span> count, <span class=\"type\">uint8_t</span> dataSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> i;</span><br><span class=\"line\">  <span class=\"type\">int</span> err;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_msg</span> <span class=\"title\">msg</span>[1];</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span> data[<span class=\"number\">8</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pObj==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV;</span><br><span class=\"line\"> </span><br><span class=\"line\">  client = &amp;pObj-&gt;client;<span class=\"comment\">//得到client信息</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!client-&gt;adapter)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(dataSize&lt;=<span class=\"number\">0</span>||dataSize&gt;<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;count; i++) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    msg-&gt;addr = client-&gt;addr;<span class=\"comment\">//设置要写的i2c设备地址</span></span><br><span class=\"line\">    msg-&gt;flags= <span class=\"number\">0</span>;<span class=\"comment\">//一直为0</span></span><br><span class=\"line\">    msg-&gt;buf  = data;<span class=\"comment\">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    data[<span class=\"number\">0</span>] = reg[i];<span class=\"comment\">//寄存器地址赋值</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dataSize==<span class=\"number\">1</span>) &#123;<span class=\"comment\">//寄存器值长度为1</span></span><br><span class=\"line\">       data[<span class=\"number\">1</span>]  = buffer[i];<span class=\"comment\">//寄存器值赋值</span></span><br><span class=\"line\">       msg-&gt;len = <span class=\"number\">2</span>;  \t<span class=\"comment\">//设置data长度为2\t</span></span><br><span class=\"line\">    &#125;\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dataSize==<span class=\"number\">2</span>) &#123;<span class=\"comment\">//寄存器值长度为2</span></span><br><span class=\"line\">       data[<span class=\"number\">1</span>] = buffer[<span class=\"number\">2</span>*i+<span class=\"number\">1</span>];</span><br><span class=\"line\">       data[<span class=\"number\">2</span>] = buffer[<span class=\"number\">2</span>*i];</span><br><span class=\"line\">       msg-&gt;len = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    err = i2c_transfer(client-&gt;adapter, msg, <span class=\"number\">1</span>);<span class=\"comment\">//调用i2c-core中的i2c_transfer发送i2c数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( err &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">driver-&gt;driver.name = pObj-&gt;name;</span><br><span class=\"line\">driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class=\"line\">driver-&gt;attach_adapter = I2C_attachAdapter;</span><br><span class=\"line\">driver-&gt;detach_client = I2C_detachClient;</span><br></pre></td></tr></table></figure>\n<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Notifies the driver that a new bus has appeared. This routine</span></span><br><span class=\"line\"><span class=\"comment\"> * can be used by the driver to test if the bus meets its conditions</span></span><br><span class=\"line\"><span class=\"comment\"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span></span><br><span class=\"line\"><span class=\"comment\"> * registers the client(s) that are on the bus to the i2c admin. via</span></span><br><span class=\"line\"><span class=\"comment\"> * i2c_attach_client.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_attachAdapter</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adapter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> I2C_detectClient(adapter, gI2C_curAddr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_detectClient</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_adapter *adapter, <span class=\"type\">int</span> address)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    I2C_Obj *pObj;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">i2c_client</span> *<span class=\"title\">client</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;</span><br><span class=\"line\">      printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Invalid device address %x\\n&quot;</span>, address);        </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    pObj = gI2C_dev.pObj[address];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pObj==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Object not found for address %x\\n&quot;</span>, address);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    client = &amp;pObj-&gt;client;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(client-&gt;adapter)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -EBUSY;  <span class=\"comment\">/* our client is already attached */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(client, <span class=\"number\">0x00</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> i2c_client));</span><br><span class=\"line\">    client-&gt;addr = pObj-&gt;devAddr;</span><br><span class=\"line\">    client-&gt;adapter = adapter;</span><br><span class=\"line\">    client-&gt;driver = &amp;pObj-&gt;driver;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>((err = i2c_attach_client(client)))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printk( KERN_ERR <span class=\"string\">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);</span><br><span class=\"line\">        client-&gt;adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* tells the driver that a client is about to be deleted &amp; gives it </span></span><br><span class=\"line\"><span class=\"comment\"> * the chance to remove its private data. Also, if the client struct</span></span><br><span class=\"line\"><span class=\"comment\"> * has been dynamically allocated by the driver in the function above,</span></span><br><span class=\"line\"><span class=\"comment\"> * it must be freed here.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">I2C_detachClient</span><span class=\"params\">(<span class=\"keyword\">struct</span> i2c_client *client)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> err;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!client-&gt;adapter)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -ENODEV; <span class=\"comment\">/* our client isn&#x27;t attached */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>((err = i2c_detach_client(client))) &#123;</span><br><span class=\"line\">    printk( KERN_ERR <span class=\"string\">&quot;Client deregistration failed (address=%x), client not detached.\\n&quot;</span>, client-&gt;addr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">client-&gt;adapter = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>}</p>\n<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}