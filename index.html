<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux Kernel tyro</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Linux Kernel tyro"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Linux Kernel tyro"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。"><meta property="og:type" content="blog"><meta property="og:title" content="Linux Kernel tyro"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Linux Kernel tyro"><meta property="og:description" content="一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="李嘉图"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Linux Kernel tyro","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"李嘉图"},"publisher":{"@type":"Organization","name":"Linux Kernel tyro","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"一步一步往上爬，背着我的蜗牛壳，爬到葡萄架。"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Linux Kernel tyro" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-30T08:43:59.000Z" title="2023/9/30 16:43:59">2023-09-30</time>发表</span><span class="level-item"><time dateTime="2023-09-30T08:59:08.254Z" title="2023/9/30 16:59:08">2023-09-30</time>更新</span><span class="level-item">2 分钟读完 (大约227个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/30/MissingLi/">MissingLi</a></p><div class="content"><p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BD%A9%E8%99%B9.jpg"></p>
<p>今天学校里出现了两个彩虹，含娃。</p>
<p>我根本舍不得不找你，我根本舍不得不理你。</p>
<p>我根本不敢找你，我好想你！</p>
<p>我根本不敢找你说那么多次我爱你！你能猜到我会把话都写到这吧？</p>
<p>看到你发消息，我来回的看，不敢点进去，我怕忍不住跟你说一大堆。</p>
<p>好好玩吧！我可以再等等的！</p>
<p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%852.png"></p>
<p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%851.png" alt="..\imgs\心情1"></p>
<p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%853.jpg"></p>
<p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%854.png"></p>
<p><img src="/imgs/%E5%BF%83%E6%83%85%E8%AE%B0%E5%BD%95/%E5%BF%83%E6%83%855.jpg"></p>
<p>我有好多话要说啊!我好想你啊!</p>
<p>我知道我要等下去,</p>
<p>上一次,我等了三十年呢</p>
<p>很多次的感受跟现在一样.</p>
<p>我们以后一定会是一家人.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-29T11:24:05.000Z" title="2023/9/29 19:24:05">2023-09-29</time>发表</span><span class="level-item"><time dateTime="2023-09-30T05:04:11.984Z" title="2023/9/30 13:04:11">2023-09-30</time>更新</span><span class="level-item">8 分钟读完 (大约1212个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/29/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F%E8%A7%82%E8%B5%8F%E6%8A%A5%E5%91%8A-%E9%87%8D%E8%A6%81/">头脑特工队观赏报告(重要)</a></p><div class="content"><p>被遗忘的想象会被送去记忆垃圾场，清理工拿走bing bond的音乐火箭，认为rilay不在需要它，bingbong惊慌的追上去也没能阻止。bingbong看着跌落深渊的火箭，一下跌坐在地上。我不知道为什么，看一个电影，我总是不能抓住主线，我看到这么一个小插曲，都会想到自己做的梦，我也惊慌的拉着很大的货轮，拉了很久很久，手上全是泡，还是没有把你留下。可能我当时的心情跟这个粉色小猪很像吧。</p>
<p><img src="/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay2.png"></p>
<p>我打了好多好多字啊，</p>
<p>可我都删了。</p>
<p>我想说很多话，有时候都说不出来。</p>
<p>就像我一直很想你，但我不敢老去找你聊天，我怕你讨厌我。</p>
<p>内心的复杂，是多么纤细而又值得赞颂的。</p>
<p>”替我把她送上月球好吗？“bingbong自己跳下火车，在记忆垃圾堆里，自己快要消失的时候对joy说的。我不知道是不是这样啊，喜欢一个人走那么久，真的不会累。我跑的很快，我怕咖啡会凉，我狠狠的跑，一点也不累，你不知道我那会儿我有多幸福，被电车撞上的时候我狠狠的护住咖啡，如果咖啡被打翻，我该有多难过啊。有时候，我很想很想很想自己也可以做的很好，像bingbong这样，为你狠狠的付出。我总是犯病，总是让你也很难受。我好笨啊。</p>
<p><img src="/imgs/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F/rilay1.png"></p>
<p>Rilay拒绝了内心的感受，开始变得冷漠，她没有愤怒，没有害怕也不在乎任何事，这样真的很酷啊，像以前的我一样？没有情绪，不会害怕任何事，因为根本不在乎。高中坐在垃圾桶旁边也不在乎，读研被大家网暴也不在乎，身体快不行了也不在乎，什么都不怕，什么都不在乎。没有感情奥，跟别人对我的称呼一样奥。没想过娶妻生子，没想过和哪个人共度一生，没想过生命怎么结束，没想过以后会怎样，因为我什么都不在乎，没有家人也不需要家人，没有情绪也不需要情绪。</p>
<p>我以为我会一直这样，直到我兜兜转转。</p>
<p>遇到你的时候，</p>
<p>我发现我好想跟你玩啊？</p>
<p>我不想听二手的话，我只想听你说的，我不想让夏於丹传话。我好想跟你说说话啊，我好想粘着你啊？</p>
<p>你不跟我说话，我发现自己会紧张，看到你不舒服，我会很局促。</p>
<p>哦，我发现我也有了很多情绪，我第一次很紧张很紧张，是我那天要去跟你到星巴克喝咖啡，我整晚不想睡觉，一直等时针转到早上七点，</p>
<p>原来紧张是这样，我以前真的很厉害，我不关心别人，不关心自己，就不会紧张。</p>
<p>那天，我用梳子给你梳头，吹头发，我感觉自己我比京爷都要幸福，我发现自己也想要一个家，想自己后半生可以每天像这样照顾你，照顾女儿，每天给你们做饭，吹头，按摩，梳头，带你们去玩。</p>
<p>谢谢你，lyh，带给我这么多完整的情绪。</p>
<p>搜到这个动画，看着奇怪的画风，让我很难点进去看，还好是含娃让我看的，不然我可能就错过了。</p>
<p>头脑特工队的导演是从他女儿那得到的灵感，也意图将这部动画做给他女儿。Rilay的一生很多奇妙的情感，长大的过程就是道别的过程，和曾经喜欢的一些东西一一道别。我做过一个很久的梦，梦里，我陪你度过了30年的青春，至少那一次我陪着你走完了我的一生，接下来的一生，我们还有很多时间，我不要跟你道别，因为我们是一家人，我们家现在只有我们两个人。我要好好陪着你，反正你拒绝也没有用，你可管不住我。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-29T02:40:26.000Z" title="2023/9/29 10:40:26">2023-09-29</time>发表</span><span class="level-item"><time dateTime="2023-09-30T08:58:16.650Z" title="2023/9/30 16:58:16">2023-09-30</time>更新</span><span class="level-item">5 分钟读完 (大约816个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/29/Linux%E9%A9%B1%E5%8A%A8-%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Linux驱动-构造和运行模块个人学习总结</a></p><div class="content"><h1 id="构造和运行模块"><a href="#构造和运行模块" class="headerlink" title="构造和运行模块"></a>构造和运行模块</h1><p>我发现对于学习任何一门知识，在最开始只能背诵或抄写别人的一些总结，所以tyro阶段我会抄写一些别人的文章，进行复习总结。<br></p>
<p>我记得小时候看过一部电影《心灵捕手》，虽然主线剧情不是我要说的，但我仍然记者记忆中有个桥段，Will在哈佛附近的酒吧遇到Skylar的时候，Will最铁的哥们查克冒充历史系学生和美女Skylar搭讪，但哈佛大学的学生克拉克看破了查克是冒牌货，于是过来考查克历史学知识，Will不止回答了这些知识，还输出了一顿自己的理解。我一直不明白，同为学生时代的我们，究竟会有什么差距呢，后来看到这一段，我才发现，只有能输出自己的东西才算是在这个领域有所了解了吧？所以tyro阶段我也只能摘抄一些别人消化的知识点，多希望我也能有一天输出自己的东西。</p>
<p><img src="/imgs/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E5%BF%83%E7%81%B5%E6%8D%95%E6%89%8B.webp"></p>
<p><small>提到《心灵捕手》我又想到:<br><br>你年轻彪悍，我如果和你谈论战争，你大可以向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友”，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。不要以为，我了解你。也许我可以通过“知识”来看你，但那不是你，除非你愿意谈谈你自己，否则我不知道你到底是谁。有时候喜欢是一种非常简单的事，我没有进入过你的世界，只听你讲过自己的故事，你人生的前25年从未参与过，我喜欢的只是我所认识的25岁的你。我不知道为什么，我真真实实的做了一场梦，很久很久的梦，我把人生的25年从头过了一遍，非常真切的感受，30年的人生所有的故事主角都是你，我才发现，我的这份喜欢似乎是贯彻了这痛苦的一生。</small></p>
<p><small>ANY WAY，写这些东西的时候我的状态是非常不好的，最近这两年我失去了爱我的外婆，得了很多很重的疾病，毕业选择的第一家公司在春招结束的时候解散了，还有一个她。在这之前我的世界没有什么情绪，对生活也没有热情，感谢她给我平庸的人生带来了一些阳光。让我捡起来对生活的热爱，谢谢你，u complete me。人生太多变化，不知道还能在一起多久，我们已经是家人了吧，不要忘记我奥，死亡不是真的逝去，遗忘才是永恒的消亡。</small></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-28T13:43:49.000Z" title="2023/9/28 21:43:49">2023-09-28</time>发表</span><span class="level-item"><time dateTime="2023-09-30T05:04:11.983Z" title="2023/9/30 13:04:11">2023-09-30</time>更新</span><span class="level-item">41 分钟读完 (大约6205个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/28/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/">I2C驱动框架学习</a></p><div class="content"><h1 id="I2C通信："><a href="#I2C通信：" class="headerlink" title="I2C通信："></a>I2C通信：</h1><p><strong>I2C集成电路总线是一种串行的通信总线，使用主从架构</strong><br>特点：<br>只需要两条双向总线（SDA串行数据线、SCL串行时钟线）<br>所有组件之间都存在简单的主从关系，连接到总线的每个设备都可以通过唯一地址进行软件寻址。<br>I2C是真正的多主设备总线，可以提供仲裁和冲突检测。</p>
<h3 id="CAN总线仲裁："><a href="#CAN总线仲裁：" class="headerlink" title="CAN总线仲裁："></a>CAN总线仲裁：</h3><p>CAN总线采用的是一种叫做“载波监测，多主掌控／冲突避免”（CSMA／CA）的通信模式。这种总线仲裁方式允许总线上的任何一个设各都有机会取得总线的控制权并向外发送数据。如果在同一时刻有2个或2个以上的设各要求发送数据，就会产生总线冲突，CAN总线能够实时地检测这些冲突并对其进行仲裁，从而使具有高优先级的数据不受任何损坏地传输。<br>当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。如果2个或2个以上同时发送就会产生竞争。CAN总线解决竞争的方法同以太网的CSMA／CD方法基本相似。此外，CAN总线做了改进并采用CSMA／CA访问总线，按位对标识符进行仲裁。各节点在向总线发送电平的同时，也对总线上的电平读取，并与自身发送的电平进行比较，如果电平相同继续发送下一位，不同则停止发送退出总线竞争。剩余的节点继续上述过程，直到总线上只剩下1个节点发送的电平，总线竞争结束，优先级高的节点获得总线的控制权。<br>CAN总线以报文为单位进行数据传输，具有最小二进制数的标识符的节点具有最高的优先级。这种优先级一旦在系统设计时确定就不能随意地更改，总线读取产生的冲突主要靠这些位仲裁解决。<br><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/CAN%E6%80%BB%E7%BA%BF%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.gif"><br>如图所示，节点A和节点B的标识符的第lO、9、8位电平相同，因此两个节点侦听到的信息和它们发出的信息相同。第7位节点B发出一个“1”，但从节点上接收到的消息却是“0”，说明有更高优先级的节点占用总线发送消息。节点B会退出发送处于单纯监听方式而不发送数据；节点A成功发送仲裁位从而获得总线的控制权，继而发送全部消息。总线中的信号持续跟踪最后获得总线控制权发出的报文，本例中节点A的报文将被跟踪。这种非破坏性位仲裁方法的优点在于，在网络最终确定哪个节点被传送前，报文的起始部分已经在网络中传输了，因此具有高优先级的节点的数据传输没有任何延时。在获得总线控制权的节点发送数据过程中，其他节点成为报文的接收节点，并且不会在总线再次空闲之前发送报文。</p>
<h3 id="数据传输协议："><a href="#数据传输协议：" class="headerlink" title="数据传输协议："></a>数据传输协议：</h3><p>主设备和从设备进行数据传输时，数据通过一条SDA数据线在主从设备之间传输0和1的串行数据。串行数据的结构分为：开始条件，地址位，读写位，应答位，数据位，停止条件。</p>
<h4 id="开始条件："><a href="#开始条件：" class="headerlink" title="开始条件："></a>开始条件：</h4><p>主设备要开始通信时发送开始信号，执行：<br>将SDA线从高压电平转换到低压电平<br>将SCL从高电平切换成低压电平</p>
<p><strong>地址位</strong>：</p>
<p>主机向从机发送&#x2F;接收数据，需要发送对应的从机地址，然后匹配总线上挂载的从机地址。</p>
<p><strong>读写位</strong>：</p>
<p>指定数据传输方向：主–&gt;从，该位为0。从–&gt;主，该位为1。</p>
<p><strong>ACK</strong>&#x2F;<strong>NACK</strong>：</p>
<p>主机每次发送完数据之后会等待从设备的应答信号ACK。<br>如果从设备发送应答信号ACK，则SDA会被拉低；<br>若没有应答信号NACK，则SDA会输出为高电平，这过程会引起主设备发生重启或者停止；</p>
<p><strong>数据块</strong>：传输数据总共有8位，由发送方设置。将数据位传输到接收方，发送后会紧跟一个ACK&#x2F;NACK位，如果接收器成功收到数据，则置为0，否则保持逻辑1。重复发送直到数据传送完。</p>
<p><strong>停止条件</strong>：先将SDA线从低电压电平切换到高电压电平；<br>再将SCL线从高电平拉到低电平。</p>
<h3 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h3><p><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png"></p>
<h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><p>提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p>
<h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><p>提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p>
<h6 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h6><p>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p>
<h5 id="第四层："><a href="#第四层：" class="headerlink" title="第四层："></a>第四层：</h5><p>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，eeprom和ov2715显然不是同一类的device，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p>
<p>第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。在linux驱动架构中，几乎不需要驱动开发人员再添加bus，因为linux内核几乎集成所有总线bus，如usb、pci、i2c等等。并且总线bus中的【与特定硬件相关的代码】已由芯片提供商编写完成，例如TI davinci平台i2c总线bus与硬件相关的代码在内核目录&#x2F;drivers&#x2F;i2c&#x2F;buses下的i2c-davinci.c源文件中；而三星的s3c-2440平台i2c总线bus为&#x2F;drivers&#x2F;i2c&#x2F;buses&#x2F;i2c-s3c2410.c</p>
<p>第三第四层又叫设备驱动层与特定device相干的就需要驱动工程师来实现了。</p>
<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>i2c_adapter与i2c_client的关系与i2c硬件体系中设配器与设备的关系一致，即i2c_client依附于i2c_adapter，由于一个适配器上可以连接多个i2c设备device，所以相应的，i2c_adapter也可以被多个i2c_client依附，在i2c_adapter中包含i2c_client的链表。同一类的i2c设备device对应一个驱动driver。driver与device的关系是一对多的关系。</p>
<p>看一下这几个重要的结构体，分别是i2c_driver i2c_client i2c_adapter，也可以先忽略他们，待会回过头来看会更容易理解</p>
<h5 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a>i2c_driver</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">	<span class="type">int</span> (*detach_adapter)(<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> (*detach_client)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>};</p>
<h5 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a>i2c_client</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit 	*/</span></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* and our access routines	*/</span></span><br><span class="line">	<span class="type">int</span> usage_count;		<span class="comment">/* How many accesses currently  */</span></span><br><span class="line">					<span class="comment">/* to the client		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a>i2c_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span><span class="comment">/* the algorithm to access the bus	*/</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* --- administration stuff. */</span></span><br><span class="line">	<span class="type">int</span> (*client_register)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line">	<span class="type">int</span> (*client_unregister)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">clist_lock</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> timeout;</span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">class_dev</span>;</span>	<span class="comment">/* the class device */</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">class_dev_released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a>i2c_algorithm</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs, </span><br><span class="line">	                   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*slave_send)(<span class="keyword">struct</span> i2c_adapter *,<span class="type">char</span>*,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*slave_recv)(<span class="keyword">struct</span> i2c_adapter *,<span class="type">char</span>*,<span class="type">int</span>);</span><br><span class="line">	u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="【i2c-adapter与i2c-algorithm】"><a href="#【i2c-adapter与i2c-algorithm】" class="headerlink" title="【i2c_adapter与i2c_algorithm】"></a>【i2c_adapter与i2c_algorithm】</h5><p>i2c_adapter对应与物理上的一个适配器，而i2c_algorithm对应一套通信方法，一个i2c适配器需要i2c_algorithm中提供的（i2c_algorithm中的又是更下层与硬件相关的代码提供）通信函数来控制适配器上产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含其使用i2c_algorithm的指针。</p>
<p>i2c_algorithm中的关键函数master_xfer()用于产生i2c访问周期需要的start stop ack信号，以i2c_msg（即i2c消息）为单位发送和接收通信数据。i2c_msg也非常关键，调用驱动中的发送接收函数需要填充该结构体</p>
<pre><code> /*
  * I2C Message - used for pure i2c transaction, also from /dev interface
  */
 struct i2c_msg &#123;
     __u16 addr;	/* slave address			*/
  	__u16 flags;		
  	__u16 len;		/* msg length				*/
  	__u8 *buf;		/* pointer to msg data			*/
 &#125;;
</code></pre>
<h5 id="【i2c-driver和i2c-client】"><a href="#【i2c-driver和i2c-client】" class="headerlink" title="【i2c_driver和i2c_client】"></a>【i2c_driver和i2c_client】</h5><p>i2c_driver对应一套驱动方法，其主要函数是attach_adapter()和detach_client()，i2c_client对应真实的i2c物理设备device，每个i2c设备都需要一个i2c_client来描述，i2c_driver与i2c_client的关系是一对多。一个i2c_driver上可以支持多个同等类型的i2c_client.</p>
<h5 id="【i2c-adapter和i2c-client】"><a href="#【i2c-adapter和i2c-client】" class="headerlink" title="【i2c_adapter和i2c_client】"></a>【i2c_adapter和i2c_client】</h5><p>i2c_adapter和i2c_client的关系与i2c硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adapter,由于一个适配器上可以连接多个i2c设备，所以i2c_adapter中包含依附于它的i2c_client的链表。<br>从图1图2中都可以看出，linux内核对i2c架构抽象了一个叫核心层core的中间件，它分离了设备驱动device driver和硬件控制的实现细节（如操作i2c的寄存器），core层不但为上面的设备驱动提供封装后的内核注册函数，而且还为小面的硬件时间提供注册接口（也就是i2c总线注册接口），可以说core层起到了承上启下的作用。</p>
<p>我们先看一下i2c-core为外部提供的核心函数（选取部分），i2c-core对应的源文件为i2c-core.c，位于内核目录&#x2F;driver&#x2F;i2c&#x2F;i2c-core.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(i2c_add_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_adapter);</span><br><span class="line">EXPORT_SYMBOL(i2c_del_driver);</span><br><span class="line">EXPORT_SYMBOL(i2c_attach_client);</span><br><span class="line">EXPORT_SYMBOL(i2c_detach_client);</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure>

<p>i2c_transfer()函数，i2c_transfer()函数本身并不具备驱动适配器物理硬件完成消息交互的能力，它只是寻找到i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer()函数真正的驱动硬件流程，代码清单如下，不重要的已删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">//如果master_xfer函数存在，则调用，否则返回错误</span></span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);<span class="comment">//这个函数在硬件相关的代码中给algorithm赋值</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的client被侦测到并被关联的时候，设备和sysfs文件将被注册。相反的，在client被取消关联的时候，sysfs文件和设备也被注销，驱动开发人员需开发i2c设备驱动时，需要调用下列函数。程序清单如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_attach_client</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	device_register(&amp;client-&gt;dev);</span><br><span class="line">	device_create_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_detach_client</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;client-&gt;dev, &amp;dev_attr_client_name);</span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_add_adapter()函数和i2c_del_adapter()在i2c-davinci.c中有调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter is called from within the algorithm layer,</span></span><br><span class="line"><span class="comment"> * when a new hw adapter registers. A new device is register to be</span></span><br><span class="line"><span class="comment"> * available for clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	device_register(&amp;adap-&gt;dev);</span><br><span class="line">	device_create_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* inform drivers of new adapters */</span></span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, <span class="keyword">struct</span> i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;attach_adapter)</span><br><span class="line">			<span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">			driver-&gt;attach_adapter(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">		driver = list_entry(item, <span class="keyword">struct</span> i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (driver-&gt;detach_adapter)</span><br><span class="line">			<span class="keyword">if</span> ((res = driver-&gt;detach_adapter(adap))) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	list_for_each_safe(item, _n, &amp;adap-&gt;clients) &#123;</span><br><span class="line">		client = list_entry(item, <span class="keyword">struct</span> i2c_client, <span class="built_in">list</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((res=client-&gt;driver-&gt;detach_client(client))) &#123;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	device_remove_file(&amp;adap-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c-davinci.c是实现与硬件相关功能的代码集合，这部分是与平台相关的，也叫做i2c总线驱动，这部分代码是这样添加到系统中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">davinci_i2c_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= davinci_i2c_probe,</span><br><span class="line">	.remove		= davinci_i2c_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;i2c_davinci&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* I2C may be needed to bring up other drivers */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">davinci_i2c_init_driver</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">subsys_initcall(davinci_i2c_init_driver);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">davinci_i2c_exit_driver</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;davinci_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(davinci_i2c_exit_driver);</span><br></pre></td></tr></table></figure>

<p>并且，i2c适配器控制硬件发送接收数据的函数在这里赋值给i2c-algorithm，i2c_davinci_xfer稍加修改就可以在裸机中控制i2c适配器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_davinci_algo</span> =</span> &#123;</span><br><span class="line">	.master_xfer	= i2c_davinci_xfer,</span><br><span class="line">	.functionality	= i2c_davinci_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在davinci_i2c_probe函数中，将i2c_davinci_algo添加到添加到algorithm系统中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adap-&gt;algo = &amp;i2c_davinci_algo;</span><br></pre></td></tr></table></figure>


<h3 id="梳理图"><a href="#梳理图" class="headerlink" title="梳理图"></a>梳理图</h3><p>有时候代码比任何文字描述都来得直接，但是过多的代码展示反而让人觉得枯燥。这个时候，需要一幅图来梳理一下上面的内容:</p>
<p><img src="/imgs/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/I2C%E9%80%82%E9%85%8D%E5%99%A8Dm368%E7%A1%AC%E4%BB%B6.png"></p>
<p>linux内核和芯片提供商为我们的的驱动程序提供了 i2c驱动的框架，以及框架底层与硬件相关的代码的实现。剩下的就是针对挂载在i2c两线上的i2c设备了device，如at24c02，例如ov2715，而编写的具体设备驱动了，这里的设备就是硬件接口外挂载的设备，而非硬件接口本身（soc硬件接口本身的驱动可以理解为总线驱动）。</p>
<p>在理解了i2c驱动架构后，我们接下来再作两方面的分析工作：一是具体的i2c设备ov2715驱动源码分析，二是davinci平台的i2c总线驱动源码。</p>
<h4 id="ov2715设备i2c驱动源码分析"><a href="#ov2715设备i2c驱动源码分析" class="headerlink" title="ov2715设备i2c驱动源码分析"></a>ov2715设备i2c驱动源码分析</h4><p>ov2715为200万的CMOS Sensor，芯片的寄存器控制通过i2c接口完成，i2c设备地址为0x6c，寄存器地址为16位两个字节，寄存器值为8位一个字节，可以理解为一般的字符设备。<br>该驱动程序并非只能用于ov2715，因此源码中存在支持多个设备地址的机制。<br>该字符设备的用到的结构体有两个，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> devAddr;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> <span class="title">client</span>;</span>   <span class="comment">//!&lt; Data structure containing general access routines.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">driver</span>;</span>   <span class="comment">//!&lt; Data structure containing information specific to each client.</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> nameSize;</span><br><span class="line">  <span class="type">int</span> users;</span><br><span class="line"></span><br><span class="line">&#125; I2C_Obj;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DEV_MAX_ADDR  (0xFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TRANSFER_BUF_SIZE_MAX   (256)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>             <span class="comment">/* Char device structure    */</span></span><br><span class="line">  <span class="type">int</span>     major;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">semLock</span>;</span></span><br><span class="line">    </span><br><span class="line">  I2C_Obj *pObj[I2C_DEV_MAX_ADDR];</span><br><span class="line"> </span><br><span class="line">  <span class="type">uint8_t</span> reg[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class="line">  <span class="type">uint16_t</span> reg16[I2C_TRANSFER_BUF_SIZE_MAX];</span><br><span class="line">  <span class="type">uint8_t</span> buffer[I2C_TRANSFER_BUF_SIZE_MAX*<span class="number">4</span>];</span><br><span class="line">  </span><br><span class="line">&#125; I2C_Dev;</span><br></pre></td></tr></table></figure>

<p>一个I2C_Obj描述一个设备，devAddr保存该设备的地址，I2C_Obj内嵌到结构体I2C_Dev，I2C_Dev管理该驱动所支持的所有设备，尽管支持多个设备，但i2c适配器只有一个，因此需要一个信号量semLock来保护该共享资源，同时只能向一个设备读写数据。成员变量cdev是我们所熟知的，每个字符设备驱动中几乎总会有一个结构体包含它，major用于保存该驱动的主设备编号，reg数组为寄存器地址为8位的寄存器地址缓冲区，reg16为寄存器地址为16的寄存器地址缓冲区。同时可以读写多个寄存器地址的值。buffer为读写的寄存器值<br>使用I2C_Dev构建一个全局变量gI2C_dev，在驱动的多个地方均需要它。<br>下面先从字符设备的基本框架入手，然后深入该驱动的细节部分。<br>首先是该字符设备的初始化和退出函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">I2C_devInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>     result, i;</span><br><span class="line">  <span class="type">dev_t</span>   dev = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  result = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, I2C_DRV_NAME);<span class="comment">//分配字符设备空间</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;I2C_DEV_MAX_ADDR; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    gI2C_dev.pObj[i]=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  gI2C_dev.major = MAJOR(dev);<span class="comment">//保存设备主编号</span></span><br><span class="line">  sema_init(&amp;gI2C_dev.semLock, <span class="number">1</span>);<span class="comment">//信号量初始化</span></span><br><span class="line">  cdev_init(&amp;gI2C_dev.cdev, &amp;gI2C_devFileOps);<span class="comment">//使用gI2C_devFileOps初始化该字符设备，gI2C_devFileOps见下文</span></span><br><span class="line">  gI2C_dev.cdev.owner = THIS_MODULE;<span class="comment">//常规赋值</span></span><br><span class="line"> gI2C_dev.cdev.ops = &amp;gI2C_devFileOps;<span class="comment">//常规赋值 result = cdev_add(&amp;gI2C_dev.cdev, dev, 1);//添加设备到字符设备中 return result;&#125;void I2C_devExit(void)&#123; dev_t devno = MKDEV(gI2C_dev.major, 0); cdev_del(&amp;gI2C_dev.cdev);//从字符设备中删除该设备 unregister_chrdev_region(devno, 1);//回收空间&#125;</span></span><br><span class="line">gI2c_devFileOps全局变量，驱动初始化会用到该结构体变量</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gI2C_devFileOps</span> =</span> &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .open = I2C_devOpen,</span><br><span class="line">  .release = I2C_devRelease,</span><br><span class="line">  .ioctl = I2C_devIoctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该驱动只实现了三个函数,open,release和ioctl，对于i2c设备来说，这已经足够了。<br>在I2C_devOpen和I2C_devOpen中并没有做实际的工作，重要的工作均在I2C_devIoctl这个ioctl中完成。I2C_devIoctl代码展示（将影响结构条理的代码去掉，稍后在做详细分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">I2C_devIoctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  I2C_Obj *pObj;</span><br><span class="line">  <span class="type">int</span> status=<span class="number">0</span>;</span><br><span class="line">  I2C_TransferPrm transferPrm;</span><br><span class="line">  </span><br><span class="line">  pObj = (I2C_Obj *)filp-&gt;private_data;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(!I2C_IOCTL_CMD_IS_VALID(cmd))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  cmd = I2C_IOCTL_CMD_GET(cmd);<span class="comment">//cmd命令转换，防止混淆，具体原因参见上一篇文章：ioctl中的cmd</span></span><br><span class="line"> </span><br><span class="line">  down_interruptible(&amp;gI2C_dev.semLock);      <span class="comment">//信号量down</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> I2C_CMD_SET_DEV_ADDR:<span class="comment">//命令1，设置设备地址</span></span><br><span class="line">      filp-&gt;private_data = I2C_create(arg);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> I2C_CMD_WRITE:  <span class="comment">//命令2，写寄存器值</span></span><br><span class="line">      </span><br><span class="line">      status = copy_from_user(&amp;transferPrm, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(transferPrm));</span><br><span class="line">      ...</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> I2C_CMD_READ:  <span class="comment">//命令3，读寄存器值</span></span><br><span class="line">    </span><br><span class="line">      status = copy_from_user(&amp;transferPrm, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(transferPrm));</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      status = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;    </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  up(&amp;gI2C_dev.semLock);      <span class="comment">//信号量up</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三个命令中最重要最复杂的是第一个I2C_CMD_SET_DEV_ADDR，设置设备地址，之所以重要和复杂，因为在I2C_create()函数中，将通过i2c-core提供的函数把该驱动程序和底层的i2c_adapter联系起来。下面是I2C_create()函数源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">I2C_create</span><span class="params">(<span class="type">int</span> devAddr)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> client;</span><br><span class="line">    I2C_Obj *pObj;</span><br><span class="line"> </span><br><span class="line">    devAddr &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(devAddr&gt;I2C_DEV_MAX_ADDR)  <span class="comment">//变量合法性判断</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(gI2C_dev.pObj[devAddr]!=<span class="literal">NULL</span>) &#123;	<span class="comment">//变量合法性判断，如果该地址的设备已经创建，则调过，防止上层错误调用</span></span><br><span class="line">      <span class="comment">// already allocated, increment user count, and return the allocated handle</span></span><br><span class="line">      gI2C_dev.pObj[devAddr]-&gt;users++;</span><br><span class="line">      <span class="keyword">return</span> gI2C_dev.pObj[devAddr];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pObj = (<span class="type">void</span>*)kmalloc( <span class="keyword">sizeof</span>(I2C_Obj), GFP_KERNEL); <span class="comment">//为pObj分配空间</span></span><br><span class="line">    gI2C_dev.pObj[devAddr] = pObj;  <span class="comment">//将分配的空间地址保存在全局变量里</span></span><br><span class="line">    <span class="built_in">memset</span>(pObj, <span class="number">0</span>, <span class="keyword">sizeof</span>(I2C_Obj));</span><br><span class="line">  </span><br><span class="line">    pObj-&gt;client.adapter = <span class="literal">NULL</span>;</span><br><span class="line">    pObj-&gt;users++;    <span class="comment">//用户基数，初始化为0，当前设为1</span></span><br><span class="line">    pObj-&gt;devAddr = devAddr;  <span class="comment">//保存设备地址</span></span><br><span class="line">    </span><br><span class="line">    gI2C_curAddr = pObj-&gt;devAddr;  <span class="comment">//gI2C_curAddr为全局的整型变量，用于保存当前的设备地址</span></span><br><span class="line">    driver = &amp;pObj-&gt;driver;  <span class="comment">//将成员变量driver单独抽取出来，因为线面要使用driver来初始化驱动</span></span><br><span class="line"> </span><br><span class="line">    pObj-&gt;nameSize=<span class="number">0</span>;<span class="comment">//i2c设备名称，注意，这里不是在/dev下面的设备节点名</span></span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;_&#x27;</span>;   </span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;A&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="string">&#x27;B&#x27;</span> + ((pObj-&gt;devAddr &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">    pObj-&gt;name[pObj-&gt;nameSize++] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    driver-&gt;driver.name = pObj-&gt;name; <span class="comment">//保存刚才设置的name</span></span><br><span class="line">    driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class="line">    driver-&gt;attach_adapter = I2C_attachAdapter;   <span class="comment">//这个很重要，将驱动连接到i2c适配器上，在后面分析</span></span><br><span class="line">    driver-&gt;detach_client = I2C_detachClient;	<span class="comment">//这个很重，在后面分析</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((ret = i2c_add_driver(driver)))	<span class="comment">//使用i2c-core（i2c_register_driver函数）的接口，注册该驱动，i2c_add_driver实质调用了driver_register()</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk( KERN_ERR <span class="string">&quot;I2C: ERROR: Driver registration failed (address=%x), module not inserted.\n&quot;</span>, pObj-&gt;devAddr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">      gI2C_dev.pObj[pObj-&gt;devAddr] = <span class="literal">NULL</span>;</span><br><span class="line">      kfree(pObj);    </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他两个命令是I2C_CMD_WRITE和I2C_CMD_READ，这个比较简单，只需设置寄存器地址的大小以及寄存器值的大小，然后通过i2c-core 提供的i2c_transfer()函数发送即可。例如I2C_wirte()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">I2C_write</span><span class="params">(I2C_Obj *pObj, <span class="type">uint8_t</span> *reg, <span class="type">uint8_t</span> *buffer, <span class="type">uint8_t</span> count, <span class="type">uint8_t</span> dataSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> i;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(pObj==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line"> </span><br><span class="line">  client = &amp;pObj-&gt;client;<span class="comment">//得到client信息</span></span><br><span class="line">  <span class="keyword">if</span>(!client-&gt;adapter)</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(dataSize&lt;=<span class="number">0</span>||dataSize&gt;<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">  </span><br><span class="line">    msg-&gt;addr = client-&gt;addr;<span class="comment">//设置要写的i2c设备地址</span></span><br><span class="line">    msg-&gt;flags= <span class="number">0</span>;<span class="comment">//一直为0</span></span><br><span class="line">    msg-&gt;buf  = data;<span class="comment">//date为准备i2c通信的缓冲区，这个缓冲区除了不包含设备地址外，要包括要目标寄存器地址，和要写入该寄存器的值</span></span><br><span class="line">		</span><br><span class="line">    data[<span class="number">0</span>] = reg[i];<span class="comment">//寄存器地址赋值</span></span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(dataSize==<span class="number">1</span>) &#123;<span class="comment">//寄存器值长度为1</span></span><br><span class="line">       data[<span class="number">1</span>]  = buffer[i];<span class="comment">//寄存器值赋值</span></span><br><span class="line">       msg-&gt;len = <span class="number">2</span>;  	<span class="comment">//设置data长度为2	</span></span><br><span class="line">    &#125;	<span class="keyword">else</span> <span class="keyword">if</span>(dataSize==<span class="number">2</span>) &#123;<span class="comment">//寄存器值长度为2</span></span><br><span class="line">       data[<span class="number">1</span>] = buffer[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">       data[<span class="number">2</span>] = buffer[<span class="number">2</span>*i];</span><br><span class="line">       msg-&gt;len = <span class="number">3</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    err = i2c_transfer(client-&gt;adapter, msg, <span class="number">1</span>);<span class="comment">//调用i2c-core中的i2c_transfer发送i2c数据</span></span><br><span class="line">    <span class="keyword">if</span>( err &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析上一段代码void *I2C_create(int devAddr)函数中的i2c_driver结构体部分的代码，下面的代码是从上面I2C_create抽取出来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver-&gt;driver.name = pObj-&gt;name;</span><br><span class="line">driver-&gt;id = I2C_DRIVERID_MISC;</span><br><span class="line">driver-&gt;attach_adapter = I2C_attachAdapter;</span><br><span class="line">driver-&gt;detach_client = I2C_detachClient;</span><br></pre></td></tr></table></figure>
<p>在i2c_driver结构体中针对attach_adapter有这样的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Notifies the driver that a new bus has appeared. This routine</span></span><br><span class="line"><span class="comment"> * can be used by the driver to test if the bus meets its conditions</span></span><br><span class="line"><span class="comment"> * &amp; seek for the presence of the chip(s) it supports. If found, it </span></span><br><span class="line"><span class="comment"> * registers the client(s) that are on the bus to the i2c admin. via</span></span><br><span class="line"><span class="comment"> * i2c_attach_client.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>意思是通知驱动，i2c适配器已经就绪了，这时可以讲device的driver连接到总线bus上。所以I2C_attachAdapter的作用就是检测client，然后将client连接上来。attach_adapter和detach_client由内核驱动自动调用，我们只需在调用的时候实现必要的功能即可，如下代码展示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">I2C_attachAdapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> I2C_detectClient(adapter, gI2C_curAddr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">I2C_detectClient</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="type">int</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Obj *pObj;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(address &gt; I2C_DEV_MAX_ADDR) &#123;</span><br><span class="line">      printk( KERN_ERR <span class="string">&quot;I2C: ERROR: Invalid device address %x\n&quot;</span>, address);        </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    pObj = gI2C_dev.pObj[address];</span><br><span class="line">    <span class="keyword">if</span>(pObj==<span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk( KERN_ERR <span class="string">&quot;I2C: ERROR: Object not found for address %x\n&quot;</span>, address);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    client = &amp;pObj-&gt;client;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(client-&gt;adapter)</span><br><span class="line">      <span class="keyword">return</span> -EBUSY;  <span class="comment">/* our client is already attached */</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(client, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_client));</span><br><span class="line">    client-&gt;addr = pObj-&gt;devAddr;</span><br><span class="line">    client-&gt;adapter = adapter;</span><br><span class="line">    client-&gt;driver = &amp;pObj-&gt;driver;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((err = i2c_attach_client(client)))</span><br><span class="line">    &#123;</span><br><span class="line">        printk( KERN_ERR <span class="string">&quot;I2C: ERROR: Couldn&#x27;t attach %s (address=%x)\n&quot;</span>, pObj-&gt;name, pObj-&gt;devAddr);</span><br><span class="line">        client-&gt;adapter = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终I2C_detectClient()函数调用了i2c-core中的i2c_attach_client，从名字上就能看出什么意思，连接client设备。<br>当内核驱动准备删除该驱动时会自动调用i2c_driver的成员函数：detech_client，因此我们需要实现删除client设备的函数然后赋值给改函数指针，detech_client的说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tells the driver that a client is about to be deleted &amp; gives it </span></span><br><span class="line"><span class="comment"> * the chance to remove its private data. Also, if the client struct</span></span><br><span class="line"><span class="comment"> * has been dynamically allocated by the driver in the function above,</span></span><br><span class="line"><span class="comment"> * it must be freed here.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>下面是detech_client调用的函数代码清单，该函数最终调用了i2c-core提供的i2c_detach_client，用于取消client设备的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">I2C_detachClient</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"><span class="keyword">if</span>(!client-&gt;adapter)</span><br><span class="line">    <span class="keyword">return</span> -ENODEV; <span class="comment">/* our client isn&#x27;t attached */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>((err = i2c_detach_client(client))) &#123;</span><br><span class="line">    printk( KERN_ERR <span class="string">&quot;Client deregistration failed (address=%x), client not detached.\n&quot;</span>, client-&gt;addr);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">client-&gt;adapter = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p><small>misslyh20080512202305122023080719980106202309281520825879280398965</small></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-30T08:43:59.000Z">2023-09-30</time></p><p class="title"><a href="/2023/09/30/MissingLi/">MissingLi</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-29T11:24:05.000Z">2023-09-29</time></p><p class="title"><a href="/2023/09/29/%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F%E8%A7%82%E8%B5%8F%E6%8A%A5%E5%91%8A-%E9%87%8D%E8%A6%81/">头脑特工队观赏报告(重要)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-29T02:40:26.000Z">2023-09-29</time></p><p class="title"><a href="/2023/09/29/Linux%E9%A9%B1%E5%8A%A8-%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Linux驱动-构造和运行模块个人学习总结</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-28T13:43:49.000Z">2023-09-28</time></p><p class="title"><a href="/2023/09/28/I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/">I2C驱动框架学习</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Linux Kernel tyro" height="28"></a><p class="is-size-7"><span>&copy; 2023 李嘉图</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>